{"pages":[],"posts":[{"title":"8 Vezir Probleminin Genetik Algoritma ile Çözümü","text":"Merhaba arkadaşlar, bu yazımda algoritma severlerin mutlaka bildiği 8 vezir probleminin genetik algoritma ile çözümünden bahsedeceğim. Her ne kadar 8 vezir desek de asıl amacımız n adet vezirin nxn’lik satranç tahtasına uygun bir şekilde yerleştirilmesini sağlamaktır. Bu yüzden 8 vezir yerine, n vezir problemi demek daha doğru olacaktır. n Vezir Problemi AmacıSatranç oynayanlar bilir, bir vezir yatay, dikey ve çapraz hamleler yapabilir. Amacımız n adet veziri, nxn’lik bir satranç tahtasına birbirini kesmeyecek şekilde yerleştirmek. n Vezir Probleminin Geçmişi8 vezir problemi ilk olarak 1848 yılında satranç oyuncusu Max Bezzel tarafından ortaya atılmıştır. Gauss ve Georg Cantor gibi pek çok matematikçi tarafından incelenmiştir. İlk çözümü Franz Nauck 1850’de ortaya atmıştır, aynı zamanda n vezir problemi haline getirmiştir. n Vezir Probleminin Genetik Algoritma ile ÇözümüGenetik algoritma ile ilgili daha önceden bir yazı yazmıştım. Temel seviyede bilgiyi şuradan edinebilirsiniz. Evrimsel Sürecin Simülasyonu – Genetik Algoritmalar – 1 Fitness FunctionBildiği üzere genetik algoritmada asıl işi yapan Fitness Function‘dır. İyi düşünülerek yazılmış bir fitness function sonuca ulaşmamızı büyük bir oranda etkiler. 8 vezir probleminde ise algoritmamız şu şekilde olacak: 8×8’lik satranç tahtasının ilk sütunundan başlayarak bir vezir seçilir Seçilen veziri, tahtanın sağında yer alan kesmeyen vezir sayısı bulunur Bu kontrol tüm sütunlar için uygulanır ve toplam kesmeyen vezir sayısı bulunur Not: 8 vezirlik bir problemin en uygun fitness function sonucu 28 olarak hesaplanır. Problem için hazırladığım fitness function 12345678910111213141516171819202122232425262728293031public class MyProblemFitness : IFitnessFunction{ public double Evaluate(IChromosome chromosome) { var genes = ((PermutationChromosome)chromosome).Value; double result = 0; for (int x1 = 0; x1 &lt; genes.Length - 1; x1++) { int y1 = genes[x1]; int sagdakiVezirSayisi = genes.Length - 1 - x1; for (int x2 = x1 + 1; x2 &lt; genes.Length; x2++) { int y2 = genes[x2]; if (y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2) { sagdakiVezirSayisi -= 1; } } result += sagdakiVezirSayisi; } return result; }} Kromozom YapısıÖrnek kromozom: [ 5, 1, 3, 0, 2, 7, 6, 4 ] Bu problem için permütasyon kodlamalı kromozom yapısı daha uygun olacaktır. Kromozomun birinci elamanı olan 5 değeri, vezirin sıfırıncı sütun ve beşinci satırda yer aldığını ifade etmektedir. C# ile ÇözümüProblemin çözümde kütüphane kullanmak çözüm süresinin uzamasını ve aynı işlerin (crossover, mutation, selection…) tekrarını önlemek açısından önemli. Bu yüzden AForge.Net Genetic ve GeneticSharp kütüphanelerini kullandım. Problemi her iki kütüphane ile çözdüm. AForge.Net kütüphanesinin performası bu problem için daha uygun geldi bana. Tavsiyem AForge.Net Genetic. Problemin çözümünü Github’ta paylaştım. İsterseniz inceleyebilirsiniz, https://github.com/mehmetemineker/Genetic8QueensSolutionWithAForge – AForge.Net Genetic https://github.com/mehmetemineker/Genetic8QueensSolutionWithGeneticSharp – GeneticSharp Kaynak: https://tr.wikipedia.org/wiki/Sekiz_vezir_bulmacas%C4%B1","link":"/8-vezir-probleminin-genetik-algoritma-ile-cozumu/"},{"title":"ASP.Net MVC Stars Rating Helper","text":"Geliştirmiş olduğum stars rating helperı. Açık kaynak olarak Github repomdan bakabilirsiniz. https://github.com/mehmetemineker/FontAwesome-SuperStarsRating-Helper","link":"/asp-net-mvc-stars-rating-helper/"},{"title":"C# ToUpper ve ToLower Türkçe Karakter Sorunu","text":"ToUpper ve ToLower kullandığınızda Türkçe karakterlerde sıkıntı yaşattığını gördüyseniz doğru yerdesiniz. CultureInfo ile bu sorunu giderebiliriz. 1string test = test = test.ToUpper(new CultureInfo(\"tr-TR\", false));","link":"/c-toupper-ve-tolower-turkce-karakter-sorunu/"},{"title":"Dropbox Üzerine SVN Kurulumu","text":"Freelancerlar ve küçük takımlar için Dropbox üzerine SVN kurulumu.Geliştirdiğiniz projenin kaynak kodlarının kaybını en aza indirmek, versiyon kontrolü sağlamak ve takım halinde çalışırken çakışmaların önüne geçmek istiyorsanız, SVN kolay kurulumu ve kolay kullanımı ile yazılım geliştiricileri kendine çekmeyi başarıyor. Ben de Şubat 2016 dan beri SVN kullanıyorum. İlk başlarda temel amacını kavramakta zorlansam da artık kişisel projelerimde bile SVN kullanmaya karar verdim. Bu yazıyı yazmamdaki amaç server kurulum derdi olmadan direkt Dropbox üzerinde tanımladığım bir klasöre SVN bağlayıp kullanmak. Kısa bir hatırlatma; ben Dropbox kullanıyorum. Dropbox şart değil. Google Drive, One Drive, Yandex gibi benzer depolama alanlarını da kullanabilirsiniz. Şimdi kuruluma geçelim: Kullanılan yazılımlar TortoiseSVN Dropbox İndirime ve kurulum işlemleri tamamlandıktan sonra yapılması gerekenler; Dropbox hesabımız ile oturum açıp Dropbox klasörünün içerisine yeni boş bir klasör oluşturalım. Klasörü oluşturduk. Şimdi sırada SVN Repository oluşturmak. Klasöre sağ tıklayıp açılan menüden TortoiseSVN &gt; Create repository here tıklıyoruz. Create repository here a tıkladığımızda Repository created penceresi açıldı. Burda Create folder structure butonuna tıklıyoruz. Success sonucunu aldığımızda Dropbox ile olan işlemimizi başarıyla tamamlamış olduk. Şimdi oluşturduğum SVN klasörünü kendi local diskim üzerindeki bir klasöre bağlayacağım. Herhangi bir boş klasöre gidip sağ tıklayıp açılan menüden SVN Checkout… diyorum. Sonra açılan Checkout penceresinden URL of repository alanına Dropbox üzerinde oluşturduğum SVN klasörünün yolunu belirtiyorum. Checkout directory ise bizim local diskimizdeki klasörün yolu. OK butonuna bastıktan sonra Checkout Finished! penceresi geliyor ve SVN klasörleri oluşturuluyor. *Soru: *Peki diğer geliştiriciler benim Dropbox üzerinde oluşturduğum SVN klasörüne nasıl bağlanacaklar? *Cevap: *Çok basit. Dropbox hesap sahibi klasörü paylaşıma açacak. Bir yazının daha sonuna geldik. Bir sonraki yazım Visual Studio ve SVN ile ilgili olacak. Visual Studio ile SVN Kullanımı başlıklı yazıma gitmek ister misiniz? Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/dropbox-uzerine-svn-kurulumu/"},{"title":"EF6 DbContext Unit Test Mock","text":"Merhaba, çok uzun zamandır bir şeyler yazmıyordum. Tam anlamıyla bir yazı olmasa da bir başlangıç yapmak adına bu küçük paylaşımı yapmak istedim. Bu paylaşımımda EF6 DbContext Mock işlemi için hazırladığım kodu göreceksiniz. Bilindiği üzere unit test yazmanın en önemli ve en sıkıntılı noktalarından birisi mocklama işlemi. DbContext sınıfınız eğer test edilebilir olarak geliştirilmediyse bu süreç can sıkıcı olabiliyor. Var olan yapınızı da değiştirmek ürkütücü geliyorsa, paylaşmış olduğum kodlar ile çok fazla değişiklik yapmadan DbContext nesnemizi mocklayarak test edilebilir hale getirebilirsiniz. Mocklama işlemi için Moq kütüphanesinden faydalandım.Olmazsa olmaz Utility sınıfımız ile kodlar şöyle :) 12345678910111213141516171819202122232425public class Utility{ public static (Mock&lt;D&gt; mockDbContext, Mock&lt;MockableDbSetWithExtensions&lt;T&gt;&gt; mockDbSet) MockDb&lt;D, T&gt;(List&lt;T&gt; sourceList) where D : DbContext where T : class { var queryable = sourceList.AsQueryable(); var mockDbContext = new Mock&lt;D&gt;(); var mockDbSet = new Mock&lt;MockableDbSetWithExtensions&lt;T&gt;&gt;(); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.Provider).Returns(queryable.Provider); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.Expression).Returns(queryable.Expression); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.ElementType).Returns(queryable.ElementType); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.GetEnumerator()).Returns(queryable.GetEnumerator()); mockDbSet.Setup(d =&gt; d.Add(It.IsAny&lt;T&gt;())).Callback&lt;T&gt;((s) =&gt; sourceList.Add(s)); return (mockDbContext, mockDbSet); }}public abstract class MockableDbSetWithExtensions&lt;T&gt; : DbSet&lt;T&gt; where T : class{ public abstract void AddOrUpdate(params T[] entities); public abstract void AddOrUpdate(Expression&lt;Func&lt;T, object&gt;&gt; identifierExpression, params T[] entities);} Bu metod 2 değişkenli Tuple döndürüyor. MockableDbSetWithExtensions nesnesi ile AddOrUpdate metodlarını test ediyorum. Bunun yerine sadece DbSet nesnesini de kullanabilirsiniz. Kullanımı 123var fakeData = new List&lt;MyDbSet&gt;()var (mockDbContext, mockDbSet) = Utility.MockDb&lt;MyContext, MyDbSet&gt;(fakeData);mockDbContext.Setup(c =&gt; c.MyDbSet).Returns(mockDbSet.Object); Bu tanımlamaları yaptıktan sonra test etmek istediğimiz metodun ait olduğu sınıfın yapıcı metoduna parametre olarak DbContext nesnemizi geçmemiz gerekiyor. DI kullanılıyorsa manuel olarak geçmemize gerek yok. Eğer yapımızı çok fazla değiştirmek istemiyorsanız yapıcı metoda parametre geçmek biraz daha kolay olacaktır. Kaynakhttps://docs.microsoft.com/tr-tr/ef/ef6/fundamentals/testing/mocking","link":"/ef6-dbcontext-unit-test-mock/"},{"title":"EntityFramework AsNoTracking Nedir?","text":"Merhaba arkadaşlar, bugün .Net Core projem için Generic Repository örneği yapıyordum. Github üzerinden örnek kodlara bakarken Entity sorgularındaki AsNoTracking ifadesini gördüm. Yaklaşık 4 yıldır MVC projelerinde görev alıyorum. AsNoTracking ifadesini şimdiye kadar fark edemediğim için üzüldüm, şimdi bunu keşfettiğim için de mutluyum. 🙂 Sizin de bundan faydalanmanızı istediğim için çok geciktirmeden blogumda paylaşmak istedim. Bildiğiniz üzere EntityFramework ile bir select işlemi yaptığınızda, gelen data içeriğini güncelleyip SaveChanges yaparsak değişiklikler veritabanına yansır. Bu işlemi her zaman istemiyor olabilirsiniz. Bu durumda AsNoTracking ifadesi yardımımıza koşuyor. Bu ifade ile yaptığımız entity sorgusu sadece okumalıktır. Üzerinde değişiklik yapıp SaveChanges yaptığımızda veritabanında hiçbir değişiklik olmaz. Bu da bize minimum bellek kullanımı ve optimum performans sağlayacaktır. Çok hoj 🙂 AsNoTracking PerformansıAsNoTracking ifadesinin performansı ne kadar etkilediğine görsel olarak birlikte bakalım: AsNoTracking KullanımıBu ifadenin kullanımı ise aşağıda göreceğiniz üzere çok kolay: 1context.Set&lt;TEntity&gt;().AsNoTracking(); Diğer bir kullanım yönetimi ise DbContext ayarlarından yapılabilir. Bu da tüm queryler için geçerli olacaktır: 1context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; Kaynaklar: http://blog.staticvoid.co.nz/2012/entity_framework_and_asnotracking/ https://docs.microsoft.com/en-us/ef/core/querying/tracking","link":"/entityframework-asnotracking-nedir/"},{"title":"Evrimsel Sürecin Simülasyonu – Genetik Algoritmalar – 1","text":"Selam arkadaşlar, bu makalemde birkaç aydır üzerinde araştırmalar yaptığım genetik algoritmalar hakkında edindiğim bilgileri sizlerle paylaşmak istedim. Genetik algoritamlar konusuna giriş yapmadan önce işi biraz daha temelden alarak “Algoritamanın” ne olduğu konusuna değinmek istiyorum. Bilgisayar bilimleri veya matematik bilimleri ile ilgilensek de ilgilenmesek de aslında algoritmalar hayatımız her yerinde. Günlük hayatımızda bilinçli veya bilinçsiz bir çok algoritmayı yerine getiririz. Bu algoritmalara en güzel örneği “yemek yapmak” eylemini gösterebiliriz. Yemek yaparken izlediğimiz tüm adımlar daha önceden belirlenmiş kurallar çerçevesinde ilerletilir. Bu bağlamda algoritma, en basit tanımıyla, bir problemin çözümünde izlenecek yol anlamına gelir. Algoritma sözcüğünün kökenine bakacak olursak; modern algoritmanın babası olarak anılan Türk bilim adamı El Harezmî, Cebir isimli kitabında algoritma çalışmalarından bahsetmiştir. Yazdığı kitap Avrupa dillerine de çevrilmiştir. Algoritma kelimesi, isminin Latin biçimi olan Algoritmi’ den türetilmiştir. Ayrıca ismi, İspanyolca ve Portekizce dillerinde basamak anlamına gelen guarismo ve algarismo kelimelerinin kökenini oluşturmaktadır. Algoritmayı oluşturan 3 temel bileşen vardır. Bunlar, değişkenler, algoritmanın kendisi olan mantıksal adımlar ve akış diyagramı. Bu ifadeleri açıklayacak olursak; değişken; değerlerin, yani verilerin tutulduğu-saklandığı elemanlar, mantıksal adımlar; algoritmanın adımları, akış diyagramı ise; mantıksal adımları görsel olarak ifade etme biçimi olarak tanımlayabiliriz. Örnek Akış Diyagramı Algoritma konusuna kısaca değindikten sonra makalemin asıl konusuna geçiş yapabiliriz. Bir problemin çözümünde gözlem yapmak problemin çözüm gidişatını olumlu yönde etkiler. Bilim insanları da bazı mantıksal sorunların çözümüne gözlem yaparak ulaşmışlardır. Bu çözüm yöntemlerine örnek verecek olursak; tavlama benzetimi, tabu arama algoritması, karınca kolonisi algoritması, genetik algoritmalar vb. *Tavlama Benzetimi (Simulated Annealing): *Katıların ısıtılması ve sonra kristalleşmeye kadar yavaş yavaş soğutulması esasına dayanan bir algoritmadır. Kirkpatrick ve arkadaşları tarafından 1983 yılında önerilmiştir. Sıcaklık değeri, elde edilen en iyi çözümden daha kötü bir çözümün kabul edilme olasılığını belirlemek için kullanılır. Tabu Arama (Tabu Search): Bu algoritma Glover tarafından 1986 yılında geliştirilmiştir. Yerel optimum tuzaklarından kaçarak global optimumu bulan yüksek seviyeli bir sezgisel yöntemdir. Karınca Kolonisi Algoritması (Ant Colony Algorithm): Karıncaların yuvaları ile yiyecek noktaları arasındaki en kısa yolu bulma kabiliyetlerinden esinlenilerek geliştirilmiştir. Alternatif birçok yolun söz konusu olduğu durumlarda karıncalar, öncelikle bu yollara eşit olasılıkla dağılırlarken belli bir süre sonra en kısa olan yolda yoğunlaşmaktadır. Genetik Algoritmalar, John Holland tarafından 1975 yılında, Charles Darwin’ in doğal evrim teorisinden esinlenilerek geliştirilmiştir. Bu algoritma, bir sonraki kuşağın yavrularını üretmek için en iyi bireylerin üreme için seçildiği doğal seleksiyon sürecini yansıtmaktadır. Geleneksel yöntemlerle çözümü çok zor olan veya imkansıza yakın olan problemlerin çözümünde kullanılmaktadır. Mühendislik alanında daha çok optimizasyon amaçlı kullanılmakta ve diğer geleneksel yöntemlere göre daha iyi sonuç vermektedir. Genetik algoritmanın genel işleyişini iyi anlamak için öncelikle evrimsel süreci iyi anlamak gereklidir: Evrim, canlı türlerinin yani bir popülasyon içerisindeki her bir bireyin nesilden nesile kalıtsal değişime uğrayarak, ortamlara adaptasyonlarını sağlayan “en iyi“leştirme sürecidir. Bireylerin geçirdiği bu değişimler, bireylerin hayatları boyunca geçirdiği değişimler değildir, evrimsel süreç içerisinde nesillerde meydana gelen değişimlerdir. Evrimin temel dayanağı en iyinin hayatta kalması prensibidir. En iyi olamayan bireyler üreyemezler ve yok olurlar. Bu gidişatın sonucunda en iyilere sahip bir popülasyon meydana gelir. Genetik algoritmanın genel evrim ilkeleri dışında belirgin standartları yoktur. Algoritma probleme göre bazı değişikliklere uğrayabilir. Örneğin; bireyin en iyi olup olmadığını (“en iyi” ifadesi görecelidir) kontrol etme tekniği probleme göre farklılık gösterebilir. Genetik algoritma evrimsel süreci bilgisayar ortamında taklit eder. Tek bir çözüm geliştirilmesi yerine, çözümlerden meydana gelen bir küme oluşturur. Çözümlerden meydana gelen bu kümeye genetik algoritma jargonunda popülasyon veya nüfus olarak adlandırılır. Bir popülasyon vektör, kromozom veya birey adı verilen sayı dizilerinden oluşur. Birey içindeki her bir elemana gen adı verilir. Popülasyonda yer alacak olan bireylere, evrimsel süreç doğrultusunda genetik algoritma işlemleri belirler. Genetik algoritma kapsamında temel 3 işlem (operatör) vardır. Bunlar; çaprazlama (crossover), mutasyon (mutation) ve *seçilim (selection) *işlemleridir. Genetik algoritmada kullanılan temel kavramları açıklayacak olursak; Gen: Genetik bilgi taşıyan en küçük yapıdır. Kromozom: Genlerden meydana gelen diziye kromozom denir. Her bir kromozom, olası çözümleri gösterirler. Popülasyon: Kromozomlardan meydana gelmiş topluluğa denir. Her bir popülasyon, alternatif çözüm kümesidir. Bir sonraki makale: Genetik Algoritmada Kullanılan Operatörler","link":"/evrimsel-surecin-simulasyonu-genetik-algoritmalar-1/"},{"title":"Geliştiriciler İçin Offline Dokümantasyon – Zeal","text":"Zeal – Offline Documentation Browser programı ile offline olarak dokümantasyon ihtiyacınızı giderebilirsiniz. Zeal, şuan 195 yazılım teknolojisinin dokümantasyonunu offline olarak sunmakta. İsterseniz masaüstü uygulamasını indirmek yerine kullandığınız IDE üzerine plugin olarak ekleme şansınız da var. IDE Pluginler de şunlar; Atom: https://atom.io/packages/dashBrackets: https://github.com/anephew/brackets-zealEmacs: https://github.com/jinzhu/zeal-at-pointIntelliJ IDEA: https://plugins.jetbrains.com/plugin/7351?pr=ideaKTextEditor (Kate, KWrite, KDevelop, Kile, etc): https://github.com/g3ar/ZealSearchSublime Text: https://github.com/vaanwd/ZealVIM: https://github.com/KabbAmine/zeavim.vim","link":"/gelistiriciler-icin-offline-dokumantasyon-zeal/"},{"title":"Github Pages Custom Domain","text":"Daha önceki yazım Github Pages ile Geliştiricilere Ücretsiz Blog üzerineydi. Bu yazımda da {kullanıcı adım}.github.io şeklinde olan alan adını istediğimiz bir alan alan adı ile açmayı anlatacağım. Almış olduğumuz alan adının yönetim ekranından 2 adet A kaydı oluşturmamış gerekiyor. A kayıtlarının ikisine de alan adımızı yazıyoruz. Ip adreslerine ise Github Pages Custom Domain IP‘lerini yazmamız gerekiyor. Github Pages Cutom Domain IPs 192.30.252.153 192.30.252.154 Örnek A kaydı şu şekilde olacak: mht.ist – 192.30.252.153 mht.ist – 192.30.252.154 A kaydını tamamladıktan sonra Daha önce oluşturduğumuz Github çalışma alanımıza gidip yeni bir dosya oluşturuyoruz. Dosyanın adına CNAME yazıyoruz. İçeriğine ise kendi alan adımızı yazıyoruz. Ve artık bloğumuza {kullanıcı adım}.github.io şeklide erişmek yerine direkt kendi belirlediğimiz alan adı ile erişiyoruz. Benim alan adım mht.ist.Burayı blog gibi değil de not defteri gibi kullanmaya çalışacağım. Belki ilerde sadece onu kullanırım. Github Pages hakkında daha detaylı dökümantasyon için şu adrese gidebilrisiniz. Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/github-pages-custom-domain/"},{"title":"Github Pages ile Geliştiricilere Ücretsiz Blog","text":"Geliştiriciler için basit ve hızlı blog oluşturma.Geliştirici olan herkesin hayalidir bir blog tutmak. Jekyll ile bu çok kolay. Bu yazımda, Github üzerinde HTML sayfası nasıl görüntülenir? Jekyll nedir? Jekyll Nasıl kurulur? Jekyll Projesi Nasıl Oluşturulur? Nasıl yayınlanır? konuları üzerinde duracağım. Github Üzerinde HTML Sayfası Nasıl Görüntülenir?İlk olarak Github hesabımıza giriş yaptıktan sonra New repository butonuna basarak yeni bir çalışma alanı oluşturalım. New repository butonuna bastığımızda aşağıdaki Create a new repository sayfası açılacak. Bu sayfadan projemizin adını {kullanıcı adım}.github.io şeklinde veriyoruz. İsterseniz README dosyasını da ekleyebilirsiniz. Sonra Create repository butonuna bastığımızda yeni çalışma alanımız oluşmuş olacak. Github Pages’ ın yayına girip girmediğini kontrol etmek için çalışma alanının ayarlarına göz atmamız gerekiyor. Ayarlar sayfasına girdiğimizde **Github Pages** alanında aşağıdaki resimde olduğu gibi gözüküyorsa Github Pages başarıyla yayına girmiştir. Bu bağlantıya tıkladığımız zaman 404 sayfası ile karşılaşacağız. Çünkü index.html dosyası oluşturmadık. Index.html dosyası oluşturmak için çalışma alanımıza geri dönüp Create new file butonuna basarak yeni bir dosya oluşturalım. Açılan sayfadan dosyamızın adını index.html olarak belirledikten sonra içeriğine bir şeyler yazalım. Index.html dosyasının içeriğini hallettikten sonra aynı sayfanın hemen altında yer alan Commit new file butonuna tıklıyoruz. Index.html sayfamız oluştuğuna göre artık Github sayfamızı tekrar kontrol edebiliriz. Eğer oluşturduğunuz index.html dosyası görüntülendiyse doğru yoldasınız. Buraya kadar hiçbir sorun yaşamadan geldiyseniz devam edebiliriz. Jekyll Nedir?Jekyll, Ruby ile yazılmış bir uygulamadır. Basit ama güçlü bir alt yapıya sahip statik site oluşturucusudur. Markdown veya Textile formatında yazdığınız sayfayı statik HTML sayfasına dönüştürür. Jekyll Nasıl Kurulur?Dikkat! Ben Windows kullandığım için Windows kurulumunu baz alıyorum. İlk olarak Ruby‘yi indirip kurmamız gerekiyor. www.ruby-lang.org/tr/downloads Ruby’yi kurduktan sonra RubyGems‘i kurmamız gerekiyor. rubygems.org/pages/download Kurulumun başarılı olup olmadığını anlamak için Komut Satırını (Nam-ı diğer Cemede) açıyoruz. Ruby için aşağıdaki komutu yazıyoruz. 1ruby -v Eğer versiyon numarası gözükürse başarıyla yüklenmiştir Aynı durum RubyGems için de geçerli. Bunun için de aşağıdaki komutu yazıyoruz. 1gem -v Versiyon numarasını gördüysek sıkıntı yok. Ruby’yi ve RubyGems’i yükledikten sonra şimdi sıra Jekyll‘in yüklenmesine geldi. Bu sefer komut satırına aşağıdaki komutu yazıyoruz. 1gem install jekyll Jekyll’in yüklenmesi tamamlandığında yine versiyon kontrolü ile yüklenme durumuna bakabilirsiniz. Bütün kurulumları tamamladık. Şimdi Jekyll ile ilk blogumuzu oluşturmaya hazırız. Jekyll Projesi Nasıl Oluşturulur?Yeni boş bir klasör açıp içerisinde komut satırını çalıştıralım ve aşağıdaki komutu çalıştıralım. 1jekyll new {proje adı} Projemiz oluştuktan sonra projemizin bulunduğu dizine geçelim. 1cd {proje adı} Projemizin bulunduğu dizine geçtikten sonra localhost üzerinde test edebiliriz. Bunun için yine komut satırına aşağıdaki komutu yazalım. 1jekyll serve Bu komutu yazdığımızda localhost:4000 adresinden projemizin çalışır halini görebiliriz. Projemizi oluşturduk. Şimdi sırada Github üzerindeki çalışma alanına atmak kaldı. Nasıl yayınlanır?Oluşturduğumuz Jekyll projemizi Github çalışma alanımıza atmak için Github Desktop uygulamasını indirip kurmamız gerekiyor. desktop.github.com Github Desktop uygulamasını kurduktan sonra Github üzerindeki projemize giderek Clone or download butonuna tıklayıp açılan yerden Open in Desktop butonuna tıkladığımızda Github Desktop uygulaması devreye girecek ve çalışma alanımızı nereye oluşturacağını seçtikten sonra çalışma alanımızın kendi diskimize klonlandığını göreceğiz. Jekyll projemizi klonladığımız Github çalışma alanına kopyala yapıştır yaptıktan sonra Commit ediyoruz. Commit ve Sync işlemlerini tamamladıktan sonra projemizin {kullanıcı adım}.github.io adresinden çalışıp çalışmadığını kontrol edebiliriz. Bu yazım da burada son bulsun. Bir sonraki yazımda {kullanıcı adım}.github.io şeklinde olan adresi istediğimiz bir alan adı ile açma yani Custom Domain üzerine olacak. Github Pages Custom Domain üzerine yazdığım yazımı da okumak ister misin? Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/github-pages-ile-gelistiricilere-ucretsiz-blog/"},{"title":"Javascript Function All Parameters Is Empty","text":"Bir fonksiyondaki parametrelerin hiçbiri girilmediyse bunun kontrolünü ES ile halledebiliriz. 123456function Test(a,b,c,...){ if(arguments.length === 0){ //Hiçbir paremetre girilmemiştir. //Tek tek sorgulamaya gerek kalmaz }}","link":"/javascript-function-all-parameters-is-empty/"},{"title":"Javascript Function Parameter Set Default Value","text":"Bir fonksiyonun parametresine varsayılan değeri aşağıdaki gibi atıyoruz. 123456789101112131415function Hello(name){ var name = name || 'Mehmet'; Console.log('Hello ' + name);}Hello();Hello('Emin');Hello(0);/*Result:-&gt; Hello Mehmet-&gt; Hello Emin-&gt; Hello Mehmet */","link":"/javascript-function-parameter-set-default-value/"},{"title":"Javascript Self Invoking Functions","text":"Javascript ile oluşturduğumuz bir fonksiyonu otomatik olarak çağırma. 1234567891011//Normal çağırmavar test = function(name){ return ('Hello ' + name);};test('Mehmet'); //Otomatik çağırmavar test = function(name){ return ('Hello ' + name);}('Mehmet');","link":"/javascript-self-invoking-functions/"},{"title":"Jquery Only Parent Click","text":"Jquery ile sadece parent elemente tıklama eventı ekleme. 1234567891011//Sadece Html elementine tıklandığında işlem yapar.$('#outer').click(function(e) { if (e.target === this){ console.log('Parent'); }});//Html elementinin kendisine tıklanmadıysa işlem yapmadan dön.$('#outer').click(function(e) { if(e.target != this) return;});","link":"/jquery-only-parent-click/"},{"title":"jQuery Video Extend","text":"Videolara logo ve duraklama noktaları ekleyebileceğiniz, youtube üzerinden veya flv dosyalarında video oynatmamızı sağlayan bir jQuery eklentisi. Örnek Çalışma Detayları","link":"/jquery-video-extend/"},{"title":"MSSQL Server 2014 LocalDB Connection String","text":"Eski projelerimin bazılarında SQL Server 2012 kullanarak LocalDB bağlantısını (LocalDB)\\v11.0 şeklinde yaparak gerçekleştiriyordum. SQL Server 2014 te ise bu bağlantı şekli değişmiş ve artık (LocalDB)\\MSSQLLocalDB olarak bağlantıyı sağlayabildim. Örnek connection stringler şu şekilde; SQL Server 2012 LocalDB Connection String 123&lt;connectionStrings&gt; &lt;add name=\"DBContext\" connectionString=\"Data Source=(LocalDB)\\\\v11.0;AttachDbFilename=|DataDirectory|\\\\Database.mdf;Integrated Security=True;\" providerName=\"System.Data.SqlClient\" /&gt;&lt;/connectionStrings&gt; SQL Server 2014 LocalDB Connection String 123&lt;connectionStrings&gt; &lt;add name=\"DBContext\" connectionString=\"Data Source=(LocalDB)\\\\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\\\\Database.mdf;Integrated Security=True;\" providerName=\"System.Data.SqlClient\" /&gt;&lt;/connectionStrings&gt; Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/mssql-server-2014-localdb-connection-string/"},{"title":"MSSQL Server Türkçe Karakter Destekli Veritabanı Oluşturmak","text":"Türkçe karakter destekli veritabanı için aşağıdaki SQL kodlarını kullanmanız yeterli olacaktır. 123ALTER DATABASE veritabani_adi SET SINGLE_USER WITH ROLLBACK IMMEDIATEALTER DATABASE veritabani_adi COLLATE TURKISH_CI_ASALTER DATABASE veritabani_adi SET MULTI_USER Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/mssql-server-turkce-karakter-destekli-veritabani-olusturmak/"},{"title":"Nesne Yönelimli Tasarım Prensipleri – SOLID - 1","text":"Merhaba yazılımı seven ve gönül veren değerli arkadaşlar, bu blog yazımın konusu nesne yönelimli programlamada “olmazsa olmaz” diyemem ama “olması gereken” teknikler üzerinde duracağım. Yazılım camiasında standart haline gelmiş SOLID prensipleri olarak anılan beş teknikten bahsedeceğim. Robert Cecil Martin’in (Nam-ı diğer Uncle Bob) sunumu ile yaygınlaşmaya başlayan SOLID, bir Dependency Managament (Bağımlılık Yönetimi) biçimidir. Uncle Bob ayrıca, 2000 senesinde Kent Beck ve 15 arkadaşı ile Agile Manifestonun oluşturulmasında yer almıştır. SOLID, Single Responsibility, Open Closed, Liskov Substitutio, Interface Segregation, Dependency Inversion prensiplerinden oluşur. Bu prensiplerin kullanılmasındaki temel amaç esnek ve geliştirilmesi kolay yazılımlar oluşturmaktır. Eğer bu prensipleri sadece uygulamış olmak için yaparsak kompleks bir yapı oluşacaktır. Bu yüzden projenin böyle bir şeye ihtiyacı olup olmadığını iyi analiz etmemiz gerekir. Yazılım geliştirmede amaç her zaman en basit yöntemler kullanarak, sade ve esnek yapılar oluşturmak olmalıdır. Yerine göre SOLID’i kullanıp kullanmamak bize kalmıştır. Bağımlılık seviyesi yüksek kötü tasarlanmış projelerin benzer üç özelliği vardır: (Rigidty) Esnek değillerdir. Geliştirmelere ve yeni eklentilere kapalıdırlar. (Fragility) Kırılgandırlar. Projenin herhangi bir yerinde yapacağım bir değişiklik başka yerleri etkiler. (Immobilty) Sabittirler. Tekrar kullanıma uygun değillerdir. Bu kötü tasarımı SOLID ile ortadan kaldırabiliriz. Bir sonraki yazım SOLID’in S’si olan Single Responsibility Principle (SRP) – Tek Sorumluluk Prensibi Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/nesne-yonelimli-tasarim-prensipleri-solid-1/"},{"title":".Net Projelerinde Otomatik Versiyonlama","text":"Yeni bir .Net projesini Visual Studio ortamında oluşturduğumuzda projenin özellikleri altında AssemblyInfo adlı bir dosya da varsayılan olarak oluşturulmaktadır. Bu dosyada projenin derleme bilgileri (projenin adı, versiyon bilgileri gibi) tutulur. Biz de bu dosyada yer alan AssemblyVersion özelliğine, SVN revision numarasını otomatik atayacağız. Öncelikle .Net projelerinde versiyonlama standartını görelim; Versiyon ({Major}.{Minor}.{Build Number}.{Revision}) şeklindedir. Major Version: Büyük yeniliklerde manuel olarak artırılır.Minor Version: Küçük değişikliklerde manuel olarak artırılır.Build Number: Derme numarası otomatik olarak atanacak.Revision: Her commit sonrası SVN tarafından otomatik gelen değer. Kısa bir açıklamadan sonra şimdi işe koyulabiliriz. Versiyonlama sistemi için açık kaynak kodlu olan MSBuild Community Tasks kütüphanesini kullanacağız. Nuget: 1PM&gt; Install-Package MSBuildTasks Paketi ekledikten sonra projemizin .csproj dosyasını açıp aşağıdaki özellikleri eklemeliyiz. Not: Kullandığımız SVN programının bulunduğu yolu belirtmeliyiz ve SVN programının tam yüklü olması gereklidir. Projemizi derlediğimiz zaman AssemblyVersion bilgisinin x.x.x.Revision şeklinde olduğunu göreceğiz. Bu yazı da bu kadar olsun artık. Kısa ve öz. 🙂 Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/net-projelerinde-otomatik-versiyonlama/"},{"title":"Single Responsibility Principle (SRP) – Tek Sorumluluk Prensibi - 2","text":"Bir önceki blog yazımda Nesne Yönelimli Tasarım Prensipleri – SOLID üzerinde durmuştuk. Bu yazımda ise SOLID’in S’si olan Single Responsibility Principle (SRP) – Tek Sorumluluk Prensibi üzerinde duracağım. Single Responsibility Principle (SRP) – Tek Sorumluluk Prensibi Bir sınıfın veya metodun sadece bir sorumluluğu vardır. Bu sayede bir değişiklik yapacağımız zaman sadece bir nedenimiz olur. Peki bu ne anlama geliyor? Resimde birden fazla işi yapan bir alet (çakı) görüyorsunuz. Bu aletin o kadar fazla sorumluluğu var ki, yeni bir sorumluluk eklemek istediğimde ya da kırılan bir parçayı değiştirmek istediğimizde yapısına müdahale etmem gerekecek. Eğer alet sadece bıçak olsaydı ya da tornavida, yani tek bir sorumluluğu olmuş olsaydı, kırılan kısmını kolay bir şekilde değiştirebilecektim. Belki yerden tasarruf edemezdim ancak zamandan tasarruf edeceğim ortada. Yazılım geliştirmede amaç her zaman en basit yöntemler kullanarak, sade ve esnek yapılar oluşturmaktır, demiştik. Yazılımsal açıdan bakarsak nasıl bir sonuca ulaşırız? Bir sınıfımız olsun ve bu sınıfın içerisinde Allah ne verdiyse yazdığımızı düşünelim. Bir süre sonra kodun binlerce satıra ulaştığını görüyoruz. Editör bile kodları gösterirken kasılır. Bir yeri değiştirmek canımıza okur ve geçmiş yazılımcılara sevmeler başlar. Seve seve biz de aynı şeklide kodumuzu yazarız. Sonuç; büyük ve karmaşık ve yönetimi zor kodlar, kırılgan ve esnek olmayan bir yapı. Yalnızca kendi sorumluluğunu yerine getirecek şekilde parçalara bölseydik bu sonuç ile karşılaşmayacaktık. Örnek C# kodu: 12345678910111213141516171819202122public class FullStackDeveloper{ public void WriteCSharpCode() { Console.WriteLine(\"I can write C#.\"); } public void WriteSQLCode() { Console.WriteLine(\"I can write SQL.\"); } public void WriteJavaScriptCode() { Console.WriteLine(\"I can write JavaScript.\"); } public void WriteCSSCode() { Console.WriteLine(\"I can write CSS.\"); }} “FullStackDeveloper” sınıfımız C#, SQL, JavaScript ve CSS kodu yazabilen bir yazılım geliştiricisini temsil etsin. Tek bir geliştiriciye bu kadar işin yüklenmesi geliştiricinin hata yapma olasılığını yükseltecektir. Çünkü, bir yerden sonra kafa çorbası içilmeye hazır hale gelecektir. Olması gereken ise aslında şudur: 12345678910111213141516171819202122232425262728public class BackEndDeveloper{ public void WriteCSharpCode() { Console.WriteLine(\"I can write C#.\"); }}public class FrontEndDeveloper{ public void WriteJavaScriptCode() { Console.WriteLine(\"I can write JavaScript.\"); } public void WriteCSSCode() { Console.WriteLine(\"I can write CSS.\"); }}public class SQLDeveloper{ public void WriteSQLCode() { Console.WriteLine(\"I can write SQL.\"); }} Kısacası, herkes kendi işini yapmalıdır! Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/single-responsibility-principle-srp-tek-sorumluluk-prensibi-2/"},{"title":"SQL Bir Tablonun Aynısını Oluşturma","text":"Bir tablonun aynı kolonlara sahip bir kopyasını oluşturmak istersek yazmamız gereken sorgu şu şekilde: 1select top 0 * into table2 from table1 Bu sorgu ile table1 tablosunun aynısını table2 ismiyle oluşturur.","link":"/sql-bir-tablonun-aynisini-olusturma/"},{"title":"SQL Create Temp Table Declare","text":"Temp tablo oluşturmak için bir yöntem. 12345DECLARE @TempTable TABLE( test1 INT, test2 NVARCHAR(MAX), test3 NVARCHAR(MAX))","link":"/sql-create-temp-table-declare/"},{"title":"Sql Execution Timing","text":"MSSQL 2008 ve üzeri sorgu süresini hesaplama 12345Declare @StartTime DateTime = GetDate()-- my SQL callsPrint 'Time taken was ' + cast(DateDiff(millisecond, @StartTime, GetDate()) as varchar) + 'ms'","link":"/sql-execution-timing/"},{"title":"SQL Trigger Toplu Update Sorunu","text":"Bazen triggerlarda where kullandığımız sorgular varsa, bu sorgular toplu update işlemi sırasında hata oluşturuyor. Where yerine Join kullanmak sorunu çözebilir.","link":"/sql-trigger-toplu-update-sorunu/"},{"title":"SQL – Update İle Daha Performanslı İşlem Yapma","text":"Bir sorgu içerisinde herhangi bir kolunun değerini bir fonksiyon ile düzenleyip basarsak performans kaybı olur. Ancak ilk olarak kolona varsayılan değerini basıp daha sonra toplu bir update çekersek gözle görülür performans artışı olur. 123UPDATE upb SET upb.yas = Hesapla(yas) FROM TempTable_UyeProfilBilgileri upb","link":"/sql-update-ile-daha-performansli-islem-yapma/"},{"title":"Stored Procedures and Tables Last Modify Date","text":"MSSQL sys.objects tablosundan üzerinde değişiklik yapılma tarihlerine göre tabloları ve stored proceduresleri listeleme sorgusu. U ile ifade edilenler tablo, P ile ifade edilenler ise SP. 1234SELECT name, create_date, modify_date, typeFROM sys.objectsWHERE type = 'U' OR type = 'P'ORDER BY modify_date DESC","link":"/stored-procedures-and-tables-last-modify-date/"},{"title":"TypeItJs – Harf Harf Animasyonlu Yazım Kütüphanesi","text":"Az önce internette dolaşırken karşıma çıkan, hoşuma giden webmaster araçlarını, kütüphanelerini, hem unutmamak hem de sizlerle paylaşmak için fazla açıklama yapmadan paylaşmaya karar verdim. Bu kategorinin ilk kütüphanesi TypeItJs. Harf harf animasyonlu yazı yazmamızı sağlayan güzel bir kütüphane. TypeItJs – Hemen İncele…","link":"/typeitjs-harf-harf-animasyonlu-yazim-kutuphanesi/"},{"title":"Visual Studio ile SVN Kullanımı","text":"VisualSVN kurulumu ve kullanımı hakkında.Bir önceki yazımda Dropbox Üzerine SVN Kurulumundan bahsetmiştim. Bu yazımda da söz verdiğim üzere Visual Studio ortamındayken projenizde değişiklik yaptığınız alanları göstererek commit etminizi sağlayan VisualSVN eklentisinin kurulumunu ve kullanımını anlatacağım. VisualSVN 5.1.4 sürümü ile Visual Studio 2015 e kadar destekliyor. VisualSVN eklentisini indirmek için bu linke tıklayın. www.visualsvn.com İndirme ve kurulum işlemleri bittikten sonra Visual Studio’ yu açtığımız pencerenin üstünde VisualSVN menüsünü gördüğümüzde kurulum başarılı olmuş demektir. Daha önce oluşturduğumuz SVN klasörünün içerisine herhangi bir yeni proje oluşturalım. Oluşturduğumuz anda VisualSVN projenin SVN klasörü içerisinde yer aldığını anlayarak Solution Explorer‘ da değişiklik olan dosyaların sol tarafına bir simge atarak o dosyanın commit edilebilir olduğunu gösteriyor. Projemize sağ tıklayıp commit dediğimizde bütün proje commit edilmiş olur. Eğer sadece çalıştığınız dosyayı commit etmek istiyorsanız o dosyaya sağ tıklayıp aynı işlemleri yaptığınızda commit işlemi gerçekleştiriliyor. Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/visual-studio-ile-svn-kullanimi/"},{"title":"Oracle Query – Get Version","text":"Oracle veritabanında hangi sürümün kullanıldığını merak ettim ve bunu buldum: 1SELECT * FROM V$VERSION","link":"/oracle-get-version-query/"}],"tags":[{"name":"algoritma","slug":"algoritma","link":"/tags/algoritma/"},{"name":"genetik","slug":"genetik","link":"/tags/genetik/"},{"name":"rating","slug":"rating","link":"/tags/rating/"},{"name":"helper","slug":"helper","link":"/tags/helper/"},{"name":"solid","slug":"solid","link":"/tags/solid/"},{"name":"dropbox","slug":"dropbox","link":"/tags/dropbox/"},{"name":"svn","slug":"svn","link":"/tags/svn/"},{"name":"unittest","slug":"unittest","link":"/tags/unittest/"},{"name":"mock","slug":"mock","link":"/tags/mock/"},{"name":"dbcontext","slug":"dbcontext","link":"/tags/dbcontext/"},{"name":"ef6","slug":"ef6","link":"/tags/ef6/"},{"name":"entityframework","slug":"entityframework","link":"/tags/entityframework/"},{"name":"asnotracking","slug":"asnotracking","link":"/tags/asnotracking/"},{"name":"visualstudio","slug":"visualstudio","link":"/tags/visualstudio/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"pages","slug":"pages","link":"/tags/pages/"},{"name":"customdomain","slug":"customdomain","link":"/tags/customdomain/"},{"name":"mssql","slug":"mssql","link":"/tags/mssql/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"webmaster","slug":"webmaster","link":"/tags/webmaster/"},{"name":"otomatik","slug":"otomatik","link":"/tags/otomatik/"},{"name":"versiyonlama","slug":"versiyonlama","link":"/tags/versiyonlama/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"update","slug":"update","link":"/tags/update/"},{"name":"storedprocedures","slug":"storedprocedures","link":"/tags/storedprocedures/"},{"name":"oracle","slug":"oracle","link":"/tags/oracle/"}],"categories":[{"name":"Algoritmalar","slug":"Algoritmalar","link":"/categories/Algoritmalar/"},{"name":".Net","slug":"Net","link":"/categories/Net/"},{"name":"Genel","slug":"Genel","link":"/categories/Genel/"},{"name":"C#","slug":"Net/C","link":"/categories/Net/C/"},{"name":".Net","slug":"Algoritmalar/Net","link":"/categories/Algoritmalar/Net/"},{"name":"Tavsiye Programlar","slug":"Tavsiye-Programlar","link":"/categories/Tavsiye-Programlar/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Webmaster","slug":"Webmaster","link":"/categories/Webmaster/"},{"name":"Veritabanı","slug":"Net/Veritabani","link":"/categories/Net/Veritabani/"},{"name":"SQL Server","slug":"SQL-Server","link":"/categories/SQL-Server/"},{"name":"Javascript","slug":"Net/C/Javascript","link":"/categories/Net/C/Javascript/"},{"name":"C#","slug":"Algoritmalar/Net/C","link":"/categories/Algoritmalar/Net/C/"},{"name":"Veritabanı","slug":"Veritabani","link":"/categories/Veritabani/"},{"name":"Visual Studio","slug":"Visual-Studio","link":"/categories/Visual-Studio/"},{"name":"Unit Test","slug":"Net/C/Unit-Test","link":"/categories/Net/C/Unit-Test/"},{"name":"JQuery","slug":"Javascript/JQuery","link":"/categories/Javascript/JQuery/"},{"name":"Javascript","slug":"Webmaster/Javascript","link":"/categories/Webmaster/Javascript/"},{"name":"Veritabanı","slug":"SQL-Server/Veritabani","link":"/categories/SQL-Server/Veritabani/"},{"name":"JQuery","slug":"Net/C/Javascript/JQuery","link":"/categories/Net/C/Javascript/JQuery/"},{"name":"SQL Server","slug":"Veritabani/SQL-Server","link":"/categories/Veritabani/SQL-Server/"},{"name":"Oracle","slug":"Veritabani/Oracle","link":"/categories/Veritabani/Oracle/"},{"name":"Open Source","slug":"Net/C/Javascript/JQuery/Open-Source","link":"/categories/Net/C/Javascript/JQuery/Open-Source/"}]}