{"pages":[],"posts":[{"title":"8 Vezir Probleminin Genetik Algoritma ile Ã‡Ã¶zÃ¼mÃ¼","text":"Merhaba arkadaÅŸlar, bu yazÄ±mda algoritma severlerin mutlaka bildiÄŸi 8 vezir probleminin genetik algoritma ile Ã§Ã¶zÃ¼mÃ¼nden bahsedeceÄŸim. Her ne kadar 8 vezir desek de asÄ±l amacÄ±mÄ±z n adet vezirin nxnâ€™lik satranÃ§ tahtasÄ±na uygun bir ÅŸekilde yerleÅŸtirilmesini saÄŸlamaktÄ±r. Bu yÃ¼zden 8 vezir yerine, n vezir problemi demek daha doÄŸru olacaktÄ±r. n Vezir Problemi AmacÄ±SatranÃ§ oynayanlar bilir, bir vezir yatay, dikey ve Ã§apraz hamleler yapabilir. AmacÄ±mÄ±z n adet veziri, nxnâ€™lik bir satranÃ§ tahtasÄ±na birbirini kesmeyecek ÅŸekilde yerleÅŸtirmek. n Vezir Probleminin GeÃ§miÅŸi8 vezir problemi ilk olarak 1848 yÄ±lÄ±nda satranÃ§ oyuncusu Max Bezzel tarafÄ±ndan ortaya atÄ±lmÄ±ÅŸtÄ±r. Gauss ve Georg Cantor gibi pek Ã§ok matematikÃ§i tarafÄ±ndan incelenmiÅŸtir. Ä°lk Ã§Ã¶zÃ¼mÃ¼ Franz Nauck 1850â€™de ortaya atmÄ±ÅŸtÄ±r, aynÄ± zamanda n vezir problemi haline getirmiÅŸtir. n Vezir Probleminin Genetik Algoritma ile Ã‡Ã¶zÃ¼mÃ¼Genetik algoritma ile ilgili daha Ã¶nceden bir yazÄ± yazmÄ±ÅŸtÄ±m. Temel seviyede bilgiyi ÅŸuradan edinebilirsiniz. Evrimsel SÃ¼recin SimÃ¼lasyonu â€“ Genetik Algoritmalar â€“ 1 Fitness FunctionBildiÄŸi Ã¼zere genetik algoritmada asÄ±l iÅŸi yapan Fitness Functionâ€˜dÄ±r. Ä°yi dÃ¼ÅŸÃ¼nÃ¼lerek yazÄ±lmÄ±ÅŸ bir fitness function sonuca ulaÅŸmamÄ±zÄ± bÃ¼yÃ¼k bir oranda etkiler. 8 vezir probleminde ise algoritmamÄ±z ÅŸu ÅŸekilde olacak: 8Ã—8â€™lik satranÃ§ tahtasÄ±nÄ±n ilk sÃ¼tunundan baÅŸlayarak bir vezir seÃ§ilir SeÃ§ilen veziri, tahtanÄ±n saÄŸÄ±nda yer alan kesmeyen vezir sayÄ±sÄ± bulunur Bu kontrol tÃ¼m sÃ¼tunlar iÃ§in uygulanÄ±r ve toplam kesmeyen vezir sayÄ±sÄ± bulunur Not: 8 vezirlik bir problemin en uygun fitness function sonucu 28 olarak hesaplanÄ±r. Problem iÃ§in hazÄ±rladÄ±ÄŸÄ±m fitness function 12345678910111213141516171819202122232425262728293031public class MyProblemFitness : IFitnessFunction{ public double Evaluate(IChromosome chromosome) { var genes = ((PermutationChromosome)chromosome).Value; double result = 0; for (int x1 = 0; x1 &lt; genes.Length - 1; x1++) { int y1 = genes[x1]; int sagdakiVezirSayisi = genes.Length - 1 - x1; for (int x2 = x1 + 1; x2 &lt; genes.Length; x2++) { int y2 = genes[x2]; if (y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2) { sagdakiVezirSayisi -= 1; } } result += sagdakiVezirSayisi; } return result; }} Kromozom YapÄ±sÄ±Ã–rnek kromozom: [ 5, 1, 3, 0, 2, 7, 6, 4 ] Bu problem iÃ§in permÃ¼tasyon kodlamalÄ± kromozom yapÄ±sÄ± daha uygun olacaktÄ±r. Kromozomun birinci elamanÄ± olan 5 deÄŸeri, vezirin sÄ±fÄ±rÄ±ncÄ± sÃ¼tun ve beÅŸinci satÄ±rda yer aldÄ±ÄŸÄ±nÄ± ifade etmektedir. C# ile Ã‡Ã¶zÃ¼mÃ¼Problemin Ã§Ã¶zÃ¼mde kÃ¼tÃ¼phane kullanmak Ã§Ã¶zÃ¼m sÃ¼resinin uzamasÄ±nÄ± ve aynÄ± iÅŸlerin (crossover, mutation, selectionâ€¦) tekrarÄ±nÄ± Ã¶nlemek aÃ§Ä±sÄ±ndan Ã¶nemli. Bu yÃ¼zden AForge.Net Genetic ve GeneticSharp kÃ¼tÃ¼phanelerini kullandÄ±m. Problemi her iki kÃ¼tÃ¼phane ile Ã§Ã¶zdÃ¼m. AForge.Net kÃ¼tÃ¼phanesinin performasÄ± bu problem iÃ§in daha uygun geldi bana. Tavsiyem AForge.Net Genetic. Problemin Ã§Ã¶zÃ¼mÃ¼nÃ¼ Githubâ€™ta paylaÅŸtÄ±m. Ä°sterseniz inceleyebilirsiniz, https://github.com/mehmetemineker/Genetic8QueensSolutionWithAForge â€“ AForge.Net Genetic https://github.com/mehmetemineker/Genetic8QueensSolutionWithGeneticSharp â€“ GeneticSharp Kaynak: https://tr.wikipedia.org/wiki/Sekiz_vezir_bulmacas%C4%B1","link":"/8-vezir-probleminin-genetik-algoritma-ile-cozumu/"},{"title":"ASP.Net MVC Stars Rating Helper","text":"GeliÅŸtirmiÅŸ olduÄŸum stars rating helperÄ±. AÃ§Ä±k kaynak olarak Github repomdan bakabilirsiniz. https://github.com/mehmetemineker/FontAwesome-SuperStarsRating-Helper","link":"/asp-net-mvc-stars-rating-helper/"},{"title":"C# ToUpper ve ToLower TÃ¼rkÃ§e Karakter Sorunu","text":"ToUpper ve ToLower kullandÄ±ÄŸÄ±nÄ±zda TÃ¼rkÃ§e karakterlerde sÄ±kÄ±ntÄ± yaÅŸattÄ±ÄŸÄ±nÄ± gÃ¶rdÃ¼yseniz doÄŸru yerdesiniz. CultureInfo ile bu sorunu giderebiliriz. 1string test = test = test.ToUpper(new CultureInfo(\"tr-TR\", false));","link":"/c-toupper-ve-tolower-turkce-karakter-sorunu/"},{"title":"Dropbox Ãœzerine SVN Kurulumu","text":"Freelancerlar ve kÃ¼Ã§Ã¼k takÄ±mlar iÃ§in Dropbox Ã¼zerine SVN kurulumu.GeliÅŸtirdiÄŸiniz projenin kaynak kodlarÄ±nÄ±n kaybÄ±nÄ± en aza indirmek, versiyon kontrolÃ¼ saÄŸlamak ve takÄ±m halinde Ã§alÄ±ÅŸÄ±rken Ã§akÄ±ÅŸmalarÄ±n Ã¶nÃ¼ne geÃ§mek istiyorsanÄ±z, SVN kolay kurulumu ve kolay kullanÄ±mÄ± ile yazÄ±lÄ±m geliÅŸtiricileri kendine Ã§ekmeyi baÅŸarÄ±yor. Ben de Åubat 2016 dan beri SVN kullanÄ±yorum. Ä°lk baÅŸlarda temel amacÄ±nÄ± kavramakta zorlansam da artÄ±k kiÅŸisel projelerimde bile SVN kullanmaya karar verdim. Bu yazÄ±yÄ± yazmamdaki amaÃ§ server kurulum derdi olmadan direkt Dropbox Ã¼zerinde tanÄ±mladÄ±ÄŸÄ±m bir klasÃ¶re SVN baÄŸlayÄ±p kullanmak. KÄ±sa bir hatÄ±rlatma; ben Dropbox kullanÄ±yorum. Dropbox ÅŸart deÄŸil. Google Drive, One Drive, Yandex gibi benzer depolama alanlarÄ±nÄ± da kullanabilirsiniz. Åimdi kuruluma geÃ§elim: KullanÄ±lan yazÄ±lÄ±mlar TortoiseSVN Dropbox Ä°ndirime ve kurulum iÅŸlemleri tamamlandÄ±ktan sonra yapÄ±lmasÄ± gerekenler; Dropbox hesabÄ±mÄ±z ile oturum aÃ§Ä±p Dropbox klasÃ¶rÃ¼nÃ¼n iÃ§erisine yeni boÅŸ bir klasÃ¶r oluÅŸturalÄ±m. KlasÃ¶rÃ¼ oluÅŸturduk. Åimdi sÄ±rada SVN Repository oluÅŸturmak. KlasÃ¶re saÄŸ tÄ±klayÄ±p aÃ§Ä±lan menÃ¼den TortoiseSVN &gt; Create repository here tÄ±klÄ±yoruz. Create repository here a tÄ±kladÄ±ÄŸÄ±mÄ±zda Repository created penceresi aÃ§Ä±ldÄ±. Burda Create folder structure butonuna tÄ±klÄ±yoruz. Success sonucunu aldÄ±ÄŸÄ±mÄ±zda Dropbox ile olan iÅŸlemimizi baÅŸarÄ±yla tamamlamÄ±ÅŸ olduk. Åimdi oluÅŸturduÄŸum SVN klasÃ¶rÃ¼nÃ¼ kendi local diskim Ã¼zerindeki bir klasÃ¶re baÄŸlayacaÄŸÄ±m. Herhangi bir boÅŸ klasÃ¶re gidip saÄŸ tÄ±klayÄ±p aÃ§Ä±lan menÃ¼den SVN Checkoutâ€¦ diyorum. Sonra aÃ§Ä±lan Checkout penceresinden URL of repository alanÄ±na Dropbox Ã¼zerinde oluÅŸturduÄŸum SVN klasÃ¶rÃ¼nÃ¼n yolunu belirtiyorum. Checkout directory ise bizim local diskimizdeki klasÃ¶rÃ¼n yolu. OK butonuna bastÄ±ktan sonra Checkout Finished! penceresi geliyor ve SVN klasÃ¶rleri oluÅŸturuluyor. *Soru: *Peki diÄŸer geliÅŸtiriciler benim Dropbox Ã¼zerinde oluÅŸturduÄŸum SVN klasÃ¶rÃ¼ne nasÄ±l baÄŸlanacaklar? *Cevap: *Ã‡ok basit. Dropbox hesap sahibi klasÃ¶rÃ¼ paylaÅŸÄ±ma aÃ§acak. Bir yazÄ±nÄ±n daha sonuna geldik. Bir sonraki yazÄ±m Visual Studio ve SVN ile ilgili olacak. Visual Studio ile SVN KullanÄ±mÄ± baÅŸlÄ±klÄ± yazÄ±ma gitmek ister misiniz? Olur ya bir gÃ¼n gÃ¶rÃ¼ÅŸemezsek iyi gÃ¼nler, iyi akÅŸamlar ve iyi gecelerâ€¦","link":"/dropbox-uzerine-svn-kurulumu/"},{"title":"EF6 DbContext Unit Test Mock","text":"Merhaba, Ã§ok uzun zamandÄ±r bir ÅŸeyler yazmÄ±yordum. Tam anlamÄ±yla bir yazÄ± olmasa da bir baÅŸlangÄ±Ã§ yapmak adÄ±na bu kÃ¼Ã§Ã¼k paylaÅŸÄ±mÄ± yapmak istedim. Bu paylaÅŸÄ±mÄ±mda EF6 DbContext Mock iÅŸlemi iÃ§in hazÄ±rladÄ±ÄŸÄ±m kodu gÃ¶receksiniz. BilindiÄŸi Ã¼zere unit test yazmanÄ±n en Ã¶nemli ve en sÄ±kÄ±ntÄ±lÄ± noktalarÄ±ndan birisi mocklama iÅŸlemi. DbContext sÄ±nÄ±fÄ±nÄ±z eÄŸer test edilebilir olarak geliÅŸtirilmediyse bu sÃ¼reÃ§ can sÄ±kÄ±cÄ± olabiliyor. Var olan yapÄ±nÄ±zÄ± da deÄŸiÅŸtirmek Ã¼rkÃ¼tÃ¼cÃ¼ geliyorsa, paylaÅŸmÄ±ÅŸ olduÄŸum kodlar ile Ã§ok fazla deÄŸiÅŸiklik yapmadan DbContext nesnemizi mocklayarak test edilebilir hale getirebilirsiniz. Mocklama iÅŸlemi iÃ§in Moq kÃ¼tÃ¼phanesinden faydalandÄ±m.Olmazsa olmaz Utility sÄ±nÄ±fÄ±mÄ±z ile kodlar ÅŸÃ¶yle :) 12345678910111213141516171819202122232425public class Utility{ public static (Mock&lt;D&gt; mockDbContext, Mock&lt;MockableDbSetWithExtensions&lt;T&gt;&gt; mockDbSet) MockDb&lt;D, T&gt;(List&lt;T&gt; sourceList) where D : DbContext where T : class { var queryable = sourceList.AsQueryable(); var mockDbContext = new Mock&lt;D&gt;(); var mockDbSet = new Mock&lt;MockableDbSetWithExtensions&lt;T&gt;&gt;(); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.Provider).Returns(queryable.Provider); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.Expression).Returns(queryable.Expression); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.ElementType).Returns(queryable.ElementType); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.GetEnumerator()).Returns(queryable.GetEnumerator()); mockDbSet.Setup(d =&gt; d.Add(It.IsAny&lt;T&gt;())).Callback&lt;T&gt;((s) =&gt; sourceList.Add(s)); return (mockDbContext, mockDbSet); }}public abstract class MockableDbSetWithExtensions&lt;T&gt; : DbSet&lt;T&gt; where T : class{ public abstract void AddOrUpdate(params T[] entities); public abstract void AddOrUpdate(Expression&lt;Func&lt;T, object&gt;&gt; identifierExpression, params T[] entities);} Bu metod 2 deÄŸiÅŸkenli Tuple dÃ¶ndÃ¼rÃ¼yor. MockableDbSetWithExtensions nesnesi ile AddOrUpdate metodlarÄ±nÄ± test ediyorum. Bunun yerine sadece DbSet nesnesini de kullanabilirsiniz. KullanÄ±mÄ± 123var fakeData = new List&lt;MyDbSet&gt;()var (mockDbContext, mockDbSet) = Utility.MockDb&lt;MyContext, MyDbSet&gt;(fakeData);mockDbContext.Setup(c =&gt; c.MyDbSet).Returns(mockDbSet.Object); Bu tanÄ±mlamalarÄ± yaptÄ±ktan sonra test etmek istediÄŸimiz metodun ait olduÄŸu sÄ±nÄ±fÄ±n yapÄ±cÄ± metoduna parametre olarak DbContext nesnemizi geÃ§memiz gerekiyor. DI kullanÄ±lÄ±yorsa manuel olarak geÃ§memize gerek yok. EÄŸer yapÄ±mÄ±zÄ± Ã§ok fazla deÄŸiÅŸtirmek istemiyorsanÄ±z yapÄ±cÄ± metoda parametre geÃ§mek biraz daha kolay olacaktÄ±r. Kaynakhttps://docs.microsoft.com/tr-tr/ef/ef6/fundamentals/testing/mocking","link":"/ef6-dbcontext-unit-test-mock/"},{"title":"EntityFramework AsNoTracking Nedir?","text":"Merhaba arkadaÅŸlar, bugÃ¼n .Net Core projem iÃ§in Generic Repository Ã¶rneÄŸi yapÄ±yordum. Github Ã¼zerinden Ã¶rnek kodlara bakarken Entity sorgularÄ±ndaki AsNoTracking ifadesini gÃ¶rdÃ¼m. YaklaÅŸÄ±k 4 yÄ±ldÄ±r MVC projelerinde gÃ¶rev alÄ±yorum. AsNoTracking ifadesini ÅŸimdiye kadar fark edemediÄŸim iÃ§in Ã¼zÃ¼ldÃ¼m, ÅŸimdi bunu keÅŸfettiÄŸim iÃ§in de mutluyum. ğŸ™‚ Sizin de bundan faydalanmanÄ±zÄ± istediÄŸim iÃ§in Ã§ok geciktirmeden blogumda paylaÅŸmak istedim. BildiÄŸiniz Ã¼zere EntityFramework ile bir select iÅŸlemi yaptÄ±ÄŸÄ±nÄ±zda, gelen data iÃ§eriÄŸini gÃ¼ncelleyip SaveChanges yaparsak deÄŸiÅŸiklikler veritabanÄ±na yansÄ±r. Bu iÅŸlemi her zaman istemiyor olabilirsiniz. Bu durumda AsNoTracking ifadesi yardÄ±mÄ±mÄ±za koÅŸuyor. Bu ifade ile yaptÄ±ÄŸÄ±mÄ±z entity sorgusu sadece okumalÄ±ktÄ±r. Ãœzerinde deÄŸiÅŸiklik yapÄ±p SaveChanges yaptÄ±ÄŸÄ±mÄ±zda veritabanÄ±nda hiÃ§bir deÄŸiÅŸiklik olmaz. Bu da bize minimum bellek kullanÄ±mÄ± ve optimum performans saÄŸlayacaktÄ±r. Ã‡ok hoj ğŸ™‚ AsNoTracking PerformansÄ±AsNoTracking ifadesinin performansÄ± ne kadar etkilediÄŸine gÃ¶rsel olarak birlikte bakalÄ±m: AsNoTracking KullanÄ±mÄ±Bu ifadenin kullanÄ±mÄ± ise aÅŸaÄŸÄ±da gÃ¶receÄŸiniz Ã¼zere Ã§ok kolay: 1context.Set&lt;TEntity&gt;().AsNoTracking(); DiÄŸer bir kullanÄ±m yÃ¶netimi ise DbContext ayarlarÄ±ndan yapÄ±labilir. Bu da tÃ¼m queryler iÃ§in geÃ§erli olacaktÄ±r: 1context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; Kaynaklar: http://blog.staticvoid.co.nz/2012/entity_framework_and_asnotracking/ https://docs.microsoft.com/en-us/ef/core/querying/tracking","link":"/entityframework-asnotracking-nedir/"},{"title":"Evrimsel SÃ¼recin SimÃ¼lasyonu â€“ Genetik Algoritmalar â€“ 1","text":"Selam arkadaÅŸlar, bu makalemde birkaÃ§ aydÄ±r Ã¼zerinde araÅŸtÄ±rmalar yaptÄ±ÄŸÄ±m genetik algoritmalar hakkÄ±nda edindiÄŸim bilgileri sizlerle paylaÅŸmak istedim. Genetik algoritamlar konusuna giriÅŸ yapmadan Ã¶nce iÅŸi biraz daha temelden alarak â€œAlgoritamanÄ±nâ€ ne olduÄŸu konusuna deÄŸinmek istiyorum. Bilgisayar bilimleri veya matematik bilimleri ile ilgilensek de ilgilenmesek de aslÄ±nda algoritmalar hayatÄ±mÄ±z her yerinde. GÃ¼nlÃ¼k hayatÄ±mÄ±zda bilinÃ§li veya bilinÃ§siz bir Ã§ok algoritmayÄ± yerine getiririz. Bu algoritmalara en gÃ¼zel Ã¶rneÄŸi â€œyemek yapmakâ€ eylemini gÃ¶sterebiliriz. Yemek yaparken izlediÄŸimiz tÃ¼m adÄ±mlar daha Ã¶nceden belirlenmiÅŸ kurallar Ã§erÃ§evesinde ilerletilir. Bu baÄŸlamda algoritma, en basit tanÄ±mÄ±yla, bir problemin Ã§Ã¶zÃ¼mÃ¼nde izlenecek yol anlamÄ±na gelir. Algoritma sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kÃ¶kenine bakacak olursak; modern algoritmanÄ±n babasÄ± olarak anÄ±lan TÃ¼rk bilim adamÄ± El HarezmÃ®, Cebir isimli kitabÄ±nda algoritma Ã§alÄ±ÅŸmalarÄ±ndan bahsetmiÅŸtir. YazdÄ±ÄŸÄ± kitap Avrupa dillerine de Ã§evrilmiÅŸtir. Algoritma kelimesi, isminin Latin biÃ§imi olan Algoritmiâ€™ den tÃ¼retilmiÅŸtir. AyrÄ±ca ismi, Ä°spanyolca ve Portekizce dillerinde basamak anlamÄ±na gelen guarismo ve algarismo kelimelerinin kÃ¶kenini oluÅŸturmaktadÄ±r. AlgoritmayÄ± oluÅŸturan 3 temel bileÅŸen vardÄ±r. Bunlar, deÄŸiÅŸkenler, algoritmanÄ±n kendisi olan mantÄ±ksal adÄ±mlar ve akÄ±ÅŸ diyagramÄ±. Bu ifadeleri aÃ§Ä±klayacak olursak; deÄŸiÅŸken; deÄŸerlerin, yani verilerin tutulduÄŸu-saklandÄ±ÄŸÄ± elemanlar, mantÄ±ksal adÄ±mlar; algoritmanÄ±n adÄ±mlarÄ±, akÄ±ÅŸ diyagramÄ± ise; mantÄ±ksal adÄ±mlarÄ± gÃ¶rsel olarak ifade etme biÃ§imi olarak tanÄ±mlayabiliriz. Ã–rnek AkÄ±ÅŸ DiyagramÄ± Algoritma konusuna kÄ±saca deÄŸindikten sonra makalemin asÄ±l konusuna geÃ§iÅŸ yapabiliriz. Bir problemin Ã§Ã¶zÃ¼mÃ¼nde gÃ¶zlem yapmak problemin Ã§Ã¶zÃ¼m gidiÅŸatÄ±nÄ± olumlu yÃ¶nde etkiler. Bilim insanlarÄ± da bazÄ± mantÄ±ksal sorunlarÄ±n Ã§Ã¶zÃ¼mÃ¼ne gÃ¶zlem yaparak ulaÅŸmÄ±ÅŸlardÄ±r. Bu Ã§Ã¶zÃ¼m yÃ¶ntemlerine Ã¶rnek verecek olursak; tavlama benzetimi, tabu arama algoritmasÄ±, karÄ±nca kolonisi algoritmasÄ±, genetik algoritmalar vb. *Tavlama Benzetimi (Simulated Annealing): *KatÄ±larÄ±n Ä±sÄ±tÄ±lmasÄ± ve sonra kristalleÅŸmeye kadar yavaÅŸ yavaÅŸ soÄŸutulmasÄ± esasÄ±na dayanan bir algoritmadÄ±r. Kirkpatrick ve arkadaÅŸlarÄ± tarafÄ±ndan 1983 yÄ±lÄ±nda Ã¶nerilmiÅŸtir. SÄ±caklÄ±k deÄŸeri, elde edilen en iyi Ã§Ã¶zÃ¼mden daha kÃ¶tÃ¼ bir Ã§Ã¶zÃ¼mÃ¼n kabul edilme olasÄ±lÄ±ÄŸÄ±nÄ± belirlemek iÃ§in kullanÄ±lÄ±r. Tabu Arama (Tabu Search): Bu algoritma Glover tarafÄ±ndan 1986 yÄ±lÄ±nda geliÅŸtirilmiÅŸtir. Yerel optimum tuzaklarÄ±ndan kaÃ§arak global optimumu bulan yÃ¼ksek seviyeli bir sezgisel yÃ¶ntemdir. KarÄ±nca Kolonisi AlgoritmasÄ± (Ant Colony Algorithm): KarÄ±ncalarÄ±n yuvalarÄ± ile yiyecek noktalarÄ± arasÄ±ndaki en kÄ±sa yolu bulma kabiliyetlerinden esinlenilerek geliÅŸtirilmiÅŸtir. Alternatif birÃ§ok yolun sÃ¶z konusu olduÄŸu durumlarda karÄ±ncalar, Ã¶ncelikle bu yollara eÅŸit olasÄ±lÄ±kla daÄŸÄ±lÄ±rlarken belli bir sÃ¼re sonra en kÄ±sa olan yolda yoÄŸunlaÅŸmaktadÄ±r. Genetik Algoritmalar, John Holland tarafÄ±ndan 1975 yÄ±lÄ±nda, Charles Darwinâ€™ in doÄŸal evrim teorisinden esinlenilerek geliÅŸtirilmiÅŸtir. Bu algoritma, bir sonraki kuÅŸaÄŸÄ±n yavrularÄ±nÄ± Ã¼retmek iÃ§in en iyi bireylerin Ã¼reme iÃ§in seÃ§ildiÄŸi doÄŸal seleksiyon sÃ¼recini yansÄ±tmaktadÄ±r. Geleneksel yÃ¶ntemlerle Ã§Ã¶zÃ¼mÃ¼ Ã§ok zor olan veya imkansÄ±za yakÄ±n olan problemlerin Ã§Ã¶zÃ¼mÃ¼nde kullanÄ±lmaktadÄ±r. MÃ¼hendislik alanÄ±nda daha Ã§ok optimizasyon amaÃ§lÄ± kullanÄ±lmakta ve diÄŸer geleneksel yÃ¶ntemlere gÃ¶re daha iyi sonuÃ§ vermektedir. Genetik algoritmanÄ±n genel iÅŸleyiÅŸini iyi anlamak iÃ§in Ã¶ncelikle evrimsel sÃ¼reci iyi anlamak gereklidir: Evrim, canlÄ± tÃ¼rlerinin yani bir popÃ¼lasyon iÃ§erisindeki her bir bireyin nesilden nesile kalÄ±tsal deÄŸiÅŸime uÄŸrayarak, ortamlara adaptasyonlarÄ±nÄ± saÄŸlayan â€œen iyiâ€œleÅŸtirme sÃ¼recidir. Bireylerin geÃ§irdiÄŸi bu deÄŸiÅŸimler, bireylerin hayatlarÄ± boyunca geÃ§irdiÄŸi deÄŸiÅŸimler deÄŸildir, evrimsel sÃ¼reÃ§ iÃ§erisinde nesillerde meydana gelen deÄŸiÅŸimlerdir. Evrimin temel dayanaÄŸÄ± en iyinin hayatta kalmasÄ± prensibidir. En iyi olamayan bireyler Ã¼reyemezler ve yok olurlar. Bu gidiÅŸatÄ±n sonucunda en iyilere sahip bir popÃ¼lasyon meydana gelir. Genetik algoritmanÄ±n genel evrim ilkeleri dÄ±ÅŸÄ±nda belirgin standartlarÄ± yoktur. Algoritma probleme gÃ¶re bazÄ± deÄŸiÅŸikliklere uÄŸrayabilir. Ã–rneÄŸin; bireyin en iyi olup olmadÄ±ÄŸÄ±nÄ± (â€œen iyiâ€ ifadesi gÃ¶recelidir) kontrol etme tekniÄŸi probleme gÃ¶re farklÄ±lÄ±k gÃ¶sterebilir. Genetik algoritma evrimsel sÃ¼reci bilgisayar ortamÄ±nda taklit eder. Tek bir Ã§Ã¶zÃ¼m geliÅŸtirilmesi yerine, Ã§Ã¶zÃ¼mlerden meydana gelen bir kÃ¼me oluÅŸturur. Ã‡Ã¶zÃ¼mlerden meydana gelen bu kÃ¼meye genetik algoritma jargonunda popÃ¼lasyon veya nÃ¼fus olarak adlandÄ±rÄ±lÄ±r. Bir popÃ¼lasyon vektÃ¶r, kromozom veya birey adÄ± verilen sayÄ± dizilerinden oluÅŸur. Birey iÃ§indeki her bir elemana gen adÄ± verilir. PopÃ¼lasyonda yer alacak olan bireylere, evrimsel sÃ¼reÃ§ doÄŸrultusunda genetik algoritma iÅŸlemleri belirler. Genetik algoritma kapsamÄ±nda temel 3 iÅŸlem (operatÃ¶r) vardÄ±r. Bunlar; Ã§aprazlama (crossover), mutasyon (mutation) ve *seÃ§ilim (selection) *iÅŸlemleridir. Genetik algoritmada kullanÄ±lan temel kavramlarÄ± aÃ§Ä±klayacak olursak; Gen: Genetik bilgi taÅŸÄ±yan en kÃ¼Ã§Ã¼k yapÄ±dÄ±r. Kromozom: Genlerden meydana gelen diziye kromozom denir. Her bir kromozom, olasÄ± Ã§Ã¶zÃ¼mleri gÃ¶sterirler. PopÃ¼lasyon: Kromozomlardan meydana gelmiÅŸ topluluÄŸa denir. Her bir popÃ¼lasyon, alternatif Ã§Ã¶zÃ¼m kÃ¼mesidir. Bir sonraki makale: Genetik Algoritmada KullanÄ±lan OperatÃ¶rler","link":"/evrimsel-surecin-simulasyonu-genetik-algoritmalar-1/"},{"title":"GeliÅŸtiriciler Ä°Ã§in Offline DokÃ¼mantasyon â€“ Zeal","text":"Zeal â€“ Offline Documentation Browser programÄ± ile offline olarak dokÃ¼mantasyon ihtiyacÄ±nÄ±zÄ± giderebilirsiniz. Zeal, ÅŸuan 195 yazÄ±lÄ±m teknolojisinin dokÃ¼mantasyonunu offline olarak sunmakta. Ä°sterseniz masaÃ¼stÃ¼ uygulamasÄ±nÄ± indirmek yerine kullandÄ±ÄŸÄ±nÄ±z IDE Ã¼zerine plugin olarak ekleme ÅŸansÄ±nÄ±z da var. IDE Pluginler de ÅŸunlar; Atom: https://atom.io/packages/dashBrackets: https://github.com/anephew/brackets-zealEmacs: https://github.com/jinzhu/zeal-at-pointIntelliJ IDEA: https://plugins.jetbrains.com/plugin/7351?pr=ideaKTextEditor (Kate, KWrite, KDevelop, Kile, etc): https://github.com/g3ar/ZealSearchSublime Text: https://github.com/vaanwd/ZealVIM: https://github.com/KabbAmine/zeavim.vim","link":"/gelistiriciler-icin-offline-dokumantasyon-zeal/"},{"title":"Github Pages Custom Domain","text":"Daha Ã¶nceki yazÄ±m Github Pages ile GeliÅŸtiricilere Ãœcretsiz Blog Ã¼zerineydi. Bu yazÄ±mda da {kullanÄ±cÄ± adÄ±m}.github.io ÅŸeklinde olan alan adÄ±nÄ± istediÄŸimiz bir alan alan adÄ± ile aÃ§mayÄ± anlatacaÄŸÄ±m. AlmÄ±ÅŸ olduÄŸumuz alan adÄ±nÄ±n yÃ¶netim ekranÄ±ndan 2 adet A kaydÄ± oluÅŸturmamÄ±ÅŸ gerekiyor. A kayÄ±tlarÄ±nÄ±n ikisine de alan adÄ±mÄ±zÄ± yazÄ±yoruz. Ip adreslerine ise Github Pages Custom Domain IPâ€˜lerini yazmamÄ±z gerekiyor. Github Pages Cutom Domain IPs 192.30.252.153 192.30.252.154 Ã–rnek A kaydÄ± ÅŸu ÅŸekilde olacak: mht.ist â€“ 192.30.252.153 mht.ist â€“ 192.30.252.154 A kaydÄ±nÄ± tamamladÄ±ktan sonra Daha Ã¶nce oluÅŸturduÄŸumuz Github Ã§alÄ±ÅŸma alanÄ±mÄ±za gidip yeni bir dosya oluÅŸturuyoruz. DosyanÄ±n adÄ±na CNAME yazÄ±yoruz. Ä°Ã§eriÄŸine ise kendi alan adÄ±mÄ±zÄ± yazÄ±yoruz. Ve artÄ±k bloÄŸumuza {kullanÄ±cÄ± adÄ±m}.github.io ÅŸeklide eriÅŸmek yerine direkt kendi belirlediÄŸimiz alan adÄ± ile eriÅŸiyoruz. Benim alan adÄ±m mht.ist.BurayÄ± blog gibi deÄŸil de not defteri gibi kullanmaya Ã§alÄ±ÅŸacaÄŸÄ±m. Belki ilerde sadece onu kullanÄ±rÄ±m. Github Pages hakkÄ±nda daha detaylÄ± dÃ¶kÃ¼mantasyon iÃ§in ÅŸu adrese gidebilrisiniz. Olur ya bir gÃ¼n gÃ¶rÃ¼ÅŸemezsek iyi gÃ¼nler, iyi akÅŸamlar ve iyi gecelerâ€¦","link":"/github-pages-custom-domain/"},{"title":"Github Pages ile GeliÅŸtiricilere Ãœcretsiz Blog","text":"GeliÅŸtiriciler iÃ§in basit ve hÄ±zlÄ± blog oluÅŸturma.GeliÅŸtirici olan herkesin hayalidir bir blog tutmak. Jekyll ile bu Ã§ok kolay. Bu yazÄ±mda, Github Ã¼zerinde HTML sayfasÄ± nasÄ±l gÃ¶rÃ¼ntÃ¼lenir? Jekyll nedir? Jekyll NasÄ±l kurulur? Jekyll Projesi NasÄ±l OluÅŸturulur? NasÄ±l yayÄ±nlanÄ±r? konularÄ± Ã¼zerinde duracaÄŸÄ±m. Github Ãœzerinde HTML SayfasÄ± NasÄ±l GÃ¶rÃ¼ntÃ¼lenir?Ä°lk olarak Github hesabÄ±mÄ±za giriÅŸ yaptÄ±ktan sonra New repository butonuna basarak yeni bir Ã§alÄ±ÅŸma alanÄ± oluÅŸturalÄ±m. New repository butonuna bastÄ±ÄŸÄ±mÄ±zda aÅŸaÄŸÄ±daki Create a new repository sayfasÄ± aÃ§Ä±lacak. Bu sayfadan projemizin adÄ±nÄ± {kullanÄ±cÄ± adÄ±m}.github.io ÅŸeklinde veriyoruz. Ä°sterseniz README dosyasÄ±nÄ± da ekleyebilirsiniz. Sonra Create repository butonuna bastÄ±ÄŸÄ±mÄ±zda yeni Ã§alÄ±ÅŸma alanÄ±mÄ±z oluÅŸmuÅŸ olacak. Github Pagesâ€™ Ä±n yayÄ±na girip girmediÄŸini kontrol etmek iÃ§in Ã§alÄ±ÅŸma alanÄ±nÄ±n ayarlarÄ±na gÃ¶z atmamÄ±z gerekiyor. Ayarlar sayfasÄ±na girdiÄŸimizde **Github Pages** alanÄ±nda aÅŸaÄŸÄ±daki resimde olduÄŸu gibi gÃ¶zÃ¼kÃ¼yorsa Github Pages baÅŸarÄ±yla yayÄ±na girmiÅŸtir. Bu baÄŸlantÄ±ya tÄ±kladÄ±ÄŸÄ±mÄ±z zaman 404 sayfasÄ± ile karÅŸÄ±laÅŸacaÄŸÄ±z. Ã‡Ã¼nkÃ¼ index.html dosyasÄ± oluÅŸturmadÄ±k. Index.html dosyasÄ± oluÅŸturmak iÃ§in Ã§alÄ±ÅŸma alanÄ±mÄ±za geri dÃ¶nÃ¼p Create new file butonuna basarak yeni bir dosya oluÅŸturalÄ±m. AÃ§Ä±lan sayfadan dosyamÄ±zÄ±n adÄ±nÄ± index.html olarak belirledikten sonra iÃ§eriÄŸine bir ÅŸeyler yazalÄ±m. Index.html dosyasÄ±nÄ±n iÃ§eriÄŸini hallettikten sonra aynÄ± sayfanÄ±n hemen altÄ±nda yer alan Commit new file butonuna tÄ±klÄ±yoruz. Index.html sayfamÄ±z oluÅŸtuÄŸuna gÃ¶re artÄ±k Github sayfamÄ±zÄ± tekrar kontrol edebiliriz. EÄŸer oluÅŸturduÄŸunuz index.html dosyasÄ± gÃ¶rÃ¼ntÃ¼lendiyse doÄŸru yoldasÄ±nÄ±z. Buraya kadar hiÃ§bir sorun yaÅŸamadan geldiyseniz devam edebiliriz. Jekyll Nedir?Jekyll, Ruby ile yazÄ±lmÄ±ÅŸ bir uygulamadÄ±r. Basit ama gÃ¼Ã§lÃ¼ bir alt yapÄ±ya sahip statik site oluÅŸturucusudur. Markdown veya Textile formatÄ±nda yazdÄ±ÄŸÄ±nÄ±z sayfayÄ± statik HTML sayfasÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. Jekyll NasÄ±l Kurulur?Dikkat! Ben Windows kullandÄ±ÄŸÄ±m iÃ§in Windows kurulumunu baz alÄ±yorum. Ä°lk olarak Rubyâ€˜yi indirip kurmamÄ±z gerekiyor. www.ruby-lang.org/tr/downloads Rubyâ€™yi kurduktan sonra RubyGemsâ€˜i kurmamÄ±z gerekiyor. rubygems.org/pages/download Kurulumun baÅŸarÄ±lÄ± olup olmadÄ±ÄŸÄ±nÄ± anlamak iÃ§in Komut SatÄ±rÄ±nÄ± (Nam-Ä± diÄŸer Cemede) aÃ§Ä±yoruz. Ruby iÃ§in aÅŸaÄŸÄ±daki komutu yazÄ±yoruz. 1ruby -v EÄŸer versiyon numarasÄ± gÃ¶zÃ¼kÃ¼rse baÅŸarÄ±yla yÃ¼klenmiÅŸtir AynÄ± durum RubyGems iÃ§in de geÃ§erli. Bunun iÃ§in de aÅŸaÄŸÄ±daki komutu yazÄ±yoruz. 1gem -v Versiyon numarasÄ±nÄ± gÃ¶rdÃ¼ysek sÄ±kÄ±ntÄ± yok. Rubyâ€™yi ve RubyGemsâ€™i yÃ¼kledikten sonra ÅŸimdi sÄ±ra Jekyllâ€˜in yÃ¼klenmesine geldi. Bu sefer komut satÄ±rÄ±na aÅŸaÄŸÄ±daki komutu yazÄ±yoruz. 1gem install jekyll Jekyllâ€™in yÃ¼klenmesi tamamlandÄ±ÄŸÄ±nda yine versiyon kontrolÃ¼ ile yÃ¼klenme durumuna bakabilirsiniz. BÃ¼tÃ¼n kurulumlarÄ± tamamladÄ±k. Åimdi Jekyll ile ilk blogumuzu oluÅŸturmaya hazÄ±rÄ±z. Jekyll Projesi NasÄ±l OluÅŸturulur?Yeni boÅŸ bir klasÃ¶r aÃ§Ä±p iÃ§erisinde komut satÄ±rÄ±nÄ± Ã§alÄ±ÅŸtÄ±ralÄ±m ve aÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±ralÄ±m. 1jekyll new {proje adÄ±} Projemiz oluÅŸtuktan sonra projemizin bulunduÄŸu dizine geÃ§elim. 1cd {proje adÄ±} Projemizin bulunduÄŸu dizine geÃ§tikten sonra localhost Ã¼zerinde test edebiliriz. Bunun iÃ§in yine komut satÄ±rÄ±na aÅŸaÄŸÄ±daki komutu yazalÄ±m. 1jekyll serve Bu komutu yazdÄ±ÄŸÄ±mÄ±zda localhost:4000 adresinden projemizin Ã§alÄ±ÅŸÄ±r halini gÃ¶rebiliriz. Projemizi oluÅŸturduk. Åimdi sÄ±rada Github Ã¼zerindeki Ã§alÄ±ÅŸma alanÄ±na atmak kaldÄ±. NasÄ±l yayÄ±nlanÄ±r?OluÅŸturduÄŸumuz Jekyll projemizi Github Ã§alÄ±ÅŸma alanÄ±mÄ±za atmak iÃ§in Github Desktop uygulamasÄ±nÄ± indirip kurmamÄ±z gerekiyor. desktop.github.com Github Desktop uygulamasÄ±nÄ± kurduktan sonra Github Ã¼zerindeki projemize giderek Clone or download butonuna tÄ±klayÄ±p aÃ§Ä±lan yerden Open in Desktop butonuna tÄ±kladÄ±ÄŸÄ±mÄ±zda Github Desktop uygulamasÄ± devreye girecek ve Ã§alÄ±ÅŸma alanÄ±mÄ±zÄ± nereye oluÅŸturacaÄŸÄ±nÄ± seÃ§tikten sonra Ã§alÄ±ÅŸma alanÄ±mÄ±zÄ±n kendi diskimize klonlandÄ±ÄŸÄ±nÄ± gÃ¶receÄŸiz. Jekyll projemizi klonladÄ±ÄŸÄ±mÄ±z Github Ã§alÄ±ÅŸma alanÄ±na kopyala yapÄ±ÅŸtÄ±r yaptÄ±ktan sonra Commit ediyoruz. Commit ve Sync iÅŸlemlerini tamamladÄ±ktan sonra projemizin {kullanÄ±cÄ± adÄ±m}.github.io adresinden Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol edebiliriz. Bu yazÄ±m da burada son bulsun. Bir sonraki yazÄ±mda {kullanÄ±cÄ± adÄ±m}.github.io ÅŸeklinde olan adresi istediÄŸimiz bir alan adÄ± ile aÃ§ma yani Custom Domain Ã¼zerine olacak. Github Pages Custom Domain Ã¼zerine yazdÄ±ÄŸÄ±m yazÄ±mÄ± da okumak ister misin? Olur ya bir gÃ¼n gÃ¶rÃ¼ÅŸemezsek iyi gÃ¼nler, iyi akÅŸamlar ve iyi gecelerâ€¦","link":"/github-pages-ile-gelistiricilere-ucretsiz-blog/"},{"title":"Javascript Function All Parameters Is Empty","text":"Bir fonksiyondaki parametrelerin hiÃ§biri girilmediyse bunun kontrolÃ¼nÃ¼ ES ile halledebiliriz. 123456function Test(a,b,c,...){ if(arguments.length === 0){ //HiÃ§bir paremetre girilmemiÅŸtir. //Tek tek sorgulamaya gerek kalmaz }}","link":"/javascript-function-all-parameters-is-empty/"},{"title":"Javascript Function Parameter Set Default Value","text":"Bir fonksiyonun parametresine varsayÄ±lan deÄŸeri aÅŸaÄŸÄ±daki gibi atÄ±yoruz. 123456789101112131415function Hello(name){ var name = name || 'Mehmet'; Console.log('Hello ' + name);}Hello();Hello('Emin');Hello(0);/*Result:-&gt; Hello Mehmet-&gt; Hello Emin-&gt; Hello Mehmet */","link":"/javascript-function-parameter-set-default-value/"},{"title":"Javascript Self Invoking Functions","text":"Javascript ile oluÅŸturduÄŸumuz bir fonksiyonu otomatik olarak Ã§aÄŸÄ±rma. 1234567891011//Normal Ã§aÄŸÄ±rmavar test = function(name){ return ('Hello ' + name);};test('Mehmet'); //Otomatik Ã§aÄŸÄ±rmavar test = function(name){ return ('Hello ' + name);}('Mehmet');","link":"/javascript-self-invoking-functions/"},{"title":"Jquery Only Parent Click","text":"Jquery ile sadece parent elemente tÄ±klama eventÄ± ekleme. 1234567891011//Sadece Html elementine tÄ±klandÄ±ÄŸÄ±nda iÅŸlem yapar.$('#outer').click(function(e) { if (e.target === this){ console.log('Parent'); }});//Html elementinin kendisine tÄ±klanmadÄ±ysa iÅŸlem yapmadan dÃ¶n.$('#outer').click(function(e) { if(e.target != this) return;});","link":"/jquery-only-parent-click/"},{"title":"jQuery Video Extend","text":"Videolara logo ve duraklama noktalarÄ± ekleyebileceÄŸiniz, youtube Ã¼zerinden veya flv dosyalarÄ±nda video oynatmamÄ±zÄ± saÄŸlayan bir jQuery eklentisi. Ã–rnek Ã‡alÄ±ÅŸma DetaylarÄ±","link":"/jquery-video-extend/"},{"title":"MSSQL Server 2014 LocalDB Connection String","text":"Eski projelerimin bazÄ±larÄ±nda SQL Server 2012 kullanarak LocalDB baÄŸlantÄ±sÄ±nÄ± (LocalDB)\\v11.0 ÅŸeklinde yaparak gerÃ§ekleÅŸtiriyordum. SQL Server 2014 te ise bu baÄŸlantÄ± ÅŸekli deÄŸiÅŸmiÅŸ ve artÄ±k (LocalDB)\\MSSQLLocalDB olarak baÄŸlantÄ±yÄ± saÄŸlayabildim. Ã–rnek connection stringler ÅŸu ÅŸekilde; SQL Server 2012 LocalDB Connection String 123&lt;connectionStrings&gt; &lt;add name=\"DBContext\" connectionString=\"Data Source=(LocalDB)\\\\v11.0;AttachDbFilename=|DataDirectory|\\\\Database.mdf;Integrated Security=True;\" providerName=\"System.Data.SqlClient\" /&gt;&lt;/connectionStrings&gt; SQL Server 2014 LocalDB Connection String 123&lt;connectionStrings&gt; &lt;add name=\"DBContext\" connectionString=\"Data Source=(LocalDB)\\\\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\\\\Database.mdf;Integrated Security=True;\" providerName=\"System.Data.SqlClient\" /&gt;&lt;/connectionStrings&gt; Olur ya bir gÃ¼n gÃ¶rÃ¼ÅŸemezsek iyi gÃ¼nler, iyi akÅŸamlar ve iyi gecelerâ€¦","link":"/mssql-server-2014-localdb-connection-string/"},{"title":"MSSQL Server TÃ¼rkÃ§e Karakter Destekli VeritabanÄ± OluÅŸturmak","text":"TÃ¼rkÃ§e karakter destekli veritabanÄ± iÃ§in aÅŸaÄŸÄ±daki SQL kodlarÄ±nÄ± kullanmanÄ±z yeterli olacaktÄ±r. 123ALTER DATABASE veritabani_adi SET SINGLE_USER WITH ROLLBACK IMMEDIATEALTER DATABASE veritabani_adi COLLATE TURKISH_CI_ASALTER DATABASE veritabani_adi SET MULTI_USER Olur ya bir gÃ¼n gÃ¶rÃ¼ÅŸemezsek iyi gÃ¼nler, iyi akÅŸamlar ve iyi gecelerâ€¦","link":"/mssql-server-turkce-karakter-destekli-veritabani-olusturmak/"},{"title":"Nesne YÃ¶nelimli TasarÄ±m Prensipleri â€“ SOLID - 1","text":"Merhaba yazÄ±lÄ±mÄ± seven ve gÃ¶nÃ¼l veren deÄŸerli arkadaÅŸlar, bu blog yazÄ±mÄ±n konusu nesne yÃ¶nelimli programlamada â€œolmazsa olmazâ€ diyemem ama â€œolmasÄ± gerekenâ€ teknikler Ã¼zerinde duracaÄŸÄ±m. YazÄ±lÄ±m camiasÄ±nda standart haline gelmiÅŸ SOLID prensipleri olarak anÄ±lan beÅŸ teknikten bahsedeceÄŸim. Robert Cecil Martinâ€™in (Nam-Ä± diÄŸer Uncle Bob) sunumu ile yaygÄ±nlaÅŸmaya baÅŸlayan SOLID, bir Dependency Managament (BaÄŸÄ±mlÄ±lÄ±k YÃ¶netimi) biÃ§imidir. Uncle Bob ayrÄ±ca, 2000 senesinde Kent Beck ve 15 arkadaÅŸÄ± ile Agile Manifestonun oluÅŸturulmasÄ±nda yer almÄ±ÅŸtÄ±r. SOLID, Single Responsibility, Open Closed, Liskov Substitutio, Interface Segregation, Dependency Inversion prensiplerinden oluÅŸur. Bu prensiplerin kullanÄ±lmasÄ±ndaki temel amaÃ§ esnek ve geliÅŸtirilmesi kolay yazÄ±lÄ±mlar oluÅŸturmaktÄ±r. EÄŸer bu prensipleri sadece uygulamÄ±ÅŸ olmak iÃ§in yaparsak kompleks bir yapÄ± oluÅŸacaktÄ±r. Bu yÃ¼zden projenin bÃ¶yle bir ÅŸeye ihtiyacÄ± olup olmadÄ±ÄŸÄ±nÄ± iyi analiz etmemiz gerekir. YazÄ±lÄ±m geliÅŸtirmede amaÃ§ her zaman en basit yÃ¶ntemler kullanarak, sade ve esnek yapÄ±lar oluÅŸturmak olmalÄ±dÄ±r. Yerine gÃ¶re SOLIDâ€™i kullanÄ±p kullanmamak bize kalmÄ±ÅŸtÄ±r. BaÄŸÄ±mlÄ±lÄ±k seviyesi yÃ¼ksek kÃ¶tÃ¼ tasarlanmÄ±ÅŸ projelerin benzer Ã¼Ã§ Ã¶zelliÄŸi vardÄ±r: (Rigidty) Esnek deÄŸillerdir. GeliÅŸtirmelere ve yeni eklentilere kapalÄ±dÄ±rlar. (Fragility) KÄ±rÄ±lgandÄ±rlar. Projenin herhangi bir yerinde yapacaÄŸÄ±m bir deÄŸiÅŸiklik baÅŸka yerleri etkiler. (Immobilty) Sabittirler. Tekrar kullanÄ±ma uygun deÄŸillerdir. Bu kÃ¶tÃ¼ tasarÄ±mÄ± SOLID ile ortadan kaldÄ±rabiliriz. Bir sonraki yazÄ±m SOLIDâ€™in Sâ€™si olan Single Responsibility Principle (SRP) â€“ Tek Sorumluluk Prensibi Olur ya bir gÃ¼n gÃ¶rÃ¼ÅŸemezsek iyi gÃ¼nler, iyi akÅŸamlar ve iyi gecelerâ€¦","link":"/nesne-yonelimli-tasarim-prensipleri-solid-1/"},{"title":".Net Projelerinde Otomatik Versiyonlama","text":"Yeni bir .Net projesini Visual Studio ortamÄ±nda oluÅŸturduÄŸumuzda projenin Ã¶zellikleri altÄ±nda AssemblyInfo adlÄ± bir dosya da varsayÄ±lan olarak oluÅŸturulmaktadÄ±r. Bu dosyada projenin derleme bilgileri (projenin adÄ±, versiyon bilgileri gibi) tutulur. Biz de bu dosyada yer alan AssemblyVersion Ã¶zelliÄŸine, SVN revision numarasÄ±nÄ± otomatik atayacaÄŸÄ±z. Ã–ncelikle .Net projelerinde versiyonlama standartÄ±nÄ± gÃ¶relim; Versiyon ({Major}.{Minor}.{Build Number}.{Revision}) ÅŸeklindedir. Major Version: BÃ¼yÃ¼k yeniliklerde manuel olarak artÄ±rÄ±lÄ±r.Minor Version: KÃ¼Ã§Ã¼k deÄŸiÅŸikliklerde manuel olarak artÄ±rÄ±lÄ±r.Build Number: Derme numarasÄ± otomatik olarak atanacak.Revision: Her commit sonrasÄ± SVN tarafÄ±ndan otomatik gelen deÄŸer. KÄ±sa bir aÃ§Ä±klamadan sonra ÅŸimdi iÅŸe koyulabiliriz. Versiyonlama sistemi iÃ§in aÃ§Ä±k kaynak kodlu olan MSBuild Community Tasks kÃ¼tÃ¼phanesini kullanacaÄŸÄ±z. Nuget: 1PM&gt; Install-Package MSBuildTasks Paketi ekledikten sonra projemizin .csproj dosyasÄ±nÄ± aÃ§Ä±p aÅŸaÄŸÄ±daki Ã¶zellikleri eklemeliyiz. Not: KullandÄ±ÄŸÄ±mÄ±z SVN programÄ±nÄ±n bulunduÄŸu yolu belirtmeliyiz ve SVN programÄ±nÄ±n tam yÃ¼klÃ¼ olmasÄ± gereklidir. Projemizi derlediÄŸimiz zaman AssemblyVersion bilgisinin x.x.x.Revision ÅŸeklinde olduÄŸunu gÃ¶receÄŸiz. Bu yazÄ± da bu kadar olsun artÄ±k. KÄ±sa ve Ã¶z. ğŸ™‚ Olur ya bir gÃ¼n gÃ¶rÃ¼ÅŸemezsek iyi gÃ¼nler, iyi akÅŸamlar ve iyi gecelerâ€¦","link":"/net-projelerinde-otomatik-versiyonlama/"},{"title":"Oracle Query â€“ Get Version","text":"Oracle veritabanÄ±nda hangi sÃ¼rÃ¼mÃ¼n kullanÄ±ldÄ±ÄŸÄ±nÄ± merak ettim ve bunu buldum: 1SELECT * FROM V$VERSION","link":"/oracle-get-version-query/"},{"title":"Single Responsibility Principle (SRP) â€“ Tek Sorumluluk Prensibi - 2","text":"Bir Ã¶nceki blog yazÄ±mda Nesne YÃ¶nelimli TasarÄ±m Prensipleri â€“ SOLID Ã¼zerinde durmuÅŸtuk. Bu yazÄ±mda ise SOLIDâ€™in Sâ€™si olan Single Responsibility Principle (SRP) â€“ Tek Sorumluluk Prensibi Ã¼zerinde duracaÄŸÄ±m. Single Responsibility Principle (SRP) â€“ Tek Sorumluluk Prensibi Bir sÄ±nÄ±fÄ±n veya metodun sadece bir sorumluluÄŸu vardÄ±r. Bu sayede bir deÄŸiÅŸiklik yapacaÄŸÄ±mÄ±z zaman sadece bir nedenimiz olur. Peki bu ne anlama geliyor? Resimde birden fazla iÅŸi yapan bir alet (Ã§akÄ±) gÃ¶rÃ¼yorsunuz. Bu aletin o kadar fazla sorumluluÄŸu var ki, yeni bir sorumluluk eklemek istediÄŸimde ya da kÄ±rÄ±lan bir parÃ§ayÄ± deÄŸiÅŸtirmek istediÄŸimizde yapÄ±sÄ±na mÃ¼dahale etmem gerekecek. EÄŸer alet sadece bÄ±Ã§ak olsaydÄ± ya da tornavida, yani tek bir sorumluluÄŸu olmuÅŸ olsaydÄ±, kÄ±rÄ±lan kÄ±smÄ±nÄ± kolay bir ÅŸekilde deÄŸiÅŸtirebilecektim. Belki yerden tasarruf edemezdim ancak zamandan tasarruf edeceÄŸim ortada. YazÄ±lÄ±m geliÅŸtirmede amaÃ§ her zaman en basit yÃ¶ntemler kullanarak, sade ve esnek yapÄ±lar oluÅŸturmaktÄ±r, demiÅŸtik. YazÄ±lÄ±msal aÃ§Ä±dan bakarsak nasÄ±l bir sonuca ulaÅŸÄ±rÄ±z? Bir sÄ±nÄ±fÄ±mÄ±z olsun ve bu sÄ±nÄ±fÄ±n iÃ§erisinde Allah ne verdiyse yazdÄ±ÄŸÄ±mÄ±zÄ± dÃ¼ÅŸÃ¼nelim. Bir sÃ¼re sonra kodun binlerce satÄ±ra ulaÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz. EditÃ¶r bile kodlarÄ± gÃ¶sterirken kasÄ±lÄ±r. Bir yeri deÄŸiÅŸtirmek canÄ±mÄ±za okur ve geÃ§miÅŸ yazÄ±lÄ±mcÄ±lara sevmeler baÅŸlar. Seve seve biz de aynÄ± ÅŸeklide kodumuzu yazarÄ±z. SonuÃ§; bÃ¼yÃ¼k ve karmaÅŸÄ±k ve yÃ¶netimi zor kodlar, kÄ±rÄ±lgan ve esnek olmayan bir yapÄ±. YalnÄ±zca kendi sorumluluÄŸunu yerine getirecek ÅŸekilde parÃ§alara bÃ¶lseydik bu sonuÃ§ ile karÅŸÄ±laÅŸmayacaktÄ±k. Ã–rnek C# kodu: 12345678910111213141516171819202122public class FullStackDeveloper{ public void WriteCSharpCode() { Console.WriteLine(\"I can write C#.\"); } public void WriteSQLCode() { Console.WriteLine(\"I can write SQL.\"); } public void WriteJavaScriptCode() { Console.WriteLine(\"I can write JavaScript.\"); } public void WriteCSSCode() { Console.WriteLine(\"I can write CSS.\"); }} â€œFullStackDeveloperâ€ sÄ±nÄ±fÄ±mÄ±z C#, SQL, JavaScript ve CSS kodu yazabilen bir yazÄ±lÄ±m geliÅŸtiricisini temsil etsin. Tek bir geliÅŸtiriciye bu kadar iÅŸin yÃ¼klenmesi geliÅŸtiricinin hata yapma olasÄ±lÄ±ÄŸÄ±nÄ± yÃ¼kseltecektir. Ã‡Ã¼nkÃ¼, bir yerden sonra kafa Ã§orbasÄ± iÃ§ilmeye hazÄ±r hale gelecektir. OlmasÄ± gereken ise aslÄ±nda ÅŸudur: 12345678910111213141516171819202122232425262728public class BackEndDeveloper{ public void WriteCSharpCode() { Console.WriteLine(\"I can write C#.\"); }}public class FrontEndDeveloper{ public void WriteJavaScriptCode() { Console.WriteLine(\"I can write JavaScript.\"); } public void WriteCSSCode() { Console.WriteLine(\"I can write CSS.\"); }}public class SQLDeveloper{ public void WriteSQLCode() { Console.WriteLine(\"I can write SQL.\"); }} KÄ±sacasÄ±, herkes kendi iÅŸini yapmalÄ±dÄ±r! Olur ya bir gÃ¼n gÃ¶rÃ¼ÅŸemezsek iyi gÃ¼nler, iyi akÅŸamlar ve iyi gecelerâ€¦","link":"/single-responsibility-principle-srp-tek-sorumluluk-prensibi-2/"},{"title":"SQL Bir Tablonun AynÄ±sÄ±nÄ± OluÅŸturma","text":"Bir tablonun aynÄ± kolonlara sahip bir kopyasÄ±nÄ± oluÅŸturmak istersek yazmamÄ±z gereken sorgu ÅŸu ÅŸekilde: 1select top 0 * into table2 from table1 Bu sorgu ile table1 tablosunun aynÄ±sÄ±nÄ± table2 ismiyle oluÅŸturur.","link":"/sql-bir-tablonun-aynisini-olusturma/"},{"title":"SQL Create Temp Table Declare","text":"Temp tablo oluÅŸturmak iÃ§in bir yÃ¶ntem. 12345DECLARE @TempTable TABLE( test1 INT, test2 NVARCHAR(MAX), test3 NVARCHAR(MAX))","link":"/sql-create-temp-table-declare/"},{"title":"Sql Execution Timing","text":"MSSQL 2008 ve Ã¼zeri sorgu sÃ¼resini hesaplama 12345Declare @StartTime DateTime = GetDate()-- my SQL callsPrint 'Time taken was ' + cast(DateDiff(millisecond, @StartTime, GetDate()) as varchar) + 'ms'","link":"/sql-execution-timing/"},{"title":"SQL Trigger Toplu Update Sorunu","text":"Bazen triggerlarda where kullandÄ±ÄŸÄ±mÄ±z sorgular varsa, bu sorgular toplu update iÅŸlemi sÄ±rasÄ±nda hata oluÅŸturuyor. Where yerine Join kullanmak sorunu Ã§Ã¶zebilir.","link":"/sql-trigger-toplu-update-sorunu/"},{"title":"SQL â€“ Update Ä°le Daha PerformanslÄ± Ä°ÅŸlem Yapma","text":"Bir sorgu iÃ§erisinde herhangi bir kolunun deÄŸerini bir fonksiyon ile dÃ¼zenleyip basarsak performans kaybÄ± olur. Ancak ilk olarak kolona varsayÄ±lan deÄŸerini basÄ±p daha sonra toplu bir update Ã§ekersek gÃ¶zle gÃ¶rÃ¼lÃ¼r performans artÄ±ÅŸÄ± olur. 123UPDATE upb SET upb.yas = Hesapla(yas) FROM TempTable_UyeProfilBilgileri upb","link":"/sql-update-ile-daha-performansli-islem-yapma/"},{"title":"Stored Procedures and Tables Last Modify Date","text":"MSSQL sys.objects tablosundan Ã¼zerinde deÄŸiÅŸiklik yapÄ±lma tarihlerine gÃ¶re tablolarÄ± ve stored proceduresleri listeleme sorgusu. U ile ifade edilenler tablo, P ile ifade edilenler ise SP. 1234SELECT name, create_date, modify_date, typeFROM sys.objectsWHERE type = 'U' OR type = 'P'ORDER BY modify_date DESC","link":"/stored-procedures-and-tables-last-modify-date/"},{"title":"TypeItJs â€“ Harf Harf Animasyonlu YazÄ±m KÃ¼tÃ¼phanesi","text":"Az Ã¶nce internette dolaÅŸÄ±rken karÅŸÄ±ma Ã§Ä±kan, hoÅŸuma giden webmaster araÃ§larÄ±nÄ±, kÃ¼tÃ¼phanelerini, hem unutmamak hem de sizlerle paylaÅŸmak iÃ§in fazla aÃ§Ä±klama yapmadan paylaÅŸmaya karar verdim. Bu kategorinin ilk kÃ¼tÃ¼phanesi TypeItJs. Harf harf animasyonlu yazÄ± yazmamÄ±zÄ± saÄŸlayan gÃ¼zel bir kÃ¼tÃ¼phane. TypeItJs â€“ Hemen Ä°nceleâ€¦","link":"/typeitjs-harf-harf-animasyonlu-yazim-kutuphanesi/"},{"title":"Visual Studio ile SVN KullanÄ±mÄ±","text":"VisualSVN kurulumu ve kullanÄ±mÄ± hakkÄ±nda.Bir Ã¶nceki yazÄ±mda Dropbox Ãœzerine SVN Kurulumundan bahsetmiÅŸtim. Bu yazÄ±mda da sÃ¶z verdiÄŸim Ã¼zere Visual Studio ortamÄ±ndayken projenizde deÄŸiÅŸiklik yaptÄ±ÄŸÄ±nÄ±z alanlarÄ± gÃ¶stererek commit etminizi saÄŸlayan VisualSVN eklentisinin kurulumunu ve kullanÄ±mÄ±nÄ± anlatacaÄŸÄ±m. VisualSVN 5.1.4 sÃ¼rÃ¼mÃ¼ ile Visual Studio 2015 e kadar destekliyor. VisualSVN eklentisini indirmek iÃ§in bu linke tÄ±klayÄ±n. www.visualsvn.com Ä°ndirme ve kurulum iÅŸlemleri bittikten sonra Visual Studioâ€™ yu aÃ§tÄ±ÄŸÄ±mÄ±z pencerenin Ã¼stÃ¼nde VisualSVN menÃ¼sÃ¼nÃ¼ gÃ¶rdÃ¼ÄŸÃ¼mÃ¼zde kurulum baÅŸarÄ±lÄ± olmuÅŸ demektir. Daha Ã¶nce oluÅŸturduÄŸumuz SVN klasÃ¶rÃ¼nÃ¼n iÃ§erisine herhangi bir yeni proje oluÅŸturalÄ±m. OluÅŸturduÄŸumuz anda VisualSVN projenin SVN klasÃ¶rÃ¼ iÃ§erisinde yer aldÄ±ÄŸÄ±nÄ± anlayarak Solution Explorerâ€˜ da deÄŸiÅŸiklik olan dosyalarÄ±n sol tarafÄ±na bir simge atarak o dosyanÄ±n commit edilebilir olduÄŸunu gÃ¶steriyor. Projemize saÄŸ tÄ±klayÄ±p commit dediÄŸimizde bÃ¼tÃ¼n proje commit edilmiÅŸ olur. EÄŸer sadece Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±z dosyayÄ± commit etmek istiyorsanÄ±z o dosyaya saÄŸ tÄ±klayÄ±p aynÄ± iÅŸlemleri yaptÄ±ÄŸÄ±nÄ±zda commit iÅŸlemi gerÃ§ekleÅŸtiriliyor. Olur ya bir gÃ¼n gÃ¶rÃ¼ÅŸemezsek iyi gÃ¼nler, iyi akÅŸamlar ve iyi gecelerâ€¦","link":"/visual-studio-ile-svn-kullanimi/"},{"title":"Stryker Mutator ile Mutation Testing ve Azure Pipelines Entegrasyonu","text":"YazmÄ±ÅŸ olduÄŸumuz bir unit testin kalitesini anlamak iÃ§in, testi yazÄ±lan kod parÃ§acÄ±ÄŸÄ± Ã¼zerinde deÄŸiÅŸiklikler yaptÄ±ÄŸÄ±mÄ±zda, unit testin sonucuna bir etkisi olup olmadÄ±ÄŸÄ±nÄ± analiz ederek kalitesini ve kapsamÄ±nÄ± kontrol edebiliriz. Bu ÅŸekilde yapmÄ±ÅŸ olduÄŸumuz iÅŸleme bir nevi â€œtestin testini yapmakâ€ diyebiliriz. Bu yapÄ±lan iÅŸleme Mutation Testing denilmektedir. Kod parÃ§acÄ±klarÄ±nÄ±n mutasyona uÄŸratÄ±lmasÄ± sonucunda kalite ve kapsam analizi yapÄ±lmaktadÄ±r. Yeni unit testler yazmak ve mevcut unit testlerin kalitesini deÄŸerlendirmek iÃ§in Mutation Testing yapÄ±lmalÄ±dÄ±r. Mutation Testing, bir kod parÃ§acÄ±ÄŸÄ±nÄ± kÃ¼Ã§Ã¼k ÅŸekillerde deÄŸiÅŸtirmeyi amaÃ§lar. Bu deÄŸiÅŸiklikler, aritmetik operatÃ¶r, eÅŸiklik veya mantÄ±ksal ifadelerin deÄŸiÅŸtirilmesi gibi iÅŸlemlerdir. DeÄŸiÅŸikliklerin sonucunda oluÅŸan her bir yeni kod parÃ§acÄ±ÄŸÄ±na â€œMutantâ€ denilir. Burada beklenilen durum, unit test Ã§alÄ±ÅŸtÄ±ÄŸÄ± zaman oluÅŸan mutantÄ±n Ã¶lmesidir. EÄŸer mutant Ã¶lmez ise unit testimizin kapsamadÄ±ÄŸÄ± bir durum var demektir. Kod parÃ§acÄ±ÄŸÄ± Ã¼zerinde ileride yapÄ±lacak bir deÄŸiÅŸiklik muhtemelen unit testimizi etkilemeyecektir. Mutation Testing manuel olarak yapÄ±labileceÄŸi gibi otomatik olarak araÃ§lar kullanÄ±larak da yapÄ±labilir. Mutation Testing temelde 3 tÃ¼re ayrÄ±labilir. Bunlar; ifade mutasyonu (statement mutation), karar mutasyonu (decision mutation) ve deÄŸer mutasyonudur (value mutation). BilgiMutation Testing ilk olarak Richard Lipton tarafÄ±ndan 1971â€™de Ã¶nerildi. Bir Mutation Testing aracÄ±nÄ±n ilk uygulamasÄ±, 1980 yÄ±lÄ±nda Timothy Budd tarafÄ±ndan yapÄ±ldÄ±. Otomatik olarak Mutation Testing yapmamÄ±zÄ± saÄŸlayan araÃ§lardan bir tanesi Stryker Mutatorâ€™dÄ±r. Stryker Mutator ile kod parÃ§acÄ±klarÄ±nÄ± mutasyona uÄŸratarak yani deÄŸiÅŸtirerek mutation testing iÅŸlemini yapmamÄ±zÄ± kolaylaÅŸtÄ±ran bir araÃ§tÄ±r. Bu araÃ§ sayesinde, daha kaliteli ve dayanÄ±klÄ±, kapsamÄ± geniÅŸ unit testler yazabiliriz. .NET desteÄŸi ile CLI Ã¼zerinden testimizi analiz ettirebiliriz. Bir diÄŸer araÃ§ ise PIT Testing. PIT Testing ile SonarQube Ã¼zerinden de analiz sonuÃ§larÄ±nÄ± gÃ¶rebiliriz. Stryker Mutator ile de Azure Pipelines entegrasyonu sayesinde SonarQube ihtiyacÄ± olmadan da analiz sonuÃ§larÄ±nÄ± gÃ¶rmemiz mÃ¼mkÃ¼n. Ä°ÅŸin hikaye kÄ±smÄ±nÄ± Ã§ok fazla uzatmadan artÄ±k Ã¶rneÄŸimize geÃ§elim: Stryker Mutator Kurulumu ve KullanÄ±mÄ± Projemizin solution yapÄ±sÄ± Basit matematiksel iÅŸlemler yapan, Calc isimli bir class oluÅŸturalÄ±m. Åimdilik sadece toplama iÅŸlemini eklememiz yeterli olacaktÄ±r. Unit Test Caseâ€™i oluÅŸturmak amacÄ±yla â€œValidateâ€ isimli bir metod yazarak sadece pozitif tamsayÄ±lar Ã¼zerinde iÅŸlem yapÄ±lmasÄ±nÄ± saÄŸladÄ±m. NUnit kullanarak unit test yazacaÄŸÄ±z. 12345678910111213141516public class Calc{ public double Sum(int x, int y) { Validate(x, y); return x + y; } public void Validate(int x, int y) { if (x &lt; 0 || y &lt; 0) { throw new ArgumentException(\"Only positive integers can be used.\"); } }} AÅŸaÄŸÄ±da da Calc clasÄ±mÄ±z iÃ§in yazdÄ±ÄŸÄ±mÄ±z unit testleri gÃ¶rebilirsiniz. 123456789101112131415161718192021public class CalcTest{ Calc _testClass; [SetUp] public void Setup() { _testClass = new Calc(); } [TestCase(0, 0, 0)] [TestCase(1, 0, 1)] [TestCase(1, 1, 2)] [TestCase(2, 1, 3)] [TestCase(9, 4, 13)] public void SumTest(int x, int y, int expectedResult) { var actualResult = _testClass.Sum(x, y); Assert.AreEqual(expectedResult, actualResult); }} Test Explorer Ã¼zerinden unit testlerimizi Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda oluÅŸan 5 case iÃ§in tÃ¼m testlerin baÅŸarÄ±lÄ± olduÄŸunu gÃ¶rdÃ¼k. Buraya kadar olan kÄ±sÄ±m standart unit test geliÅŸtirme adÄ±mlarÄ±ydÄ±. Siz de basit bir proje Ã¼zerinden denemeler yapabilirsiniz. Åimdi sÄ±ra geldi Stryker Mutator kurulumuna. Stryker Mutator kurulumunu gerÃ§ekleÅŸtirebilmek iÃ§in 2 yÃ¶ntem var. Bunlardan bir tanesi Nuget ile kurulumu diÄŸeri ise .NET CLI Ã¼zerinden kurulumudur. Ben CLI Ã¼zerinden kurulumu tercih ettim. Global yÃ¼kleyerek de tÃ¼m tÃ¼m projelerimde kullanÄ±ma hazÄ±r hale getirmiÅŸ oldum. Tabi bunun iÃ§in â€œdotnet CLIâ€ bilgisayarÄ±mÄ±zda yÃ¼klÃ¼ olmalÄ±. AÅŸaÄŸÄ±daki komut ile Stryker Mutator global olarak bilgisayarÄ±ma yÃ¼kleyebiliriz. 1dotnet tool install -g dotnet-stryker Kurulumdan sonra dotnet-stryker komutu ile saÄŸlamasÄ±nÄ± yapabiliriz. Stryker Mutatorâ€™Ä± kullanÄ±ma hazÄ±r hale getirdikten sonra unit testlerimiz Ã¼zerinde analiz yapmaya baÅŸlayabiliriz. Stryker Mutator, Unit Test projemizin bulunduÄŸu dizinde Ã§alÄ±ÅŸtÄ±rÄ±lmalÄ±dÄ±r. Bu sayede ekstra parametreler girmek zorunda kalmayÄ±z. Developer Powershellâ€™i Unit Test projemizin bulunduÄŸu dizini gÃ¶stererek baÅŸlatalÄ±m. Bundan sonrasÄ± ise Ã§ok kolay, sadece dotnet-stryker komutunu yazÄ±p Enter tuÅŸuna bastÄ±ÄŸÄ±mÄ±zda mutasyon iÅŸlemlerini baÅŸlatmÄ±ÅŸ oluruz. Mutasyon iÅŸlemleri bittiÄŸinde ise yukarÄ±daki gibi bir ekran gÃ¶rÃ¼ntÃ¼sÃ¼ ile karÅŸÄ±laÅŸÄ±rÄ±z. Burada toplan test caseâ€™i, oluÅŸturulan mutant sayÄ±sÄ±nÄ± ve bizim iÃ§in daha Ã¶nemli olan mutasyon skorunu ve rapor Ã§Ä±ktÄ±sÄ±nÄ± gÃ¶rÃ¼yoruz. Ã–rneÄŸin, Calc sÄ±nÄ±fÄ±mÄ±z iÃ§in yazdÄ±ÄŸÄ±mÄ±z unit testler iÃ§in mutasyon skoru %75 olarak belirlenmiÅŸ. Bu da ÅŸu demek oluyor: oluÅŸturulan 8 mutanttan 6 tanesini yazmÄ±ÅŸ olduÄŸumuz unit testler Ã¶ldÃ¼rdÃ¼. AÅŸaÄŸÄ±da da oluÅŸturulan html formatÄ±ndaki raporun ekran gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ gÃ¶rebilirsiniz. â€œCalc.csâ€ sayfasÄ±nÄ± aÃ§tÄ±ÄŸÄ±mÄ±zda, 6 mutantÄ±n Ã¶ldÃ¼ÄŸÃ¼nÃ¼, 1 tanesinin hayatta kaldÄ±ÄŸÄ±nÄ± ve 1 tanesinin de kapsanmadÄ±ÄŸÄ±nÄ± gÃ¶rmekteyiz. Åimdi sÄ±rayla bu sorunlarÄ± Ã§Ã¶zelim: 1. Kodun Unit Test ile kapsanmasÄ±nÄ± saÄŸlayalÄ±m: Kodumuzu incelediÄŸimizde 15.satÄ±rdaki ÅŸartÄ± saÄŸlayan x veya y deÄŸeri sÄ±fÄ±rdan kÃ¼Ã§Ã¼k gÃ¶nderilirse 17.satÄ±rÄ±n kapsanmasÄ±nÄ± saÄŸlayabiliriz. Bunun iÃ§in &quot;Sum&quot; metodu Ã¼zerinden unit test yazabileceÄŸimiz gibi &quot;Validate&quot; metodu iÃ§in ayrÄ± bir unit test de yazabiliriz. Ben daha anlaÅŸÄ±lÄ±r olmasÄ± adÄ±na ayrÄ± metod yazmayÄ± tercih ettim.123456[TestCase(-1, -1)]public void Validate_Only_Positive_Integers_Test(int x, int y){ var exception = Assert.Throws(Is.TypeOf&lt;ArgumentException&gt;(), () =&gt; _testClass.Validate(x, y)); Assert.AreEqual(\"Only positive integers can be used.\", exception.Message);} Validate metodunu incelediÄŸimizde x veya y deÄŸiÅŸkenlerinin negatif gelmesi durumunda exception fÄ±rlattÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼rÃ¼z. Unit Testâ€™imizde de ArgumentException gelmesini ve mesajÄ±n da beklenilen iÃ§eriÄŸe sahip olmasÄ±nÄ± kontrol etmiÅŸ olduk. EÄŸer mesajÄ±n deÄŸerini kontrol etmezsek yeni bir mutantÄ±n oluÅŸmasÄ±na neden oluruz. Tekrar dotnet-stryker komutu ile rapor aldÄ±ÄŸÄ±mÄ±zda durum aÅŸaÄŸÄ±daki gibi olacaktÄ±r: GÃ¶rdÃ¼ÄŸÃ¼nÃ¼z Ã¼zere artÄ±k kapsanmayan kodumuz kalmadÄ± ancak mutantÄ± hala Ã¶ldÃ¼remedik. 2 Hayatta kalan mutantÄ± Ã¶ldÃ¼relim: YukarÄ±da ekran gÃ¶rÃ¼ntÃ¼sÃ¼nde gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z 1 numaralÄ± kÄ±rmÄ±zÄ± kutu simgesine tÄ±kladÄ±ÄŸÄ±mÄ±zda aÅŸaÄŸÄ±daki gibi gÃ¶zÃ¼kecektir. Burada oluÅŸturulan mutant ile mantÄ±ksal operatÃ¶r deÄŸiÅŸtirilmiÅŸ ve bu deÄŸiÅŸikliÄŸe raÄŸmen unit testimiz hiÃ§bir sorun Ã§Ä±karmadan Ã§alÄ±ÅŸmÄ±ÅŸ. Bu da bizim istediÄŸimiz bir durum deÄŸil. â€œValidateâ€ metodu iÃ§in yazmÄ±ÅŸ olduÄŸumuz Unit Testâ€™imizin TestCaseâ€™inde x ve y deÄŸiÅŸkenlerine -1 gÃ¶ndermiÅŸtik. Ancak mantÄ±ksal operatÃ¶r deÄŸiÅŸtiÄŸinde x ve y deÄŸiÅŸkenlerine gÃ¶ndermiÅŸ olduÄŸumuz -1 deÄŸeri oluÅŸan mutantÄ±n hayatta kalmasÄ±na neden olmaktadÄ±r. Test Caseâ€™ler arasÄ±na x ve y deÄŸiÅŸkenlerine sÄ±rasÄ±yla (-1,-1) - (-1,1) ve (1,-1) deÄŸerlerini gÃ¶nderdiÄŸimizde, mantÄ±ksal operatÃ¶r deÄŸiÅŸikliÄŸinden ortaya Ã§Ä±kan mutantÄ±n Ã¶lmesini saÄŸlayacaktÄ±r. 12345678[TestCase(-1, -1)][TestCase(1, -1)][TestCase(-1, 1)]public void Validate_Only_Positive_Integers_Test(int x, int y){ var exception = Assert.Throws(Is.TypeOf&lt;ArgumentException&gt;(), () =&gt; _testClass.Validate(x, y)); Assert.AreEqual(\"Only positive integers can be used.\", exception.Message);} Unit Testâ€™mizin son hali yukarÄ±daki gibi olacaktÄ±r. Bu deÄŸiÅŸiklikler sayesinde kod ileride parÃ§acÄ±ÄŸÄ± Ã¼zerinde yapÄ±lacak deÄŸiÅŸikliklerin Unit Testâ€™lerimizi etkileme ihtimalini artÄ±rmÄ±ÅŸ oluyoruz. Yeniden dotnet-stryker komutunu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mda artÄ±k tÃ¼m mutantlarÄ±n Ã¶ldÃ¼rÃ¼ldÃ¼ÄŸÃ¼nÃ¼ gÃ¶rebiliriz. Åimdi de son dokunuÅŸlarÄ± yapalÄ±m artÄ±k :) Azure Pipelines Ã¼zerinde, Stryker Mutator ile almÄ±ÅŸ olduÄŸumuz raporu CI sÃ¼recinde gÃ¶rmemizi saÄŸlayalÄ±m. Azure Pipelines EntegrasyonuBurada pipeline sÃ¼recinin halihazÄ±rda olduÄŸunu varsayarak anlatmaya Ã§alÄ±ÅŸacaÄŸÄ±m. Stryker Mutatorâ€™dan rapor alabilmek iÃ§in aÅŸaÄŸÄ±daki gibi 3 agent job tanÄ±mÄ±nÄ±n olmasÄ± gerekiyor. Ä°lki Stryker Mutator kurulumunu, ikincisi Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± ve Ã¼Ã§Ã¼ncÃ¼sÃ¼ de oluÅŸturulan raporun publish edilmesi. Bu Ã¼Ã§ adÄ±mÄ±n YAML iÃ§erikleri ÅŸu ÅŸekilde olmalÄ±dÄ±r: 1. Install dotnet-stryker 1234567steps:- task: DotNetCoreCLI@2 displayName: 'Install dotnet-stryker' inputs: command: custom custom: tool arguments: 'install dotnet-stryker --tool-path $(Agent.BuildDirectory)/tools' 2. Run dotnet-stryker 1234steps:- powershell: '$(Agent.BuildDirectory)/tools/dotnet-stryker' workingDirectory: StrykerMutatorSample.Calc.Test displayName: 'Run dotnet-stryker' 3. Publish Mutation Test Report Bu adÄ±mda Ã¶nemli olan, Mutation Report Publisher eklentisinin yÃ¼klenmesi. 123steps:- task: stryker-mutator.mutation-report-publisher.44d9cfb7-7efd-48e2-b2ae-4750950271be.PublishMutationReport@0 displayName: 'Publish Mutation Test Report' Azure Pipelines kÄ±smÄ±nda yapacaklarÄ±mÄ±z sadece bu kadar. Pipelineâ€™Ä±mÄ±zÄ± Run ettiÄŸimizde aÅŸaÄŸÄ±daki gÃ¶rseldeki gibi Mutation Report sekmesi gelecektir. Bu sekmenin detayÄ±nda rapor sonucunu gÃ¶rebiliriz. FaydalÄ± olmasÄ± dileÄŸiyle, baÅŸka yazÄ±larda gÃ¶rÃ¼ÅŸmek Ã¼zere :)","link":"/stryker-mutator-ile-mutation-testing-ve-azure-pipelines-entegrasyonu/"},{"title":"WebAssembly - Bize HÄ±zÄ±n AnlamÄ±nÄ± GÃ¶ster","text":"WebAssembly, kÄ±saca WASM ile web tarayÄ±cÄ±larda C,C++ ve Rust gibi yÃ¼ksek seviyeli diller ile yazÄ±lÄ±mÄ±ÅŸ programlarÄ± derleyebilir, Ã§alÄ±ÅŸtÄ±rabilir ve taÅŸÄ±yabiliriz. Javascriptâ€™in performans olarak yetersiz kaldÄ±ÄŸÄ± noktalarda WASM ile 20 kat daha performanslÄ± iÅŸler yapabiliriz. Run Shadowfax WebAssembly, show us the meaning of haste. Gandalf WebAssemblyWebAssembly, kÄ±saca WASM ile web tarayÄ±cÄ±larda C,C++ ve Rust gibi yÃ¼ksek seviyeli diller ile yazÄ±lÄ±mÄ±ÅŸ programlarÄ± derleyebilir, Ã§alÄ±ÅŸtÄ±rabilir ve taÅŸÄ±yabiliriz. Javascriptâ€™in performans olarak yetersiz kaldÄ±ÄŸÄ± noktalarda WASM ile 20 kat daha performanslÄ± iÅŸler yapabiliriz. WASM, JavaScriptâ€™e eÅŸlik eden bir araÃ§ olarak dÃ¼ÅŸÃ¼nÃ¼lebilir. Javascriptâ€™ten tamamen vazgeÃ§me durumu yok. JavaScriptâ€™in esnek olduÄŸu, dinamik olarak yazÄ±labildiÄŸi ve okunabilir kaynak koduyla sunulduÄŸu durumlarda, WASM yÃ¼ksek hÄ±zlÄ±, gÃ¼Ã§lÃ¼ bir ÅŸekilde yazÄ±lmÄ±ÅŸtÄ±r ve kompakt bir binary format aracÄ±lÄ±ÄŸÄ±yla sunulmaktadÄ±r. WASMâ€™Ä±n sunmuÅŸ olduÄŸu native performansÄ± kadar iyi olmasa da, modern JavaScript motorlarÄ± da oldukÃ§a hÄ±zlÄ±dÄ±r. BÃ¼yÃ¼k miktarda veri sÄ±kÄ±ÅŸtÄ±rmasÄ± gerektirmeyen Ã§oÄŸu temel web uygulamasÄ± ve basit komut dosyalarÄ± iÃ§in hala kabul edilebilir bir performans sergileyebilmektedirler. Temel komutlarÄ± barÄ±ndÄ±ran basit ÅŸeyler iÃ§in WASM kullanmaya gerek yoktur. Ã–rneÄŸin, bir kullanÄ±cÄ± bir butona tÄ±kladÄ±ÄŸÄ±nda bir uyarÄ±nÄ±n tetiklenmesi Javascript tarafÄ±ndan kolaylÄ±kla yapÄ±labilir, saniyede bir milyon kez Ã§alÄ±ÅŸtÄ±rÄ±lacak kadar performanslÄ± olmasÄ± gerekmez ve kesinlikle C, C++ ya da Rust ile yazÄ±lmasÄ±na gerek yoktur. Ancak, bir masaÃ¼stÃ¼ uygulamasÄ±nÄ± bir web tarayÄ±cÄ±sÄ±nda Ã§alÄ±ÅŸtÄ±rÄ±lacak ÅŸekilde geliÅŸtirmek istediÄŸinizde, WASM tercih edilen format olacaktÄ±r. Yine de, JavaScript hala WASM yÃ¶ntemlerini Ã§aÄŸÄ±rmak iÃ§in gereklidir.AÅŸaÄŸÄ±daki gÃ¶rselde, face detection uygulamasÄ±nÄ±n WASM ve Javascript kÄ±yaslamasÄ± yapÄ±lmaktadÄ±r. FPS deÄŸerlerine bakÄ±ldÄ±ÄŸÄ±nda WASM Ã§ok daha performanslÄ± bir ÅŸekilde gÃ¶rÃ¼ntÃ¼ iÅŸlemesi gerÃ§ekleÅŸtirebilmektedir. Yine bahsetmek gerekirse; masaÃ¼stÃ¼ uygulamalarÄ±n web uygulamalarÄ±na gÃ¶re daha performanslÄ± Ã§alÄ±ÅŸtÄ±ÄŸÄ± bilinir. KarmaÅŸÄ±k ve yÃ¼ksek CPU gerektiren iÅŸlemleri barÄ±ndÄ±ran programlar genellikle masaÃ¼stÃ¼ uygulamalarÄ±dÄ±r. MasaÃ¼stÃ¼ uygulamalarÄ±nÄ± native olarak sÄ±nÄ±flandÄ±rÄ±rsak, WASM ile native performansa yakÄ±n ve web ortamÄ±nda Ã§alÄ±ÅŸan uygulamalar geliÅŸtirmek amaÃ§lanmÄ±ÅŸtÄ±r. GÃ¼nÃ¼mÃ¼zde popÃ¼ler bir Ã§ok web tarayÄ±cÄ±sÄ± WASMâ€™Ä± desteklemektedir. WASMâ€™dan Ã¶nce Googleâ€™Ä±n Native Clientâ€˜Ä± ve Mozillaâ€™nÄ±n da asm.js isimli teknolojileri ile native performansÄ± saÄŸlanmaktaydÄ±. Tabii doÄŸal olarak Googleâ€™Ä±n odak noktasÄ± Chrome ve Mozillaâ€™nÄ±nki ise Firefoxâ€™tu. Ã–ncelikli olarak kendi tarayÄ±cÄ±larÄ±nda Ã§alÄ±ÅŸacak bir sistem geliÅŸtirmiÅŸlerdi. Bunlara kÄ±saca deÄŸinmek gerekirse: Google, native kodu bir web tarayÄ±cÄ±sÄ±nda gÃ¼venli bir ÅŸekilde Ã§alÄ±ÅŸtÄ±rmak amacÄ±yla Native Clientâ€™Ä± (NaCl) geliÅŸtirmiÅŸtir. YÃ¼rÃ¼tÃ¼lebilir kod sanal bir alanda Ã§alÄ±ÅŸÄ±r ve native kod yÃ¼rÃ¼tmenin performans avantajlarÄ±nÄ± sunabilmektedir. NaCl, belirli bir mimariye baÄŸlÄ±yken, Portable Native Client (PNaCl), herhangi bir platformda Ã§alÄ±ÅŸmak Ã¼zere geliÅŸtirilmiÅŸ, NaClâ€™nin mimariden baÄŸÄ±msÄ±z bir versiyonudur. Mozilla ise, asm.jsâ€™i 2013â€™te piyasaya sÃ¼rdÃ¼ ve geliÅŸtiricilere C veya C++ kaynak kodlarÄ±nÄ± JavaScriptâ€™e Ã§evirmeleri iÃ§in bir yol saÄŸlamÄ±ÅŸtÄ±r. asm.js, derleyiciler iÃ§in dÃ¼ÅŸÃ¼k seviyeli, verimli bir hedef dil olarak kullanÄ±labilen katÄ± bir JavaScript alt kÃ¼mesi olarak tanÄ±mlanmaktadÄ±r. 2015 yÄ±lÄ±nda, web standartlarÄ± geliÅŸtirmek iÃ§in kurulmuÅŸ uluslararasÄ± bir topluluk olan World Wide Web Consortiumâ€™un (W3C) organize etmiÅŸ olduÄŸu ve Google, Mozilla, Apple ve Microsoftâ€™un katÄ±lÄ±mlarÄ±yla gerÃ§ekleÅŸtirilen WebAssembly Community Group buluÅŸmasÄ±yla WASMâ€™Ä±n temelleri atÄ±lmÄ±ÅŸ oldu. ArtÄ±k navite performansÄ± popÃ¼ler tarayÄ±cÄ±larÄ±n hepsinde desteklenir hale gelmiÅŸtir. Web tarayÄ±cÄ±larÄ±nda WASM desteÄŸinin uygulanmasÄ± asm.jsâ€™e ve PNaClâ€™nin daÄŸÄ±tÄ±lmÄ±ÅŸ yÃ¼rÃ¼tÃ¼lebilir dosya konseptine dayanmaktadÄ±r. AÅŸaÄŸÄ±daki gÃ¶rselde yine aynÄ± face detection uygulamasÄ±nÄ±n WASM, asm.js ve Javascript kÄ±yaslamasÄ± yapÄ±lmaktadÄ±r. FPS deÄŸerlerine bakÄ±ldÄ±ÄŸÄ±nda WASM Ã§ok daha performanslÄ± bir ÅŸekilde gÃ¶rÃ¼ntÃ¼ iÅŸlemesi gerÃ§ekleÅŸtirebilmektedir. WebAssembly NasÄ±l Ã‡alÄ±ÅŸÄ±r?WASM, yaratÄ±cÄ±larÄ±nÄ±n deyimiyle bir â€œderleme hedefiâ€ dir. DoÄŸrudan WebAssembly yazmamÄ±za gerek yoktur. SeÃ§tiÄŸimiz yÃ¼ksek seviyeli dilde yazarÄ±z ve daha sonra WASM bayt kodu olarak derlenir. Bayt kod daha sonra client Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r ve burada yerel makine koduna Ã§evrilir ve yÃ¼ksek hÄ±zda yÃ¼rÃ¼tÃ¼lÃ¼r. WASM herhangi bir Ã¶zel makine iÃ§in tasarlanmadÄ±ÄŸÄ± iÃ§in tam anlamÄ±yla bir assembly dili deÄŸildir. TarayÄ±cÄ±lar iÃ§indir ve tarayÄ±cÄ±da yÃ¼rÃ¼tÃ¼lecek kodu teslim ederken, kodunuzun ne tÃ¼r makinelerde Ã§alÄ±ÅŸacaÄŸÄ±nÄ± bilemeyiz. TarayÄ±cÄ± WASM kodunu indirdiÄŸinde, kodu hÄ±zla herhangi bir makinenin anlayabileceÄŸi bir dile dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. C, C++ veya Rust ile yazdÄ±ÄŸÄ±mÄ±z kodlar WASM metin formatÄ± olan .wat dosyalarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r. TarayÄ±cÄ±ya ise bu dosyanÄ±n binary hali olan .wasm dosyasÄ± sunulmaktadÄ±r. Ã–rneÄŸin, aÅŸaÄŸÄ±daki kod parÃ§asÄ±nda C++ ile faktÃ¶riyel hesaplamasÄ± yapan recursive bir fonksiyonu .wat ve .wasm formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ halini gÃ¶rebilirsiniz. Binary olan .wasm, text olan ise .wat dosyasÄ±na aittir. .wasm ve .wat dosyalarÄ±nÄ± herhangi bir WasmExplorer aracÄ±lÄ±ÄŸÄ±yla elde edebilirsiniz. AyrÄ±ca, Emscripten kullanarak da derleme yapabilirsiniz. Emscripten, hÄ±za, boyuta ve Web platformuna Ã¶zel odaklanan, LLVM kullanan, WASM iÃ§in eksiksiz bir derleyici toolchainâ€™dir. Emscripten kurulumunu yaptÄ±ktan sonra aÅŸaÄŸÄ±daki basit CLI komutu ile C ile yazdÄ±ÄŸÄ±nÄ±z kodu WASM dosyasÄ±na dÃ¶nÃ¼ÅŸtÃ¼rerek tarayÄ±cÄ± Ã¼zerinden kullanÄ±labilir hale getirebilirsiniz. emcc hello.c -s WASM=1 -o hello.html GerÃ§ek DÃ¼nyadan GÃ¼zel Bir Ã–rnekBir Ã§oÄŸumuzun bildiÄŸi sanal seyahat imkanÄ± sunan Google Earth, Haziran 2019â€™daki Medium yazÄ±sÄ±na (Preview Google Earth on web across browsers) gÃ¶re WASM ile beta sÃ¼rÃ¼mÃ¼nÃ¼ yayÄ±nladÄ±. Google Earth, Ã¶nceki versiyonunda NaCI kullanÄ±ldÄ±ÄŸÄ± iÃ§in, sadece Chrome tarayÄ±cÄ±larda kullanÄ±labiliyordu, artÄ±k sadece Chromeâ€™da deÄŸil Opera, Edge ve Firefox tarayÄ±cÄ±larda da kullanÄ±labilir hale getirildi. Safari tarayÄ±cÄ±sÄ±nda da desteklenmesi iÃ§in Ã§alÄ±ÅŸmalar hala devam etmektedir. AÅŸaÄŸÄ±daki gÃ¶rselde gÃ¶receÄŸiniz Ã¼zere Google Earth Web uygulamasÄ±nÄ± tarayÄ±cÄ±mÄ±zda aÃ§tÄ±ÄŸÄ±mÄ±zda yÃ¼klenen dosyalar arasÄ±nda .wasm dosyasÄ±nÄ± da gÃ¶rebilirsiniz. Son BirkaÃ§ SÃ¶zWebAssembly ile C, C++ ve Rust dillerinin dÄ±ÅŸÄ±nda diÄŸer popÃ¼ler dillerle de geliÅŸtirme yapmak mÃ¼mkÃ¼n. Ã–rneÄŸin; C# ile Blazor F# ile Bolero Haxe ile WebIDL Java ile TeaVM ya da Bytecoder Kotlin ile TeaVM TypeScript ile AssemblyScript WebAssembly konusunda Ã§ok fazla detaya girmeden, olabildiÄŸince sade anlatmaya Ã§alÄ±ÅŸtÄ±m. Detaylara girdikÃ§e iÅŸin iÃ§erisinden Ã§Ä±kmak Ã§ok mÃ¼mkÃ¼n olmuyor. :) UmarÄ±m faydalÄ± olmuÅŸtur. Kaynaklar https://www.infoworld.com/article/3291780/what-is-webassembly-the-next-generation-web-platform-explained.html https://webassembly.org/docs/faq/ https://medium.com/google-earth/google-earth-comes-to-more-browsers-thanks-to-webassembly-1877d95810d6 https://hacks.mozilla.org/2017/09/bootcamps-webassembly-and-computer-vision/ https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71/","link":"/webassembly-bize-hizin-anlamini-goster/"},{"title":"Yapay Zekaâ€™ya GÃ¼venebilir miyim? â€” Explainable AI","text":"AsÄ±l konumuza giriÅŸ yapmadan Ã¶nce kÄ±saca Yapay ZekanÄ±n ne demek olduÄŸunu hatÄ±rlayalÄ±m; Yapay Zeka, bir Ã§Ä±ktÄ± elde etmek iÃ§in insan zekasÄ± gibi davranan ve elde ettiÄŸi bilgilere gÃ¶re yinelemeli olarak kendisini sÃ¼rekli geliÅŸtirebilen sistem veya makinedir. Tekrarlanan Ã¶ÄŸrenme ve verisel keÅŸif sÃ¼reci ile birÃ§ok gizli katmana sahip sinir aÄŸlarÄ±nÄ± kullanarak daha fazla ve daha derin verileri analiz eder. Bu noktada, Yapay ZekanÄ±n en Ã¶nemli Ã¶zelliÄŸi baÄŸÄ±msÄ±z Ã¶ÄŸrenme yeteneÄŸidir diyebiliriz. Yapay Zeka, baÄŸÄ±msÄ±z Ã¶ÄŸrenme yeteneÄŸi ile algoritmalar oluÅŸturarak karar verir. Karar verme sÃ¼recinde faydalandÄ±ÄŸÄ± algoritmanÄ±n tam olarak ne olduÄŸunu ve aldÄ±ÄŸÄ± kararÄ±n gerekÃ§elerini tam olarak bilemeyiz. Bu da Yapay ZekanÄ±n arkasÄ±ndaki kara kutudur. Bu kara kutunun iÃ§erisinde neler olup bittiÄŸini bilemiyoruz. Ã–rneÄŸin, aÅŸaÄŸÄ±daki gÃ¶rselde de gÃ¶receÄŸiniz Ã¼zere, daha Ã¶nceden eÄŸitilmiÅŸ bir Yapay Zekaya girdi olarak verilen bir fotoÄŸrafÄ±n analiz sÃ¼reci yer almaktadÄ±r. Kara kutu olarak belirtilen yer, Yapay ZekanÄ±n Ã¶ÄŸrenme sÃ¼recinde kendisine Ã§Ä±kardÄ±ÄŸÄ± algoritma yer almaktadÄ±r. Buradaki algoritmanÄ±n nasÄ±l iÅŸlediÄŸini Yapay ZekayÄ± geliÅŸtiren mÃ¼hendis bile tam anlamÄ±yla bilmemektedir. Nuance yÃ¶neticisi Nils Lenke, Yapay ZekanÄ±n kara kutusu hakkÄ±nda ÅŸÃ¶yle diyor; Ä°Ã§erde ne olduÄŸu her zaman aÃ§Ä±k deÄŸildir, siz Yapay ZekanÄ±n kendi kendini dÃ¼zenlemesini saÄŸlarsÄ±nÄ±z. Ancak bu durum, kendi geliÅŸtirirken size bunu nasÄ±l yaptÄ±ÄŸÄ±nÄ± sÃ¶yleyeceÄŸi demek deÄŸildir. 1950â€™lerden gÃ¼nÃ¼mÃ¼ze kadar Yapay Zeka alanÄ±nda birÃ§ok Ã§alÄ±ÅŸma yapÄ±lmÄ±ÅŸtÄ±r. Bu doÄŸrultuda Yapay ZekanÄ±n kullanÄ±m alanÄ± her geÃ§en gÃ¼n daha da geniÅŸledi ve gÃ¼venlik, saÄŸlÄ±k, otomotiv, otomasyon, bilgi teknolojileri ve finans gibi birÃ§ok sektÃ¶rde kullanÄ±lmaya baÅŸlandÄ±. GeliÅŸen teknoloji ve deÄŸiÅŸen ihtiyaÃ§lar nedeniyle, her geÃ§en gÃ¼n Yapay Zekadan daha fazla ÅŸey beklenilmektedir. Bu ihtiyaÃ§lardan bir tanesi de, Yapay ZekanÄ±n almÄ±ÅŸ olduÄŸu karara duyulan gÃ¼vendir. Problemi Ã§Ã¶zmesinin yanÄ± sÄ±ra Yapay ZekanÄ±n arkasÄ±nda nelerin olup bittiÄŸini aÃ§Ä±klanmasÄ± da beklenmektedir. Bu noktada iÅŸin iÃ§erisine, Yapay ZekanÄ±n kara kutusu iÃ§erisinde nelerin olup bittiÄŸini, AÃ§Ä±klanabilir Yapay Zeka (Explainable AI â€” XAI) yaklaÅŸÄ±mÄ± ile ifade etme sÃ¼reci devreye girmektedir. AÅŸaÄŸÄ±daki gÃ¶rsellerde AÃ§Ä±klanabilir Yapay Zeka Ã¶ncesi ve sonrasÄ± basit olarak ifade edilmiÅŸtir. â€œÃ–nceâ€ olarak isimlendirilen gÃ¶rsele Kara Kutu Yapay Zeka (Blackbox AI), â€œSonraâ€ olarak isimlendirilen gÃ¶rsele ise AÃ§Ä±klanabilir Yapay Zeka (Explainable AI) diyebiliriz. AÃ§Ä±klanabilir Yapay Zeka sistemleri, ek bilgi saÄŸlayan veya makine Ã¶ÄŸrenimi sisteminin iÃ§ iÅŸleyiÅŸine Ã¶zgÃ¼ verileri sunan bir arayÃ¼z saÄŸlar. Bu sayede insanlarÄ±n bu karara Yapay Zeka tarafÄ±ndan nasÄ±l ve neden ulaÅŸÄ±ldÄ±ÄŸÄ±nÄ± anlamasÄ±na yardÄ±mcÄ± olur. SAS baÅŸkan yardÄ±mcÄ±sÄ± Keith Collins, AÃ§Ä±klanabilir Yapay ZekayÄ± ÅŸÃ¶yle ifade etmektedir: AÃ§Ä±klanabilir Yapay Zeka terimi, insanlarÄ±n yapay zeka teknolojisinin bir karar vermek iÃ§in izlediÄŸi yolu dinamik olarak oluÅŸturulmuÅŸ grafikler veya metinsel aÃ§Ä±klamalar aracÄ±lÄ±ÄŸÄ±yla kolayca anlayabilmesini ifade eder.AÃ§Ä±klanabilir Yapay Zeka yaklaÅŸÄ±mÄ± ile yorumlanabilirlik, ÅŸeffaflÄ±k ve aÃ§Ä±klanabilirlik saÄŸlanmaya Ã§alÄ±ÅŸÄ±lmÄ±ÅŸtÄ±r. Ancak bilindiÄŸi Ã¼zere Yapay Zeka yapay sinir aÄŸlarÄ±ndan oluÅŸmaktadÄ±r. KÃ¼Ã§Ã¼k bir sinir aÄŸÄ±nÄ± aÃ§Ä±klamak nispeten daha kolayken, yÃ¼zlerce belki de binlerce katmana sahip bir derin sinir aÄŸÄ±nÄ± aÃ§Ä±klamak oldukÃ§a zor olmaktadÄ±r. Bu noktada Yapay Zekadaki aÃ§Ä±klanabilirlik karmaÅŸÄ±klÄ±ÄŸa baÄŸlÄ±dÄ±r diyebiliriz. Genel olarak, daha karmaÅŸÄ±k Yapay Zeka sistemleri daha doÄŸrudur ancak daha az aÃ§Ä±klanabilirken, daha az karmaÅŸÄ±k modeller ise daha az doÄŸrudur ancak daha aÃ§Ä±klanabilirdir. KÄ±saca, aÃ§Ä±klanabilirlik ve karmaÅŸÄ±klÄ±k arasÄ±nda ters orantÄ± vardÄ±r. AÃ§Ä±klanabilir Yapay Zeka sistemlerinden bunun dengeli olmasÄ± faydalÄ± olacaktÄ±r. AÃ§Ä±klanabilir Yapay ZekanÄ±n Mevcut ve Potansiyel KullanÄ±m AlanlarÄ±AÃ§Ä±klanabilir Yapay Zekaya Yapay ZekanÄ±n kullanÄ±ldÄ±ÄŸÄ± bir Ã§ok alanda ihtiyaÃ§ duyulabilir. Bu ihtiyacÄ±n ortaya Ã§Ä±kmasÄ±ndaki asÄ±l neden Yapay Zekaya duyulan gÃ¼vendir. Yapay ZekanÄ±n, karar verme aÅŸamasÄ±nda tÃ¼m kontrolÃ¼n bir algoritmalarda olmasÄ± bazÄ± problemlere neden olabilmektedir. Ã–rneÄŸin; otonom bir araÃ§ bir kazaya neden olursa bunun sorumlusu kim olacaktÄ±r? YolcularÄ±, Yapay ZekanÄ±n almÄ±ÅŸ olduÄŸu karardan sorumlu tutamayÄ±z. Ancak otonom araÃ§ almÄ±ÅŸ olduÄŸu kararlarÄ± aÃ§Ä±klayarak durumu netleÅŸtirebilir. Tabi bÃ¶yle karmaÅŸÄ±k bir durumu aÃ§Ä±klamak Ã¼reticiler iÃ§in bir hayli zor olacaktÄ±r. Benzer bir durum, bir hastanÄ±n iyileÅŸme sÃ¼recinin kontrolÃ¼ne otomatik olarak sahip olan Yapay Zeka uygulamalarÄ± iÃ§in de sÃ¶ylenebilir. KÄ±sacasÄ±, AÃ§Ä±klanabilir Yapay Zeka yaklaÅŸÄ±mÄ± Yapay ZekanÄ±n olduÄŸu her yerde olabilir. Yapay Zeka, pazarlamada, otomotivde, sigortacÄ±lÄ±k ve finansta, saÄŸlÄ±kta, siber gÃ¼venlikte, askeri savunmada ve aklÄ±mÄ±za gelebilecek birÃ§ok alanda kullanÄ±lmaktadÄ±r. BunlarÄ±n hepsinin temelinde Yapay Zeka ve dolayÄ±sÄ±yla yapay sinir aÄŸlarÄ± vardÄ±r. Kara kutu olarak isimlendirdiÄŸimiz Yapay ZekanÄ±n bilinmezinin aÃ§Ä±klanmasÄ± gerektiÄŸi tÃ¼m durumlarda AÃ§Ä±klanabilir Yapay Zeka kullanÄ±labilir. Tabi burada Yapay Zeka sisteminin kullanÄ±ldÄ±ÄŸÄ± sÃ¼recin kritiklik derecesine baÄŸlÄ± olarak deÄŸiÅŸebilmektedir. Yapay ZekanÄ±n en Ã¶nemli Ã¶zelliÄŸi baÄŸÄ±msÄ±z Ã¶ÄŸrenme yeteneÄŸidir. BaÄŸÄ±msÄ±z Ã¶ÄŸrenme yeteneÄŸi sayesinde girdi olarak verilen verileri analiz ederek Ã§Ä±karÄ±mlarda bulunur. Daha Ã¶ncede bahsettiÄŸimiz Ã¼zere kara kutuda neler olup bittiÄŸini kimse bilemez. Bu da Yapay Zekaya gÃ¼ven sorununu ortaya Ã§Ä±karmaktadÄ±r. Ã–rneÄŸin, Amazon tarafÄ±ndan iÅŸ baÅŸvurularÄ±nÄ± incelemek iÃ§in geliÅŸtirilen bir Yapay Zeka sistemi, kadÄ±n adaylarÄ± erkek adaylara kÄ±yasla sÃ¼rekli olarak geri plana atmÄ±ÅŸtÄ±r. Sistem, Ã¶zellikle erkek adaylar tarafÄ±ndan aÅŸÄ±rÄ± doldurulan tarihsel veriler Ã¼zerine eÄŸitilmiÅŸtir. SonuÃ§ olarak, sistem kadÄ±nlara karÅŸÄ± Ã¶nyargÄ±lÄ± kararlar almÄ±ÅŸtÄ±r. Ä°ÅŸin ilginÃ§ tarafÄ± ise, cinsiyet belirleyici Ã¶zellikler kaldÄ±rÄ±ldÄ±ktan sonra bile (Ã¶rneÄŸin ad ve cinsiyet) sistemin hala aynÄ± sonucu vermesiydi. Sistem, erkek adaylarÄ±n kadÄ±n adaylarÄ±n kullanmadÄ±ÄŸÄ± belirli kelimeleri veya cÃ¼mleleri kullanma eÄŸiliminde olduklarÄ±nÄ± tespit etmiÅŸtir. Erkek adaylar baÅŸarÄ±larÄ±nÄ± anlatmak iÃ§in daha Ã¶zgÃ¼venli ve otoriter bir dil kullanÄ±rken, kadÄ±n adaylar yetenekleri konusunda daha temkinli bir dil kullanmÄ±ÅŸlardÄ±. Benzer ÅŸekilde, 2018 UC Berkley Ã§alÄ±ÅŸmasÄ±, kredi baÅŸvurularÄ±nÄ± onaylamaya yÃ¶nelik geleneksel ve makine tabanlÄ± sistemlerin, Latin ve AfroamerikalÄ± borÃ§lulara eÅŸdeÄŸer bir Kafkas borÃ§lusundan 6â€“9 baz puan daha yÃ¼ksek faiz oranlarÄ± uyguladÄ±ÄŸÄ± sonucuna varmÄ±ÅŸtÄ±r. Bu sadece ahlaki aÃ§Ä±dan yanlÄ±ÅŸ deÄŸildir, gÃ¶rÃ¼nÃ¼ÅŸte ten rengiyle baÄŸlantÄ±lÄ± tespitler yapmakla kalmÄ±yor. Bu durumda, ahlaki aÃ§Ä±dan adil olma, ancak aynÄ± zamanda yasal olarak uyumlu olma ihtiyacÄ± vardÄ±r. AÃ§Ä±klanabilir Yapay Zeka AlanÄ±nda YapÄ±lan Ã‡alÄ±ÅŸmalarÃ‡ok uzun zamandÄ±r bilim ve mÃ¼hendislikte kullanÄ±lan klasik kara kutu analizi yaklaÅŸÄ±mlarÄ±ndan Derin Sinir AÄŸlarI iÃ§in tasarlanmÄ±ÅŸ en son yÃ¶ntemlere kadar, aÃ§Ä±klama Ã¼retmek iÃ§in bir dizi yÃ¶ntem mevcuttur. Bu alanda yapÄ±lan en Ã¶nemli Ã§alÄ±ÅŸmalar ÅŸunlardÄ±r; LIMELIME (Local Interpretable Model-Agnostic Explanations), modelden baÄŸÄ±msÄ±zdÄ±r, yani herhangi bir makine Ã¶ÄŸrenimi modeline uygulanabilir. Teknik, veri Ã¶rneklerinin giriÅŸini bozarak ve tahminlerin nasÄ±l deÄŸiÅŸtiÄŸini anlayarak modeli anlamaya Ã§alÄ±ÅŸÄ±r. Herhangi bir sÄ±nÄ±flandÄ±rÄ±cÄ± veya regresÃ¶rÃ¼n tahminlerini yerel olarak yorumlanabilir bir modelle yaklaÅŸtÄ±rarak sadÄ±k bir ÅŸekilde aÃ§Ä±klayabilen bir algoritmadÄ±r. Ã–zellik deÄŸerlerini deÄŸiÅŸtirerek tek bir veri Ã¶rneÄŸini deÄŸiÅŸtirir ve sonuÃ§ta Ã§Ä±ktÄ± Ã¼zerindeki etkiyi gÃ¶zlemler. Her veri Ã¶rneÄŸinden gelen tahminleri aÃ§Ä±klamak iÃ§in bir â€œaÃ§Ä±klayÄ±cÄ±â€ rolÃ¼nÃ¼ yerine getirir. LIME Ã§Ä±ktÄ±sÄ±, her bir Ã¶zelliÄŸin tek bir Ã¶rneklem iÃ§in bir tahmine olan katkÄ±sÄ±nÄ± temsil eden bir dizi aÃ§Ä±klama olup, bir yerel yorumlanabilirlik biÃ§imidir. LIME ile yorumlanabilir modeller, Ã¶rneÄŸin, iyi bir yerel yaklaÅŸÄ±m saÄŸlamak iÃ§in orijinal modelin kÃ¼Ã§Ã¼k dÃ¼zensizlikleri (bu dÃ¼zensizlikler; gÃ¼rÃ¼ltÃ¼ ekleme, sÃ¶zcÃ¼kleri Ã§Ä±karma, gÃ¶rÃ¼ntÃ¼nÃ¼n parÃ§alarÄ±nÄ± gizleme olabilir) Ã¼zerine eÄŸitilmiÅŸ doÄŸrusal regresyon veya karar aÄŸaÃ§larÄ± olabilir. SHAPSHAP, SHapley Additive Explanationsâ€™Ä±n kÄ±saltmasÄ±dÄ±r. Herhangi bir makine Ã¶ÄŸrenimi modelinin Ã§Ä±ktÄ±sÄ±nÄ± aÃ§Ä±klamak iÃ§in bir oyun teorisi yaklaÅŸÄ±mÄ±dÄ±r. Oyun teorisindeki klasik Shapley deÄŸerlerini ve bunlarla ilgili uzantÄ±larÄ± kullanarak optimum kredi tahsisini yerel aÃ§Ä±klamalarla birleÅŸtirir. Shapley deÄŸerleri, yaklaÅŸÄ±m iÃ§in bir aÄŸÄ±rlÄ±klandÄ±rma Ã§ekirdeÄŸi kullanan Kernel SHAP ve bunlarÄ± yaklaÅŸtÄ±rmak iÃ§in DeepLift kullanan DeepSHAP kullanÄ±larak yaklaÅŸÄ±k olarak hesaplanmaktadÄ±r. FairlearnMicrosoftâ€™un Fairlearn isimli projesi, veri bilimcilerinin ve geliÅŸtiricilerin yapay zeka sistemlerinin adilliÄŸini deÄŸerlendirmelerini ve geliÅŸtirmelerini saÄŸlayan popÃ¼ler bir AÃ§Ä±klanabilir Yapay Zeka araÃ§ setidir. AraÃ§ setinin iki bileÅŸeni vardÄ±r: etkileÅŸimli bir gÃ¶rselleÅŸtirme panosu ve adaletsizliÄŸi azaltma algoritmalarÄ±. Esas olarak adalet ve model performansÄ± arasÄ±ndaki dengeyi saÄŸlamaya yardÄ±mcÄ± olmak iÃ§in tasarlanmÄ±ÅŸtÄ±r. AÃ§Ä±k kaynak araÃ§ seti, bir AI modelinin Ã§eÅŸitli insan gruplarÄ± Ã¼zerindeki etkilerini deÄŸerlendirmek iÃ§in hem sÄ±nÄ±flandÄ±rma hem de regresyon gÃ¶revlerini iÃ§eren geniÅŸ bir adalet Ã¶lÃ§Ã¼tleri yelpazesini desteklemektedir. WhiteNoiseWhiteNoise, Harvard Ãœniversitesindeki araÅŸtÄ±rmacÄ±larla iÅŸbirliÄŸi iÃ§inde Microsoft tarafÄ±ndan geliÅŸtirilen, kÃ¼resel farklÄ± Ã¶zel sistemler oluÅŸturmak iÃ§in farklÄ± bileÅŸenler iÃ§eren farklÄ± bir gizlilik platformudur. Microsoft, Build 2020 konferansÄ± sÄ±rasÄ±nda daha aÃ§Ä±klanabilir yapay zeka sistemlerine yÃ¶nelme Ã§abasÄ±yla bu aracÄ± aÃ§Ä±k kaynaklÄ± olarak kullanmÄ±ÅŸtÄ±r. Core ve System gibi iki Ã¼st dÃ¼zey bileÅŸenden oluÅŸan aÃ§Ä±k kaynaklÄ± bir projedir. Core kÃ¼tÃ¼phane, farklÄ± ÅŸekilde Ã¶zel bir sistemi uygulamak iÃ§in gizlilik mekanizmalarÄ± iÃ§erir, System kÃ¼tÃ¼phanesi ise, tablo ÅŸeklinde ve iliÅŸkisel verilerle Ã§alÄ±ÅŸmak iÃ§in araÃ§lar ve hizmetler saÄŸlar. ERASERERASER (Rationales And Simple English Reasoning), Salesforce tarafÄ±ndan geliÅŸtirilen, rasyonelleÅŸtirilmiÅŸ doÄŸal dil iÅŸleme (NLP) modellerinin deÄŸerlendirilmesine yardÄ±mcÄ± olan AÃ§Ä±klanabilir Yapay Zeka Ã§alÄ±ÅŸmasÄ±dÄ±r. KÄ±yaslama, yedi farklÄ± NLP veri setinden ve tahminler iÃ§in destekleyici kanÄ±t olarak aÃ§Ä±klamalarÄ±n insan aÃ§Ä±klamalarÄ±nÄ± iÃ§eren gÃ¶revlerden oluÅŸur.ERASERâ€™a dahil edilen tÃ¼m veri kÃ¼meleri, farklÄ± sayÄ±da etiketle diÄŸerlerinin yanÄ± sÄ±ra duyarlÄ±lÄ±k analizi, doÄŸal dil Ã§Ä±karÄ±mÄ± ve soru cevaplama gÃ¶revlerini iÃ§eren sÄ±nÄ±flandÄ±rma gÃ¶revleridir ve bazÄ±larÄ±nÄ±n farklÄ± sÄ±nÄ±f etiketleri vardÄ±r. AyrÄ±ca, kÄ±yaslama, doÄŸru Ã§Ä±ktÄ±yÄ± tahmin etmek iÃ§in yeterli kanÄ±t saÄŸlayan gÃ¶revin kaynak belgesinden Ã§Ä±karÄ±lan metin parÃ§acÄ±klarÄ± olan â€œgerekÃ§elereâ€ odaklanÄ±r. COVID-NetSon zamanlarda, AI ÅŸirketi olan DarwinAI, AÃ§Ä±klanabilir Yapay Zeka platformlarÄ±nda COVID-Net ve COVIDNet-Sâ€™yi geliÅŸtirdi. 2020 Mart ayÄ±nda, COVID-Net, COVID-19 vakalarÄ±nÄ±n gÃ¶ÄŸÃ¼s rÃ¶ntgeni (CXR) gÃ¶rÃ¼ntÃ¼lerinden algÄ±lanmasÄ± iÃ§in Ã¶zel olarak tasarlanmÄ±ÅŸ derin bir evriÅŸimli sinir aÄŸÄ± tasarÄ±mÄ±dÄ±r. AraÅŸtÄ±rmacÄ±lar, modelin yanÄ± sÄ±ra, 13870 hasta vakasÄ±nda 13975 CXR gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ iÃ§eren, oluÅŸturulan aÃ§Ä±k eriÅŸimli bir karÅŸÄ±laÅŸtÄ±rma veri kÃ¼mesi olan aÃ§Ä±k kaynaklÄ± COVIDxâ€™i de kullandÄ±. 2020 EylÃ¼l ayÄ±nda DarwinAI, COVID-19â€™un hastalÄ±k ÅŸiddetini deÄŸerlendirmek iÃ§in AÃ§Ä±klanabilir Yapay Zeka platformlarÄ±nda tasarlanmÄ±ÅŸ bir derin Ã¶ÄŸrenme modelleri paketi olan COVIDNet-Sâ€™yi duyurdu. COVIDNet-S, gÃ¶ÄŸÃ¼s rÃ¶ntgeninin temel gÃ¶rsel gÃ¶stergelerini analiz ederek hastanÄ±n akciÄŸerlerindeki coÄŸrafi ve opasite boyutunu nicel olarak puanlayabilir. Sistem, 10000â€™den fazla gÃ¶ÄŸÃ¼s rÃ¶ntgeni kullanÄ±larak geliÅŸtirildi ve bunlarÄ±n yÃ¼zlercesi kapsamlÄ± akciÄŸer hastalÄ±ÄŸÄ± ÅŸiddet deÄŸerlendirmelerine sahip COVID-19 pozitif hastalardan oluÅŸuyor. Kaynaklar https://www.oracle.com/tr/artificial-intelligence/what-is-artificial-intelligence.html https://bilimfili.com/yapay-zekanin-kalbindeki-karanlik-sir https://www.sas.com/tr_tr/insights/analytics/yapay-zeka-nedir.html https://www.karel.com.tr/blog/yapay-zeka-karsilastigi-sorunlari-asabilecek-mi https://lawtomated.medium.com/explainable-ai-all-you-need-to-know-the-what-how-why-of-explainable-ai-dcf2287a9f6c https://www.sunsavunma.net/darpa-yapay-zeka-projesi/ https://analyticsindiamag.com/top-milestones-on-explainable-ai-in-2020/","link":"/yapay-zekaya-guvenebilir-miyim-explainable-ai/"},{"title":"Blockchain â€” Interoperability","text":"Blockchain Nedir?Basit bir ifadeyle; ÅŸifrelenmiÅŸ bir ÅŸekilde iÅŸlem takibi saÄŸlayan ve merkezi olmayan bÃ¼yÃ¼k bir veritabanÄ± olarak tanÄ±mlayabiliriz. Bu bÃ¼yÃ¼k veritabanÄ±nda veriler bloklar halinde tutulur. HiÃ§bir ÅŸekilde verilerin deÄŸiÅŸtirilmesi sÃ¶z konusu deÄŸildir. Sadece okuma ve yazma iÅŸlemleri yapÄ±lÄ±r. EÄŸer hatalÄ± bir iÅŸlem yapÄ±ldÄ±ysa, bu hatalÄ± iÅŸlem de bloklara eklenir. Ã‡eÅŸitli verilerin barÄ±ndÄ±rÄ±ldÄ±ÄŸÄ± bloklar bir araya geldiÄŸinde block zinciri meydana gelir. Ã–rneÄŸin, para transfer iÅŸlemlerinde her adÄ±m bir bloÄŸu karÅŸÄ±lÄ±k gelir. Bu adÄ±mlar takip edilerek paranÄ±n alÄ±cÄ±lar arasÄ±nda nasÄ±l bir yol izlediÄŸi gÃ¶rÃ¼lÃ¼r. Blockchain sayesinde, bir aracÄ±ya ihtiyaÃ§ duyulmayan ve gÃ¼venin maksimum edildiÄŸi bir ortam saÄŸlanmÄ±ÅŸ olur. Åekil.1 â€” Ã–rnek bir Blockchain TarihÃ§eBiraz iÅŸin tarihÃ§esinden bahsedelim; blockchain teknolojisi, 1980 yÄ±lÄ±nda Ralph Merkleâ€™in meÅŸhur makalesi ile baÅŸlayan Ã§Ã¶zÃ¼lmesi Ã§ok zor kripto para ve ÅŸifreli aÄŸlar ile baÅŸladÄ±. 1991 yÄ±lÄ±na gelindiÄŸinde ise W. Scoot Stornetta ve Stuart Haber isimli iki bilim adamÄ±nÄ±n dijital belgelerin zaman damgasÄ± ile karÄ±ÅŸtÄ±rÄ±lamaz ya da geriye dÃ¶nÃ¼k olarak deÄŸiÅŸtirilemez ÅŸekilde imzalanmasÄ± fikri konuya dahil oldu. Bu geliÅŸmelerin Ã¼zerine 1992 yÄ±lÄ±nda Ralph Merkleâ€™nin bahsetmiÅŸ olduÄŸu Merkle AÄŸacÄ± ya da Hash AÄŸacÄ± olarak isimlendirilen yapÄ±dan faydalanÄ±larak birtakÄ±m belgelerin bir blok ÅŸeklinde bir arada toplanmasÄ± saÄŸlanmÄ±ÅŸ ve bu durum sistemi daha verimli hale getirmiÅŸtir. Ancak tÃ¼m bu geliÅŸmelere raÄŸmen bu teknoloji kullanÄ±lmamÄ±ÅŸ ve 2004 yÄ±lÄ±nda sonlanmÄ±ÅŸ. 2008 yÄ±lÄ±nÄ±n son Ã§eyreÄŸine gelindiÄŸinde, Lehman Brothersâ€™Ä±n iflasÄ±ndan sadece iki ay sonra, Bitcoin olarak isimlendirilen merkezi olmayan, eÅŸler arasÄ± (P2P) dijital para sistemini aÃ§Ä±klayan bir manifesto, Satoshi Nakamoto takma isimli kiÅŸi veya kiÅŸiler tarafÄ±ndan yayÄ±nlandÄ±. 3 Ocak 2009 tarihinde Bitcoinâ€™in ilk bloÄŸu (Genesis) Satoshi Nakamoto tarafÄ±ndan oluÅŸturuldu ve bu iÅŸlem ona 50 Bitcoin kazandÄ±rdÄ±. Blockchainâ€™in Temel Ã–ÄŸeleriDaÄŸÄ±tÄ±k BÃ¼yÃ¼k VeritabanÄ±AÄŸdaki tÃ¼m katÄ±lÄ±mcÄ±lar, bu veritabanÄ±na ve deÄŸiÅŸmez iÅŸlem kayÄ±tlarÄ±na eriÅŸebilirler. PaylaÅŸÄ±lan bu veritabanÄ±nda iÅŸlemler sadece bir kaydedilir. DeÄŸiÅŸmez KayÄ±tlarBir iÅŸlem, paylaÅŸÄ±lan veritabanÄ±na kaydedildikten sonra hiÃ§bir katÄ±lÄ±mcÄ± tarafÄ±ndan deÄŸiÅŸtirilemez veya kurcalanamaz. EÄŸer bir iÅŸlem kaydÄ± hata iÃ§eriyorsa, bu deÄŸiÅŸtirilemeyeceÄŸi iÃ§in hatayÄ± tersine Ã§evirmek gerekir, bunun iÃ§in yeni bir iÅŸlem eklenmelidir ve her iki iÅŸlem de gÃ¶rÃ¼nÃ¼r hale gelecektir. AkÄ±llÄ± SÃ¶zleÅŸmelerÄ°ÅŸlemleri hÄ±zlandÄ±rmak iÃ§in, akÄ±llÄ± sÃ¶zleÅŸme adÄ± verilen bir dizi kural, Blockchainâ€™de depolanÄ±r ve otomatik olarak yÃ¼rÃ¼tÃ¼lÃ¼r. Bir akÄ±llÄ± sÃ¶zleÅŸme, bloklarla ile ilgili olan her tÃ¼rlÃ¼ ÅŸartÄ± iÃ§erebilir. Interoperability(FarklÄ± Blockchain AÄŸlarÄ±nÄ±n Birlikte Ã‡alÄ±ÅŸabilmesi)GÃ¼nÃ¼mÃ¼zde, blok zincirlerinin sayÄ±sÄ± gitgide artÄ±yor. Bununla birlikte bu blok zincirleri kendi izole ortamlarÄ±nda Ã§alÄ±ÅŸmaya ve bÃ¼yÃ¼meye devam ediyor. Bir block zincirinin baÅŸka bir blok zincirindeki veriye olan ihtiyacÄ± Interoperability kavramÄ±nÄ± ortaya Ã§Ä±karmÄ±ÅŸtÄ±r. Buradan hareketle, Interoperability, kÄ±saca, blockchain aÄŸlarÄ± arasÄ±nda bilgileri kolayca paylaÅŸma ve iÅŸlem yapma kabiliyetidir diyebiliriz. BaÅŸka bir ifadeyle, birlikte Ã§alÄ±ÅŸabilirlik, tÃ¼m blockchain aÄŸlarÄ±nda serbestÃ§e bilgi paylaÅŸma yeteneÄŸidir. En genel anlamÄ±yla ise, Interoperability, farklÄ± bilgi sistemlerinin, cihazlarÄ±n ve uygulamalarÄ±n verilere, kurumsal, bÃ¶lgesel ve ulusal sÄ±nÄ±rlar iÃ§inde ve Ã¶tesinde, koordineli bir ÅŸekilde, bilgiye zamanÄ±nda, kesintisiz bir ÅŸekilde taÅŸÄ±nabilirlik saÄŸlama, eriÅŸme, bÃ¼tÃ¼nleÅŸtirme ve iÅŸbirliÄŸi iÃ§inde kullanma becerisidir diyebiliriz. Tamamen birlikte Ã§alÄ±ÅŸabilir bir ekosistemde, baÅŸka bir blok zincirinden bir kullanÄ±cÄ±, blok zincirine bir ÅŸey gÃ¶nderirse, o kullanÄ±cÄ±yÄ± kolayca tanÄ±yÄ±p ve etkileÅŸime geÃ§ebiliriz. Blok zincirlerinin birlikte Ã§alÄ±ÅŸmasÄ± bir nevi onlarÄ±n birleÅŸmesi demektir. Bu birleÅŸmedeki amaÃ§, birlikten gÃ¼Ã§ doÄŸmasÄ±nÄ± saÄŸlamak. Yani blok zincirlerindeki kullanÄ±cÄ± sayÄ±sÄ±nÄ± Ã§oÄŸaltmak. BirleÅŸme sonucunda kullanÄ±cÄ±lara pek Ã§ok pratik fayda saÄŸlanÄ±r ve kullanÄ±cÄ± adaptasyonu artÄ±rÄ±lÄ±r. Hali hazÄ±rda, blok zincirleri arasÄ±nda birlikte Ã§alÄ±ÅŸabilirliÄŸi saÄŸlamak iÃ§in Ã¼Ã§ teknik mevcut. Bunlar; Notary schemes, Sidechains / Relays ve Hash-Locking teknikleridir. Notary schemes (Noter ÅŸemalarÄ±), blok zincirleri arasÄ±nda gÃ¼venilir bir varlÄ±k kullanÄ±lmaktadÄ±r. Buradaki noterin rolÃ¼, blok zincirinde bir olayÄ±n gerÃ§ekleÅŸtiÄŸini doÄŸrulamak ve bu bilgileri baÅŸka bir blok zincirine aktarmaktÄ±r. Noter ÅŸemasÄ±nÄ±n bize saÄŸladÄ±ÄŸÄ± en bÃ¼yÃ¼k fayda, basitliÄŸidir. Ã‡Ã¼nkÃ¼, blok zincirinin temel uygulamasÄ±nda herhangi bir deÄŸiÅŸikliÄŸe ihtiyaÃ§ duyulmaz. DezavantajÄ± ise, notere gÃ¼venmek zorunda olmamÄ±zdÄ±r. Sidechains (Yan zincirler) / Relays, diÄŸer blok zincirlerinin durumu hakkÄ±nda bilgileri doÄŸrulama ve iÅŸleme yeteneÄŸi saÄŸlar. Bu iÅŸlem, teknik olarak, Simpliï¬ed Payment Veriï¬cation (Basit Ã–deme DoÄŸrulamasÄ±) kullanÄ±larak gerÃ§ekleÅŸtirilir. Simpliï¬ed Payment Veriï¬cation, tÃ¼m defteri indirmek zorunda kalmadan baÅŸka bir blok zincirinde bir iÅŸlem olup olmadÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in blok baÅŸlÄ±klarÄ± ve Merkle aÄŸaÃ§larÄ± kullanan bir sistemdir. Verilerin harici olarak bir blok zincirinden diÄŸerine aktarÄ±lmasÄ± gerekse de, bu iÅŸlem iÃ§in gevene ihtiyaÃ§ duyulmaz. Åekil.2 â€” Sidechain (Yan zincir) BilindiÄŸi Ã¼zere, blok zincirlerinin kriptografik Ã¶zellikleri nedeniyle, verilerin kurcalandÄ±ÄŸÄ±nÄ± anlamak kolaydÄ±r. AyrÄ±ca, iki blok zinciri arasÄ±ndaki deÄŸiÅŸ tokuÅŸlar, â€œPegged sidechainsâ€ ile etkinleÅŸtirilebilir. Bu ÅŸema, varlÄ±klarÄ±n bir blok zincirinde kilitlendiÄŸine dair bir kanÄ±t oluÅŸturur, bÃ¶ylece ikinci bir blok zincirinde aynÄ± miktarda iÅŸlem yapÄ±labilir. Bunun yanÄ±nda, bir yan zincir oluÅŸturmak iÃ§in akÄ±llÄ± sÃ¶zleÅŸme yetenekleri de gerekli. Tam birlikte Ã§alÄ±ÅŸabilirlik saÄŸlamak iÃ§in, her blok zinciri, diÄŸer tÃ¼m blok zincirlerini desteklemesi gereken bir yan zincire ihtiyaÃ§ duyar. BÃ¼yÃ¼yen bu sistemin bakÄ±mÄ± doÄŸal olarak bÃ¼yÃ¼k bir zorluk haline geliyor. Sidechains AvantajlarÄ±;En Ã¶nemli iki avantajlarÄ± var. Sahip olduklarÄ± ilk avantaj, sonsuz olmalarÄ±dÄ±r. Her seferinde bir tane kullanmanÄ±z gerektiÄŸinde yeni bir Sidechain oluÅŸturmanÄ±z gerekmez. Bir Sidechain oluÅŸturulduktan sonra korunur ve ana zincirden belirli bir gÃ¶revi yapan herkes tarafÄ±ndan kullanÄ±labilir.Ä°kinci avantajÄ± ise, farklÄ± kripto para birimleri arasÄ±nda etkileÅŸim kurmayÄ± kabul etmeleridir. GeliÅŸtiriciler, ana zincirde yayÄ±nlanmadan Ã¶nce yazÄ±lÄ±m sÃ¼rÃ¼mlerini ve beta coin sÃ¼rÃ¼mlerini test etme ÅŸansÄ±na sahip olurlar. Sidechains DezavantajlarÄ±;Yan zincirlerin korunmasÄ±nÄ± saÄŸlamak iÃ§in madencilere ihtiyaÃ§ duyulur. Bu, yeni Sidechainâ€™lerin dÃ¼zenlenmesini pahalÄ± bir giriÅŸim haline getiriyor. Herhangi bir yeni Sidechain oluÅŸturulmadan Ã¶nce bÃ¼yÃ¼k miktarlarda yatÄ±rÄ±m yapÄ±lmalÄ±dÄ±r. Hash-Locking, iki iÅŸlem veya aracÄ±sÄ± olmayan daha fazla taraf arasÄ±ndaki ticarete izin veren bir tekniktir. Bir baÅŸka ifadeyle, Lightning Networksâ€™ten tÃ¼retilen bir karma deÄŸerin dÃ¼z metnini tahmin etmek iÃ§in bir sÃ¼re kilitleyerek Ã¶deme yapmak iÃ§in bir mekanizmadÄ±r.Ã‡oÄŸu senaryoda zincirler arasÄ± varlÄ±k alÄ±ÅŸveriÅŸini ve zincirler arasÄ± varlÄ±k yayÄ±lÄ±mÄ±nÄ± desteklese de, zincirler arasÄ± varlÄ±k taÅŸÄ±nabilirliÄŸi ve zincirler arasÄ± akÄ±llÄ± sÃ¶zleÅŸme iÃ§in kullanÄ±lamaz. Bu birlikte Ã§alÄ±ÅŸabilirlik iÃ§in en pratik teknik yÃ¶ntemdir, ancak iÅŸlevsellik aÃ§Ä±sÄ±ndan da en sÄ±nÄ±rlayÄ±cÄ± olanÄ±dÄ±r, sadece dijital varlÄ±k deÄŸiÅŸimini destekler. Bu teknik gÃ¼nÃ¼mÃ¼zde Ã§oÄŸu merkezi olmayan borsa tarafÄ±ndan kullanÄ±lÄ±yor. Hash-Locking dezavantajÄ±;Blok zincirinin Hash-TimeLock SÃ¶zleÅŸmesi (HTLC) adÄ± verilen bu tÃ¼r akÄ±llÄ± sÃ¶zleÅŸmeyi desteklemesi gerektiÄŸidir. AyrÄ±ca, iÅŸlemler esnasÄ±ndaki bekleme sÃ¼resi taraflar arasÄ±nda dÃ¼ÅŸen veya artan fiyatlar Ã¼zerinde spekÃ¼lasyon yapÄ±larak kullanÄ±labilir. Interoperability SeviyeleriFoundational Level (Temel Seviye): Bir sistem veya uygulamanÄ±n gÃ¼venli bir ÅŸekilde diÄŸerine veri iletmesi ve diÄŸerinden veri almasÄ± iÃ§in gereken baÄŸlantÄ±lar arasÄ± gereksinimleri belirler. Structural Level (YapÄ±sal Seviye): Yorumlama iÃ§in veri alanÄ± seviyesinde olmak Ã¼zere veri alÄ±ÅŸveriÅŸinin biÃ§imini, sÃ¶zdizimini ve organizasyonunu tanÄ±mlar. Semantic Level (Anlamsal Seviye): Ortak kullanÄ±lan modeller ve kodlama saÄŸlar, veri halka aÃ§Ä±k deÄŸer kÃ¼melerinden standart tanÄ±mlamalar ve kodlama kelime daÄŸarcÄ±ÄŸÄ± kullanÄ±mÄ± da dahil olmak Ã¼zere, kullanÄ±cÄ±ya ortak bir anlayÄ±ÅŸ ve anlam saÄŸlar. Organizational Level (Ã–rgÃ¼tsel Seviye): KuruluÅŸlar, kurumlar ve bireyler arasÄ±nda gÃ¼venli, kesintisiz ve zamanÄ±nda iletiÅŸim ve veri kullanÄ±mÄ±nÄ± kolaylaÅŸtÄ±rmak iÃ§in yÃ¶netiÅŸim, politika, sosyal, yasal ve organizasyonel hususlarÄ± iÃ§erir. Bu bileÅŸenler paylaÅŸÄ±lan onay, gÃ¼ven ve entegre son kullanÄ±cÄ± sÃ¼reÃ§leri ve iÅŸ akÄ±ÅŸlarÄ±nÄ± mÃ¼mkÃ¼n kÄ±lar. Interoperability Neden Ã–nemlidir?Blok zincirinde, birlikte Ã§alÄ±ÅŸabilirlik, kullanÄ±cÄ± dostu bir deneyim saÄŸlar ve bÃ¶ylece benimsenmeyi artÄ±rÄ±r. CÃ¼zdanlar aracÄ±lÄ±ÄŸÄ±yla Ã§ok tokenli iÅŸlemler saÄŸlar ve kullanÄ±cÄ±larÄ±n tek bir pencerede birden fazla para birimiyle Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak iÃ§in zincirler arasÄ± bilgi alÄ±ÅŸveriÅŸini saÄŸlar. Birlikte Ã§alÄ±ÅŸabilirlik olmadan, baÄŸlantÄ±sÄ±z sistemler iletiÅŸim kurmadan veya iÅŸlem yapmadan birbirleriyle birlikte Ã§alÄ±ÅŸan baÄŸÄ±msÄ±z silolar olacaktÄ±r. Birlikte Ã§alÄ±ÅŸabilir bir ekosistem, ayrÄ± blok zinciri aÄŸlarÄ±ndan gelen birden Ã§ok kullanÄ±cÄ±nÄ±n, alÄ±nan bilgileri tercÃ¼me etmek ve kesinti yaÅŸamak iÃ§in kaynak harcamadan etkileÅŸim kurmasÄ±nÄ± saÄŸlar. Bilgilerin iÅŸlenmesini ve buna gÃ¶re bir yanÄ±tÄ±n gÃ¶nderilmesini saÄŸlar. Blockchain birlikte Ã§alÄ±ÅŸabilirliÄŸinin temel faydalarÄ±: KatÄ±lÄ±mcÄ± blok zincirleri arasÄ±nda kesintisiz bilgi alÄ±ÅŸveriÅŸi saÄŸlanÄ±r. AkÄ±llÄ± sÃ¶zleÅŸmeler zahmetsizce yapÄ±labilir. Blok zinciri ekosistemi iÃ§inde ortaklÄ±klar geliÅŸtirilebilir. BT personeli, bazÄ± Ã¶nde gelen standartlar hakkÄ±nda iyi bir anlayÄ±ÅŸ geliÅŸtirebilir. Blockchain AÄŸlarÄ±nÄ±n DÄ±ÅŸ Sistemler ile Entegrasyonunda Dikkat Edilmesi GerekenlerBlok zinciri aÄŸlarÄ±nÄ±n Ã¼Ã§ tÃ¼rÃ¼ vardÄ±r, bunlar; Public Blockchain (Genel Blokzincir), Private Blockchain (Ã–zel Blokzincir) ve Federated/Consortium Blockchain (BirleÅŸik / Konsorsiyum Blokzincir)â€™dir. Genel bir blokzincir, Bitcoin tarafÄ±ndan tanÄ±tÄ±ldÄ±ÄŸÄ± gibi hepimizin bildiÄŸi ve sevdiÄŸi standart blokzincir aÄŸÄ±dÄ±r. AdÄ±ndan da anlaÅŸÄ±lacaÄŸÄ± gibi, aÄŸ herkese aÃ§Ä±ktÄ±r ve merkezi bir yÃ¶netim yoktur. Sistem ÅŸu ÅŸekilde Ã§alÄ±ÅŸÄ±r: Herkes aÄŸa eriÅŸebilir ve tamamen merkezi olmayan, izinsiz ve aÃ§Ä±k kaynaklÄ± bir sistem olduÄŸu iÃ§in blok zincirini okuma, yazma ve denetlemeye katÄ±labilir. AyrÄ±ca, herkes belirli bir noktada iÅŸlem oluÅŸturabilir, doÄŸrulayabilir ve gÃ¶rÃ¼ntÃ¼leyebilir. Ä°ÅŸlemleri doÄŸrulamak iÃ§in, karar alma Ã‡alÄ±ÅŸma KanÄ±tÄ± (PoW) veya KanÄ±t KanÄ±tÄ± (PoS) gibi bir konsensÃ¼s algoritmasÄ± ile gerÃ§ekleÅŸir. AÄŸ halka aÃ§Ä±k olmasÄ±na raÄŸmen, katÄ±lÄ±mcÄ±larÄ±n kimliÄŸi takma addÄ±r. Bununla birlikte, katÄ±lÄ±mcÄ±larÄ±n anonimliÄŸi, hem avantaj hem de dezavantajdÄ±r, Ã§Ã¼nkÃ¼ bu, kÃ¶tÃ¼ niyetli iÅŸlemleri iÃ§erebilir ve sistemin itibarÄ±nÄ± tehdit edebilir. Halka aÃ§Ä±k blokzincir aÄŸÄ±nÄ± kullanan blokzincir uygulamalarÄ±na Ã¶rnek olarak Bitcoin, Litecoin, Ethereum ve bilinen diÄŸer tÃ¼m alternatif dijital para birimleri verilebilir. Ã–zel bir blokzincir, bir kiÅŸiye veya kuruluÅŸa ait izin verilen ve kapalÄ± bir sistemdir. Bu tÃ¼r sistemde, sadece tek yetkili aÄŸ blok zincirini okuyabilir, yazabilir ve denetleyebilir. Merkezi yetkili ayrÄ±ca, yalnÄ±zca belirli noktalarda iÅŸlem yapmak, doÄŸrulamak ve gÃ¶rÃ¼ntÃ¼lemek iÃ§in seÃ§ilen dÃ¼ÄŸÃ¼mlere izinli eriÅŸim saÄŸlayabilir. Esasen Ã¶zel olduÄŸu iÃ§in konsensÃ¼s, sorumlu kiÅŸinin takdirine baÄŸlÄ± olarak veya bir oylama veya Ã§ok partili konsensÃ¼s algoritmasÄ± ile elde edilir. Ã–zel blokzincir aÄŸlarÄ± genellikle veritabanÄ± yÃ¶netimi ve denetimi gibi tek bir Ã¶zel ÅŸirketin dahili sistemlerine uygulanÄ±r. Ã–zel blok zincirleri, kriptografik denetim ve bilinen kimliklerin avantajÄ±nÄ± sunar. Bu tÃ¼r bir sistemin doÄŸasÄ±, verileri kurcalamayÄ± zorlaÅŸtÄ±rÄ±r, ancak iÅŸlemleri doÄŸrulamayÄ± kolaylaÅŸtÄ±rÄ±r, bÃ¶ylece sistemi daha hÄ±zlÄ± ve daha uygun maliyetli hale getirir. Ã–zel bir blokzincir aÄŸÄ±na dayanan blokzincir uygulamalarÄ±na Ã¶rnek olarak Bankchain, Monax ve Hyperledger verilebilir. Bir birleÅŸik / konsorsiyum blokzincir, tek Ã¶zerkliÄŸin kaldÄ±rÄ±ldÄ±ÄŸÄ± izin verilen ve gruba ait bir sistemdir ve bunun yerine izinler bir grup ÅŸirkete veya bireye verilir. Bu tip sistemde, blok zincirini okumak, yazmak ve denetlemek iÃ§in Ã¶nceden seÃ§ilmiÅŸ dÃ¼ÄŸÃ¼mlere eriÅŸim saÄŸlayacak birden fazla merkez vardÄ±r. YalnÄ±zca konsorsiyum Ã¼yeleri iÅŸlemleri yapabilir, doÄŸrulayabilir ve inceleyebilir. KonsensÃ¼s, kurallarÄ± katÄ±lÄ±mcÄ±larÄ±n anlaÅŸmasÄ±na baÄŸlÄ± olan bir oylama veya Ã§ok partili konsensÃ¼s algoritmasÄ± ile elde edilir. BirleÅŸik / konsorsiyum blokzincirleri, Ã¶zel blok zincirlerinin sunduÄŸu aynÄ± faydalarÄ±, yani iÅŸlemlerin etkinliÄŸi ve gizliliÄŸi sunar. Bununla birlikte, sadece bir ÅŸirkete gÃ¼Ã§ konsolidasyonunu ortadan kaldÄ±rma avantajÄ± saÄŸlar. Bu tip blokzincir aÄŸÄ±, organizasyonel iÅŸbirliÄŸi iÃ§in idealdir. Ã–zetle, Ã¶zel ve birleÅŸik / konsorsiyum blokzinciri aÄŸlarÄ±nÄ±n her ikisi de, iÅŸlem hÄ±zÄ± aÃ§Ä±sÄ±ndan genel blokzincirlerine gÃ¶re bir avantaj sunmaktadÄ±r. Bununla birlikte, bu aÄŸlarÄ±n hesap verebilirlik ve genel yÃ¶n gibi kendi sÄ±nÄ±rlamalarÄ± da vardÄ±r. Bu yeni blokzinciri aÄŸlarÄ±nÄ±n sunduklarÄ±, orjinal blokzinciri Ã§erÃ§evesini kullanmaya devam ederken, haklar ve eriÅŸim yÃ¶netimi iÃ§in alternatif seÃ§enekler vardÄ±r. DiÄŸer bir taraftan, internet dÃ¼nyasÄ±nÄ±n genelinde gÃ¶rÃ¼len gÃ¼venlik sorunlarÄ± blokzinciri sistemleri iÃ§inde de geÃ§erlidir. Siber ataklar blokzincirlerini tehdit etmektedir. Ã–rneÄŸin aÄŸ denetiminin bÃ¼yÃ¼k Ã§oÄŸunluÄŸu siber saldÄ±rÄ± sonucu kÃ¶tÃ¼ niyetli bireylerin eline geÃ§erse iÅŸlemlerin sÄ±ralamasÄ±nÄ±n deÄŸiÅŸtirilmesi veya bazÄ± iÅŸlemlerin kasÄ±tlÄ± olarak iÅŸlem dÄ±ÅŸÄ± bÄ±rakÄ±lmasÄ± saÄŸlanabilir veya kiÅŸisel veriler tehlikeye girebilir. Birlikte Ã§alÄ±ÅŸabilirlik konusuna, geliÅŸtiriciler aÃ§Ä±sÄ±ndan bakÄ±ldÄ±ÄŸÄ±nda; geliÅŸtiriciler daha fazla Ã¶zgÃ¼rlÃ¼k iÃ§in bir blokzinciri oluÅŸtururken standartlarÄ± genellikle yok sayarlar, ancak bu birlikte Ã§alÄ±ÅŸabilirlik ve iletiÅŸim sorunlarÄ±na neden olabilir. Birlikte Ã§alÄ±ÅŸabilirlik iÃ§in en bÃ¼yÃ¼k zorluk, uzlaÅŸma modelleri, akÄ±llÄ± sÃ¶zleÅŸme iÅŸlevselliÄŸi ve iÅŸlem ÅŸemalarÄ± gibi farklÄ± parametrelere sahip Ã§oklu blokzinciri aÄŸlarÄ±dÄ±r. Bu durumu dÃ¼zeltmek iÃ§in devam etmekte olan birkaÃ§ standartlaÅŸtÄ±rma Ã§abasÄ± var. IBM ve Microsoft, birlikte Ã§alÄ±ÅŸabilir bir blok zinciri saÄŸlamak iÃ§in GS1 tarafÄ±ndan geliÅŸtirilen mevcut bir standardÄ± kullanÄ±yor. Bununla birlikte, Enterprise Ethereum Alliance sÄ±fÄ±rdan bir standart geliÅŸtirmiÅŸtir. Blokzincirinin birlikte Ã§alÄ±ÅŸabilirlik standartlaÅŸtÄ±rma Ã§abalarÄ± iki gruba ayrÄ±labilir: Open protocols (AÃ§Ä±k protokoller): Ã¼Ã§Ã¼ncÃ¼ bir taraf olmadan blok zincirleri arasÄ±nda iletiÅŸime izin veren standart protokoller veya gerekli gÃ¼ven sÃ¼reÃ§leri. En iyi bilinen aÃ§Ä±k protokol Atomic takastÄ±r. Multi-chain frameworks (Ã‡ok zincirli Ã§erÃ§eveler): Genellikle â€œblokzincirlerinin internetiâ€ olarak adlandÄ±rÄ±lÄ±r, bunlar aÃ§Ä±k protokollerden daha karmaÅŸÄ±ktÄ±r. Blok zincirler standartlaÅŸtÄ±rÄ±lmÄ±ÅŸ bir ekosistemin parÃ§asÄ± olabilir ve bir birbirleriyle veri ve deÄŸer aktarÄ±mÄ± yapabilir. Kaynaklarhttps://www.ibm.com/tr-tr/blockchain/what-is-blockchainhttps://startuphukuku.com/blockchain-nedir/http://www3.weforum.org/docs/WEF_A_Framework_for_Blockchain_Interoperability_2020.pdfhttps://bkm.com.tr/wp-content/uploads/2015/06/Sorularlablockchain.pdfhttps://bkm.com.tr/wp-content/uploads/2019/08/15082019_kitap.pdfhttps://cointral.com/tr/blockchain-nedir/https://medium.com/@ahmetseyhan/blockchain-teknolojisine-giri%C5%9F-4d2cbb452342https://www.wanchain.org/blog/the-importance-of-blockchain-interoperability/https://files.ifi.uzh.ch/CSG/staff/scheid/extern/publications/LCN2019-Bifrost.pdfhttps://medium.com/@harish_6956/sidechain-blockchain-641da3474ab3https://medium.com/coinmonks/intervalues-cross-chain-technology-and-multi-chain-integration-will-realize-value-interconnection-698cd04b9b5fhttps://www.himss.org/what-interoperabilityhttps://www.primafelicitas.com/the-challenges-of-blockchain-interoperability/https://www2.deloitte.com/content/dam/Deloitte/tr/Documents/consulting/blokzincir-potansiyelinin-kesfi.pdfhttps://www.infineon.com/dgdl/Infineon-whitepaper-Bringing-security-to-the-world-of-blockchain-Whitepaper-v01_00-EN.pdf?fileId=5546d4626afcd350016b2d605e927265https://www.cnnturk.com/2010/turkiye/03/04/50.milyon.kisinin.kimligi.internette.iddiasi/566233.0/index.html","link":"/blockchain-interoperability/"}],"tags":[{"name":"algoritma","slug":"algoritma","link":"/tags/algoritma/"},{"name":"genetik","slug":"genetik","link":"/tags/genetik/"},{"name":"rating","slug":"rating","link":"/tags/rating/"},{"name":"helper","slug":"helper","link":"/tags/helper/"},{"name":"solid","slug":"solid","link":"/tags/solid/"},{"name":"dropbox","slug":"dropbox","link":"/tags/dropbox/"},{"name":"svn","slug":"svn","link":"/tags/svn/"},{"name":"unittest","slug":"unittest","link":"/tags/unittest/"},{"name":"mock","slug":"mock","link":"/tags/mock/"},{"name":"dbcontext","slug":"dbcontext","link":"/tags/dbcontext/"},{"name":"ef6","slug":"ef6","link":"/tags/ef6/"},{"name":"entityframework","slug":"entityframework","link":"/tags/entityframework/"},{"name":"asnotracking","slug":"asnotracking","link":"/tags/asnotracking/"},{"name":"visualstudio","slug":"visualstudio","link":"/tags/visualstudio/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"pages","slug":"pages","link":"/tags/pages/"},{"name":"customdomain","slug":"customdomain","link":"/tags/customdomain/"},{"name":"mssql","slug":"mssql","link":"/tags/mssql/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"webmaster","slug":"webmaster","link":"/tags/webmaster/"},{"name":"otomatik","slug":"otomatik","link":"/tags/otomatik/"},{"name":"versiyonlama","slug":"versiyonlama","link":"/tags/versiyonlama/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"oracle","slug":"oracle","link":"/tags/oracle/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"update","slug":"update","link":"/tags/update/"},{"name":"storedprocedures","slug":"storedprocedures","link":"/tags/storedprocedures/"},{"name":"devops","slug":"devops","link":"/tags/devops/"},{"name":"webassembly","slug":"webassembly","link":"/tags/webassembly/"},{"name":"blazor","slug":"blazor","link":"/tags/blazor/"},{"name":"yapay-zeka","slug":"yapay-zeka","link":"/tags/yapay-zeka/"},{"name":"artificial-intelligence","slug":"artificial-intelligence","link":"/tags/artificial-intelligence/"},{"name":"explainable-ai","slug":"explainable-ai","link":"/tags/explainable-ai/"},{"name":"aciklanabilir-yapay-zeka","slug":"aciklanabilir-yapay-zeka","link":"/tags/aciklanabilir-yapay-zeka/"},{"name":"blockchain","slug":"blockchain","link":"/tags/blockchain/"},{"name":"blockchain-interoperability","slug":"blockchain-interoperability","link":"/tags/blockchain-interoperability/"}],"categories":[{"name":"Algoritmalar","slug":"Algoritmalar","link":"/categories/Algoritmalar/"},{"name":".Net","slug":"Net","link":"/categories/Net/"},{"name":"Genel","slug":"Genel","link":"/categories/Genel/"},{"name":"C#","slug":"Net/C","link":"/categories/Net/C/"},{"name":".Net","slug":"Algoritmalar/Net","link":"/categories/Algoritmalar/Net/"},{"name":"Tavsiye Programlar","slug":"Tavsiye-Programlar","link":"/categories/Tavsiye-Programlar/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Webmaster","slug":"Webmaster","link":"/categories/Webmaster/"},{"name":"VeritabanÄ±","slug":"Net/Veritabani","link":"/categories/Net/Veritabani/"},{"name":"SQL Server","slug":"SQL-Server","link":"/categories/SQL-Server/"},{"name":"Javascript","slug":"Net/C/Javascript","link":"/categories/Net/C/Javascript/"},{"name":"C#","slug":"Algoritmalar/Net/C","link":"/categories/Algoritmalar/Net/C/"},{"name":"VeritabanÄ±","slug":"Veritabani","link":"/categories/Veritabani/"},{"name":"Visual Studio","slug":"Visual-Studio","link":"/categories/Visual-Studio/"},{"name":"Unit Test","slug":"Net/C/Unit-Test","link":"/categories/Net/C/Unit-Test/"},{"name":"JQuery","slug":"Javascript/JQuery","link":"/categories/Javascript/JQuery/"},{"name":"Javascript","slug":"Webmaster/Javascript","link":"/categories/Webmaster/Javascript/"},{"name":"VeritabanÄ±","slug":"SQL-Server/Veritabani","link":"/categories/SQL-Server/Veritabani/"},{"name":"JQuery","slug":"Net/C/Javascript/JQuery","link":"/categories/Net/C/Javascript/JQuery/"},{"name":"Oracle","slug":"Veritabani/Oracle","link":"/categories/Veritabani/Oracle/"},{"name":"SQL Server","slug":"Veritabani/SQL-Server","link":"/categories/Veritabani/SQL-Server/"},{"name":"Open Source","slug":"Net/C/Javascript/JQuery/Open-Source","link":"/categories/Net/C/Javascript/JQuery/Open-Source/"},{"name":"Devops","slug":"Devops","link":"/categories/Devops/"},{"name":"Javascript","slug":"Genel/Javascript","link":"/categories/Genel/Javascript/"},{"name":"Yapay Zeka","slug":"Yapay-Zeka","link":"/categories/Yapay-Zeka/"}]}