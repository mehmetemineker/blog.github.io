{"pages":[],"posts":[{"title":"8 Vezir Probleminin Genetik Algoritma ile Çözümü","text":"Merhaba arkadaşlar, bu yazımda algoritma severlerin mutlaka bildiği 8 vezir probleminin genetik algoritma ile çözümünden bahsedeceğim. Her ne kadar 8 vezir desek de asıl amacımız n adet vezirin nxn’lik satranç tahtasına uygun bir şekilde yerleştirilmesini sağlamaktır. Bu yüzden 8 vezir yerine, n vezir problemi demek daha doğru olacaktır. n Vezir Problemi AmacıSatranç oynayanlar bilir, bir vezir yatay, dikey ve çapraz hamleler yapabilir. Amacımız n adet veziri, nxn’lik bir satranç tahtasına birbirini kesmeyecek şekilde yerleştirmek. n Vezir Probleminin Geçmişi8 vezir problemi ilk olarak 1848 yılında satranç oyuncusu Max Bezzel tarafından ortaya atılmıştır. Gauss ve Georg Cantor gibi pek çok matematikçi tarafından incelenmiştir. İlk çözümü Franz Nauck 1850’de ortaya atmıştır, aynı zamanda n vezir problemi haline getirmiştir. n Vezir Probleminin Genetik Algoritma ile ÇözümüGenetik algoritma ile ilgili daha önceden bir yazı yazmıştım. Temel seviyede bilgiyi şuradan edinebilirsiniz. Evrimsel Sürecin Simülasyonu – Genetik Algoritmalar – 1 Fitness FunctionBildiği üzere genetik algoritmada asıl işi yapan Fitness Function‘dır. İyi düşünülerek yazılmış bir fitness function sonuca ulaşmamızı büyük bir oranda etkiler. 8 vezir probleminde ise algoritmamız şu şekilde olacak: 8×8’lik satranç tahtasının ilk sütunundan başlayarak bir vezir seçilir Seçilen veziri, tahtanın sağında yer alan kesmeyen vezir sayısı bulunur Bu kontrol tüm sütunlar için uygulanır ve toplam kesmeyen vezir sayısı bulunur Not: 8 vezirlik bir problemin en uygun fitness function sonucu 28 olarak hesaplanır. Problem için hazırladığım fitness function 12345678910111213141516171819202122232425262728293031public class MyProblemFitness : IFitnessFunction{ public double Evaluate(IChromosome chromosome) { var genes = ((PermutationChromosome)chromosome).Value; double result = 0; for (int x1 = 0; x1 &lt; genes.Length - 1; x1++) { int y1 = genes[x1]; int sagdakiVezirSayisi = genes.Length - 1 - x1; for (int x2 = x1 + 1; x2 &lt; genes.Length; x2++) { int y2 = genes[x2]; if (y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2) { sagdakiVezirSayisi -= 1; } } result += sagdakiVezirSayisi; } return result; }} Kromozom YapısıÖrnek kromozom: [ 5, 1, 3, 0, 2, 7, 6, 4 ] Bu problem için permütasyon kodlamalı kromozom yapısı daha uygun olacaktır. Kromozomun birinci elamanı olan 5 değeri, vezirin sıfırıncı sütun ve beşinci satırda yer aldığını ifade etmektedir. C# ile ÇözümüProblemin çözümde kütüphane kullanmak çözüm süresinin uzamasını ve aynı işlerin (crossover, mutation, selection…) tekrarını önlemek açısından önemli. Bu yüzden AForge.Net Genetic ve GeneticSharp kütüphanelerini kullandım. Problemi her iki kütüphane ile çözdüm. AForge.Net kütüphanesinin performası bu problem için daha uygun geldi bana. Tavsiyem AForge.Net Genetic. Problemin çözümünü Github’ta paylaştım. İsterseniz inceleyebilirsiniz, https://github.com/mehmetemineker/Genetic8QueensSolutionWithAForge – AForge.Net Genetic https://github.com/mehmetemineker/Genetic8QueensSolutionWithGeneticSharp – GeneticSharp Kaynak: https://tr.wikipedia.org/wiki/Sekiz_vezir_bulmacas%C4%B1","link":"/8-vezir-probleminin-genetik-algoritma-ile-cozumu/"},{"title":"ASP.Net MVC Stars Rating Helper","text":"Geliştirmiş olduğum stars rating helperı. Açık kaynak olarak Github repomdan bakabilirsiniz. https://github.com/mehmetemineker/FontAwesome-SuperStarsRating-Helper","link":"/asp-net-mvc-stars-rating-helper/"},{"title":"C# ToUpper ve ToLower Türkçe Karakter Sorunu","text":"ToUpper ve ToLower kullandığınızda Türkçe karakterlerde sıkıntı yaşattığını gördüyseniz doğru yerdesiniz. CultureInfo ile bu sorunu giderebiliriz. 1string test = test = test.ToUpper(new CultureInfo(\"tr-TR\", false));","link":"/c-toupper-ve-tolower-turkce-karakter-sorunu/"},{"title":"Dropbox Üzerine SVN Kurulumu","text":"Freelancerlar ve küçük takımlar için Dropbox üzerine SVN kurulumu.Geliştirdiğiniz projenin kaynak kodlarının kaybını en aza indirmek, versiyon kontrolü sağlamak ve takım halinde çalışırken çakışmaların önüne geçmek istiyorsanız, SVN kolay kurulumu ve kolay kullanımı ile yazılım geliştiricileri kendine çekmeyi başarıyor. Ben de Şubat 2016 dan beri SVN kullanıyorum. İlk başlarda temel amacını kavramakta zorlansam da artık kişisel projelerimde bile SVN kullanmaya karar verdim. Bu yazıyı yazmamdaki amaç server kurulum derdi olmadan direkt Dropbox üzerinde tanımladığım bir klasöre SVN bağlayıp kullanmak. Kısa bir hatırlatma; ben Dropbox kullanıyorum. Dropbox şart değil. Google Drive, One Drive, Yandex gibi benzer depolama alanlarını da kullanabilirsiniz. Şimdi kuruluma geçelim: Kullanılan yazılımlar TortoiseSVN Dropbox İndirime ve kurulum işlemleri tamamlandıktan sonra yapılması gerekenler; Dropbox hesabımız ile oturum açıp Dropbox klasörünün içerisine yeni boş bir klasör oluşturalım. Klasörü oluşturduk. Şimdi sırada SVN Repository oluşturmak. Klasöre sağ tıklayıp açılan menüden TortoiseSVN &gt; Create repository here tıklıyoruz. Create repository here a tıkladığımızda Repository created penceresi açıldı. Burda Create folder structure butonuna tıklıyoruz. Success sonucunu aldığımızda Dropbox ile olan işlemimizi başarıyla tamamlamış olduk. Şimdi oluşturduğum SVN klasörünü kendi local diskim üzerindeki bir klasöre bağlayacağım. Herhangi bir boş klasöre gidip sağ tıklayıp açılan menüden SVN Checkout… diyorum. Sonra açılan Checkout penceresinden URL of repository alanına Dropbox üzerinde oluşturduğum SVN klasörünün yolunu belirtiyorum. Checkout directory ise bizim local diskimizdeki klasörün yolu. OK butonuna bastıktan sonra Checkout Finished! penceresi geliyor ve SVN klasörleri oluşturuluyor. *Soru: *Peki diğer geliştiriciler benim Dropbox üzerinde oluşturduğum SVN klasörüne nasıl bağlanacaklar? *Cevap: *Çok basit. Dropbox hesap sahibi klasörü paylaşıma açacak. Bir yazının daha sonuna geldik. Bir sonraki yazım Visual Studio ve SVN ile ilgili olacak. Visual Studio ile SVN Kullanımı başlıklı yazıma gitmek ister misiniz? Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/dropbox-uzerine-svn-kurulumu/"},{"title":"EF6 DbContext Unit Test Mock","text":"Merhaba, çok uzun zamandır bir şeyler yazmıyordum. Tam anlamıyla bir yazı olmasa da bir başlangıç yapmak adına bu küçük paylaşımı yapmak istedim. Bu paylaşımımda EF6 DbContext Mock işlemi için hazırladığım kodu göreceksiniz. Bilindiği üzere unit test yazmanın en önemli ve en sıkıntılı noktalarından birisi mocklama işlemi. DbContext sınıfınız eğer test edilebilir olarak geliştirilmediyse bu süreç can sıkıcı olabiliyor. Var olan yapınızı da değiştirmek ürkütücü geliyorsa, paylaşmış olduğum kodlar ile çok fazla değişiklik yapmadan DbContext nesnemizi mocklayarak test edilebilir hale getirebilirsiniz. Mocklama işlemi için Moq kütüphanesinden faydalandım.Olmazsa olmaz Utility sınıfımız ile kodlar şöyle :) 12345678910111213141516171819202122232425public class Utility{ public static (Mock&lt;D&gt; mockDbContext, Mock&lt;MockableDbSetWithExtensions&lt;T&gt;&gt; mockDbSet) MockDb&lt;D, T&gt;(List&lt;T&gt; sourceList) where D : DbContext where T : class { var queryable = sourceList.AsQueryable(); var mockDbContext = new Mock&lt;D&gt;(); var mockDbSet = new Mock&lt;MockableDbSetWithExtensions&lt;T&gt;&gt;(); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.Provider).Returns(queryable.Provider); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.Expression).Returns(queryable.Expression); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.ElementType).Returns(queryable.ElementType); mockDbSet.As&lt;IQueryable&lt;T&gt;&gt;().Setup(m =&gt; m.GetEnumerator()).Returns(queryable.GetEnumerator()); mockDbSet.Setup(d =&gt; d.Add(It.IsAny&lt;T&gt;())).Callback&lt;T&gt;((s) =&gt; sourceList.Add(s)); return (mockDbContext, mockDbSet); }}public abstract class MockableDbSetWithExtensions&lt;T&gt; : DbSet&lt;T&gt; where T : class{ public abstract void AddOrUpdate(params T[] entities); public abstract void AddOrUpdate(Expression&lt;Func&lt;T, object&gt;&gt; identifierExpression, params T[] entities);} Bu metod 2 değişkenli Tuple döndürüyor. MockableDbSetWithExtensions nesnesi ile AddOrUpdate metodlarını test ediyorum. Bunun yerine sadece DbSet nesnesini de kullanabilirsiniz. Kullanımı 123var fakeData = new List&lt;MyDbSet&gt;()var (mockDbContext, mockDbSet) = Utility.MockDb&lt;MyContext, MyDbSet&gt;(fakeData);mockDbContext.Setup(c =&gt; c.MyDbSet).Returns(mockDbSet.Object); Bu tanımlamaları yaptıktan sonra test etmek istediğimiz metodun ait olduğu sınıfın yapıcı metoduna parametre olarak DbContext nesnemizi geçmemiz gerekiyor. DI kullanılıyorsa manuel olarak geçmemize gerek yok. Eğer yapımızı çok fazla değiştirmek istemiyorsanız yapıcı metoda parametre geçmek biraz daha kolay olacaktır. Kaynakhttps://docs.microsoft.com/tr-tr/ef/ef6/fundamentals/testing/mocking","link":"/ef6-dbcontext-unit-test-mock/"},{"title":"EntityFramework AsNoTracking Nedir?","text":"Merhaba arkadaşlar, bugün .Net Core projem için Generic Repository örneği yapıyordum. Github üzerinden örnek kodlara bakarken Entity sorgularındaki AsNoTracking ifadesini gördüm. Yaklaşık 4 yıldır MVC projelerinde görev alıyorum. AsNoTracking ifadesini şimdiye kadar fark edemediğim için üzüldüm, şimdi bunu keşfettiğim için de mutluyum. 🙂 Sizin de bundan faydalanmanızı istediğim için çok geciktirmeden blogumda paylaşmak istedim. Bildiğiniz üzere EntityFramework ile bir select işlemi yaptığınızda, gelen data içeriğini güncelleyip SaveChanges yaparsak değişiklikler veritabanına yansır. Bu işlemi her zaman istemiyor olabilirsiniz. Bu durumda AsNoTracking ifadesi yardımımıza koşuyor. Bu ifade ile yaptığımız entity sorgusu sadece okumalıktır. Üzerinde değişiklik yapıp SaveChanges yaptığımızda veritabanında hiçbir değişiklik olmaz. Bu da bize minimum bellek kullanımı ve optimum performans sağlayacaktır. Çok hoj 🙂 AsNoTracking PerformansıAsNoTracking ifadesinin performansı ne kadar etkilediğine görsel olarak birlikte bakalım: AsNoTracking KullanımıBu ifadenin kullanımı ise aşağıda göreceğiniz üzere çok kolay: 1context.Set&lt;TEntity&gt;().AsNoTracking(); Diğer bir kullanım yönetimi ise DbContext ayarlarından yapılabilir. Bu da tüm queryler için geçerli olacaktır: 1context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; Kaynaklar: http://blog.staticvoid.co.nz/2012/entity_framework_and_asnotracking/ https://docs.microsoft.com/en-us/ef/core/querying/tracking","link":"/entityframework-asnotracking-nedir/"},{"title":"Evrimsel Sürecin Simülasyonu – Genetik Algoritmalar – 1","text":"Selam arkadaşlar, bu makalemde birkaç aydır üzerinde araştırmalar yaptığım genetik algoritmalar hakkında edindiğim bilgileri sizlerle paylaşmak istedim. Genetik algoritamlar konusuna giriş yapmadan önce işi biraz daha temelden alarak “Algoritamanın” ne olduğu konusuna değinmek istiyorum. Bilgisayar bilimleri veya matematik bilimleri ile ilgilensek de ilgilenmesek de aslında algoritmalar hayatımız her yerinde. Günlük hayatımızda bilinçli veya bilinçsiz bir çok algoritmayı yerine getiririz. Bu algoritmalara en güzel örneği “yemek yapmak” eylemini gösterebiliriz. Yemek yaparken izlediğimiz tüm adımlar daha önceden belirlenmiş kurallar çerçevesinde ilerletilir. Bu bağlamda algoritma, en basit tanımıyla, bir problemin çözümünde izlenecek yol anlamına gelir. Algoritma sözcüğünün kökenine bakacak olursak; modern algoritmanın babası olarak anılan Türk bilim adamı El Harezmî, Cebir isimli kitabında algoritma çalışmalarından bahsetmiştir. Yazdığı kitap Avrupa dillerine de çevrilmiştir. Algoritma kelimesi, isminin Latin biçimi olan Algoritmi’ den türetilmiştir. Ayrıca ismi, İspanyolca ve Portekizce dillerinde basamak anlamına gelen guarismo ve algarismo kelimelerinin kökenini oluşturmaktadır. Algoritmayı oluşturan 3 temel bileşen vardır. Bunlar, değişkenler, algoritmanın kendisi olan mantıksal adımlar ve akış diyagramı. Bu ifadeleri açıklayacak olursak; değişken; değerlerin, yani verilerin tutulduğu-saklandığı elemanlar, mantıksal adımlar; algoritmanın adımları, akış diyagramı ise; mantıksal adımları görsel olarak ifade etme biçimi olarak tanımlayabiliriz. Örnek Akış Diyagramı Algoritma konusuna kısaca değindikten sonra makalemin asıl konusuna geçiş yapabiliriz. Bir problemin çözümünde gözlem yapmak problemin çözüm gidişatını olumlu yönde etkiler. Bilim insanları da bazı mantıksal sorunların çözümüne gözlem yaparak ulaşmışlardır. Bu çözüm yöntemlerine örnek verecek olursak; tavlama benzetimi, tabu arama algoritması, karınca kolonisi algoritması, genetik algoritmalar vb. *Tavlama Benzetimi (Simulated Annealing): *Katıların ısıtılması ve sonra kristalleşmeye kadar yavaş yavaş soğutulması esasına dayanan bir algoritmadır. Kirkpatrick ve arkadaşları tarafından 1983 yılında önerilmiştir. Sıcaklık değeri, elde edilen en iyi çözümden daha kötü bir çözümün kabul edilme olasılığını belirlemek için kullanılır. Tabu Arama (Tabu Search): Bu algoritma Glover tarafından 1986 yılında geliştirilmiştir. Yerel optimum tuzaklarından kaçarak global optimumu bulan yüksek seviyeli bir sezgisel yöntemdir. Karınca Kolonisi Algoritması (Ant Colony Algorithm): Karıncaların yuvaları ile yiyecek noktaları arasındaki en kısa yolu bulma kabiliyetlerinden esinlenilerek geliştirilmiştir. Alternatif birçok yolun söz konusu olduğu durumlarda karıncalar, öncelikle bu yollara eşit olasılıkla dağılırlarken belli bir süre sonra en kısa olan yolda yoğunlaşmaktadır. Genetik Algoritmalar, John Holland tarafından 1975 yılında, Charles Darwin’ in doğal evrim teorisinden esinlenilerek geliştirilmiştir. Bu algoritma, bir sonraki kuşağın yavrularını üretmek için en iyi bireylerin üreme için seçildiği doğal seleksiyon sürecini yansıtmaktadır. Geleneksel yöntemlerle çözümü çok zor olan veya imkansıza yakın olan problemlerin çözümünde kullanılmaktadır. Mühendislik alanında daha çok optimizasyon amaçlı kullanılmakta ve diğer geleneksel yöntemlere göre daha iyi sonuç vermektedir. Genetik algoritmanın genel işleyişini iyi anlamak için öncelikle evrimsel süreci iyi anlamak gereklidir: Evrim, canlı türlerinin yani bir popülasyon içerisindeki her bir bireyin nesilden nesile kalıtsal değişime uğrayarak, ortamlara adaptasyonlarını sağlayan “en iyi“leştirme sürecidir. Bireylerin geçirdiği bu değişimler, bireylerin hayatları boyunca geçirdiği değişimler değildir, evrimsel süreç içerisinde nesillerde meydana gelen değişimlerdir. Evrimin temel dayanağı en iyinin hayatta kalması prensibidir. En iyi olamayan bireyler üreyemezler ve yok olurlar. Bu gidişatın sonucunda en iyilere sahip bir popülasyon meydana gelir. Genetik algoritmanın genel evrim ilkeleri dışında belirgin standartları yoktur. Algoritma probleme göre bazı değişikliklere uğrayabilir. Örneğin; bireyin en iyi olup olmadığını (“en iyi” ifadesi görecelidir) kontrol etme tekniği probleme göre farklılık gösterebilir. Genetik algoritma evrimsel süreci bilgisayar ortamında taklit eder. Tek bir çözüm geliştirilmesi yerine, çözümlerden meydana gelen bir küme oluşturur. Çözümlerden meydana gelen bu kümeye genetik algoritma jargonunda popülasyon veya nüfus olarak adlandırılır. Bir popülasyon vektör, kromozom veya birey adı verilen sayı dizilerinden oluşur. Birey içindeki her bir elemana gen adı verilir. Popülasyonda yer alacak olan bireylere, evrimsel süreç doğrultusunda genetik algoritma işlemleri belirler. Genetik algoritma kapsamında temel 3 işlem (operatör) vardır. Bunlar; çaprazlama (crossover), mutasyon (mutation) ve *seçilim (selection) *işlemleridir. Genetik algoritmada kullanılan temel kavramları açıklayacak olursak; Gen: Genetik bilgi taşıyan en küçük yapıdır. Kromozom: Genlerden meydana gelen diziye kromozom denir. Her bir kromozom, olası çözümleri gösterirler. Popülasyon: Kromozomlardan meydana gelmiş topluluğa denir. Her bir popülasyon, alternatif çözüm kümesidir. Bir sonraki makale: Genetik Algoritmada Kullanılan Operatörler","link":"/evrimsel-surecin-simulasyonu-genetik-algoritmalar-1/"},{"title":"Geliştiriciler İçin Offline Dokümantasyon – Zeal","text":"Zeal – Offline Documentation Browser programı ile offline olarak dokümantasyon ihtiyacınızı giderebilirsiniz. Zeal, şuan 195 yazılım teknolojisinin dokümantasyonunu offline olarak sunmakta. İsterseniz masaüstü uygulamasını indirmek yerine kullandığınız IDE üzerine plugin olarak ekleme şansınız da var. IDE Pluginler de şunlar; Atom: https://atom.io/packages/dashBrackets: https://github.com/anephew/brackets-zealEmacs: https://github.com/jinzhu/zeal-at-pointIntelliJ IDEA: https://plugins.jetbrains.com/plugin/7351?pr=ideaKTextEditor (Kate, KWrite, KDevelop, Kile, etc): https://github.com/g3ar/ZealSearchSublime Text: https://github.com/vaanwd/ZealVIM: https://github.com/KabbAmine/zeavim.vim","link":"/gelistiriciler-icin-offline-dokumantasyon-zeal/"},{"title":"Github Pages Custom Domain","text":"Daha önceki yazım Github Pages ile Geliştiricilere Ücretsiz Blog üzerineydi. Bu yazımda da {kullanıcı adım}.github.io şeklinde olan alan adını istediğimiz bir alan alan adı ile açmayı anlatacağım. Almış olduğumuz alan adının yönetim ekranından 2 adet A kaydı oluşturmamış gerekiyor. A kayıtlarının ikisine de alan adımızı yazıyoruz. Ip adreslerine ise Github Pages Custom Domain IP‘lerini yazmamız gerekiyor. Github Pages Cutom Domain IPs 192.30.252.153 192.30.252.154 Örnek A kaydı şu şekilde olacak: mht.ist – 192.30.252.153 mht.ist – 192.30.252.154 A kaydını tamamladıktan sonra Daha önce oluşturduğumuz Github çalışma alanımıza gidip yeni bir dosya oluşturuyoruz. Dosyanın adına CNAME yazıyoruz. İçeriğine ise kendi alan adımızı yazıyoruz. Ve artık bloğumuza {kullanıcı adım}.github.io şeklide erişmek yerine direkt kendi belirlediğimiz alan adı ile erişiyoruz. Benim alan adım mht.ist.Burayı blog gibi değil de not defteri gibi kullanmaya çalışacağım. Belki ilerde sadece onu kullanırım. Github Pages hakkında daha detaylı dökümantasyon için şu adrese gidebilrisiniz. Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/github-pages-custom-domain/"},{"title":"Github Pages ile Geliştiricilere Ücretsiz Blog","text":"Geliştiriciler için basit ve hızlı blog oluşturma.Geliştirici olan herkesin hayalidir bir blog tutmak. Jekyll ile bu çok kolay. Bu yazımda, Github üzerinde HTML sayfası nasıl görüntülenir? Jekyll nedir? Jekyll Nasıl kurulur? Jekyll Projesi Nasıl Oluşturulur? Nasıl yayınlanır? konuları üzerinde duracağım. Github Üzerinde HTML Sayfası Nasıl Görüntülenir?İlk olarak Github hesabımıza giriş yaptıktan sonra New repository butonuna basarak yeni bir çalışma alanı oluşturalım. New repository butonuna bastığımızda aşağıdaki Create a new repository sayfası açılacak. Bu sayfadan projemizin adını {kullanıcı adım}.github.io şeklinde veriyoruz. İsterseniz README dosyasını da ekleyebilirsiniz. Sonra Create repository butonuna bastığımızda yeni çalışma alanımız oluşmuş olacak. Github Pages’ ın yayına girip girmediğini kontrol etmek için çalışma alanının ayarlarına göz atmamız gerekiyor. Ayarlar sayfasına girdiğimizde **Github Pages** alanında aşağıdaki resimde olduğu gibi gözüküyorsa Github Pages başarıyla yayına girmiştir. Bu bağlantıya tıkladığımız zaman 404 sayfası ile karşılaşacağız. Çünkü index.html dosyası oluşturmadık. Index.html dosyası oluşturmak için çalışma alanımıza geri dönüp Create new file butonuna basarak yeni bir dosya oluşturalım. Açılan sayfadan dosyamızın adını index.html olarak belirledikten sonra içeriğine bir şeyler yazalım. Index.html dosyasının içeriğini hallettikten sonra aynı sayfanın hemen altında yer alan Commit new file butonuna tıklıyoruz. Index.html sayfamız oluştuğuna göre artık Github sayfamızı tekrar kontrol edebiliriz. Eğer oluşturduğunuz index.html dosyası görüntülendiyse doğru yoldasınız. Buraya kadar hiçbir sorun yaşamadan geldiyseniz devam edebiliriz. Jekyll Nedir?Jekyll, Ruby ile yazılmış bir uygulamadır. Basit ama güçlü bir alt yapıya sahip statik site oluşturucusudur. Markdown veya Textile formatında yazdığınız sayfayı statik HTML sayfasına dönüştürür. Jekyll Nasıl Kurulur?Dikkat! Ben Windows kullandığım için Windows kurulumunu baz alıyorum. İlk olarak Ruby‘yi indirip kurmamız gerekiyor. www.ruby-lang.org/tr/downloads Ruby’yi kurduktan sonra RubyGems‘i kurmamız gerekiyor. rubygems.org/pages/download Kurulumun başarılı olup olmadığını anlamak için Komut Satırını (Nam-ı diğer Cemede) açıyoruz. Ruby için aşağıdaki komutu yazıyoruz. 1ruby -v Eğer versiyon numarası gözükürse başarıyla yüklenmiştir Aynı durum RubyGems için de geçerli. Bunun için de aşağıdaki komutu yazıyoruz. 1gem -v Versiyon numarasını gördüysek sıkıntı yok. Ruby’yi ve RubyGems’i yükledikten sonra şimdi sıra Jekyll‘in yüklenmesine geldi. Bu sefer komut satırına aşağıdaki komutu yazıyoruz. 1gem install jekyll Jekyll’in yüklenmesi tamamlandığında yine versiyon kontrolü ile yüklenme durumuna bakabilirsiniz. Bütün kurulumları tamamladık. Şimdi Jekyll ile ilk blogumuzu oluşturmaya hazırız. Jekyll Projesi Nasıl Oluşturulur?Yeni boş bir klasör açıp içerisinde komut satırını çalıştıralım ve aşağıdaki komutu çalıştıralım. 1jekyll new {proje adı} Projemiz oluştuktan sonra projemizin bulunduğu dizine geçelim. 1cd {proje adı} Projemizin bulunduğu dizine geçtikten sonra localhost üzerinde test edebiliriz. Bunun için yine komut satırına aşağıdaki komutu yazalım. 1jekyll serve Bu komutu yazdığımızda localhost:4000 adresinden projemizin çalışır halini görebiliriz. Projemizi oluşturduk. Şimdi sırada Github üzerindeki çalışma alanına atmak kaldı. Nasıl yayınlanır?Oluşturduğumuz Jekyll projemizi Github çalışma alanımıza atmak için Github Desktop uygulamasını indirip kurmamız gerekiyor. desktop.github.com Github Desktop uygulamasını kurduktan sonra Github üzerindeki projemize giderek Clone or download butonuna tıklayıp açılan yerden Open in Desktop butonuna tıkladığımızda Github Desktop uygulaması devreye girecek ve çalışma alanımızı nereye oluşturacağını seçtikten sonra çalışma alanımızın kendi diskimize klonlandığını göreceğiz. Jekyll projemizi klonladığımız Github çalışma alanına kopyala yapıştır yaptıktan sonra Commit ediyoruz. Commit ve Sync işlemlerini tamamladıktan sonra projemizin {kullanıcı adım}.github.io adresinden çalışıp çalışmadığını kontrol edebiliriz. Bu yazım da burada son bulsun. Bir sonraki yazımda {kullanıcı adım}.github.io şeklinde olan adresi istediğimiz bir alan adı ile açma yani Custom Domain üzerine olacak. Github Pages Custom Domain üzerine yazdığım yazımı da okumak ister misin? Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/github-pages-ile-gelistiricilere-ucretsiz-blog/"},{"title":"Javascript Function All Parameters Is Empty","text":"Bir fonksiyondaki parametrelerin hiçbiri girilmediyse bunun kontrolünü ES ile halledebiliriz. 123456function Test(a,b,c,...){ if(arguments.length === 0){ //Hiçbir paremetre girilmemiştir. //Tek tek sorgulamaya gerek kalmaz }}","link":"/javascript-function-all-parameters-is-empty/"},{"title":"Javascript Function Parameter Set Default Value","text":"Bir fonksiyonun parametresine varsayılan değeri aşağıdaki gibi atıyoruz. 123456789101112131415function Hello(name){ var name = name || 'Mehmet'; Console.log('Hello ' + name);}Hello();Hello('Emin');Hello(0);/*Result:-&gt; Hello Mehmet-&gt; Hello Emin-&gt; Hello Mehmet */","link":"/javascript-function-parameter-set-default-value/"},{"title":"Javascript Self Invoking Functions","text":"Javascript ile oluşturduğumuz bir fonksiyonu otomatik olarak çağırma. 1234567891011//Normal çağırmavar test = function(name){ return ('Hello ' + name);};test('Mehmet'); //Otomatik çağırmavar test = function(name){ return ('Hello ' + name);}('Mehmet');","link":"/javascript-self-invoking-functions/"},{"title":"Jquery Only Parent Click","text":"Jquery ile sadece parent elemente tıklama eventı ekleme. 1234567891011//Sadece Html elementine tıklandığında işlem yapar.$('#outer').click(function(e) { if (e.target === this){ console.log('Parent'); }});//Html elementinin kendisine tıklanmadıysa işlem yapmadan dön.$('#outer').click(function(e) { if(e.target != this) return;});","link":"/jquery-only-parent-click/"},{"title":"jQuery Video Extend","text":"Videolara logo ve duraklama noktaları ekleyebileceğiniz, youtube üzerinden veya flv dosyalarında video oynatmamızı sağlayan bir jQuery eklentisi. Örnek Çalışma Detayları","link":"/jquery-video-extend/"},{"title":"MSSQL Server 2014 LocalDB Connection String","text":"Eski projelerimin bazılarında SQL Server 2012 kullanarak LocalDB bağlantısını (LocalDB)\\v11.0 şeklinde yaparak gerçekleştiriyordum. SQL Server 2014 te ise bu bağlantı şekli değişmiş ve artık (LocalDB)\\MSSQLLocalDB olarak bağlantıyı sağlayabildim. Örnek connection stringler şu şekilde; SQL Server 2012 LocalDB Connection String 123&lt;connectionStrings&gt; &lt;add name=\"DBContext\" connectionString=\"Data Source=(LocalDB)\\\\v11.0;AttachDbFilename=|DataDirectory|\\\\Database.mdf;Integrated Security=True;\" providerName=\"System.Data.SqlClient\" /&gt;&lt;/connectionStrings&gt; SQL Server 2014 LocalDB Connection String 123&lt;connectionStrings&gt; &lt;add name=\"DBContext\" connectionString=\"Data Source=(LocalDB)\\\\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\\\\Database.mdf;Integrated Security=True;\" providerName=\"System.Data.SqlClient\" /&gt;&lt;/connectionStrings&gt; Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/mssql-server-2014-localdb-connection-string/"},{"title":"MSSQL Server Türkçe Karakter Destekli Veritabanı Oluşturmak","text":"Türkçe karakter destekli veritabanı için aşağıdaki SQL kodlarını kullanmanız yeterli olacaktır. 123ALTER DATABASE veritabani_adi SET SINGLE_USER WITH ROLLBACK IMMEDIATEALTER DATABASE veritabani_adi COLLATE TURKISH_CI_ASALTER DATABASE veritabani_adi SET MULTI_USER Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/mssql-server-turkce-karakter-destekli-veritabani-olusturmak/"},{"title":"Nesne Yönelimli Tasarım Prensipleri – SOLID - 1","text":"Merhaba yazılımı seven ve gönül veren değerli arkadaşlar, bu blog yazımın konusu nesne yönelimli programlamada “olmazsa olmaz” diyemem ama “olması gereken” teknikler üzerinde duracağım. Yazılım camiasında standart haline gelmiş SOLID prensipleri olarak anılan beş teknikten bahsedeceğim. Robert Cecil Martin’in (Nam-ı diğer Uncle Bob) sunumu ile yaygınlaşmaya başlayan SOLID, bir Dependency Managament (Bağımlılık Yönetimi) biçimidir. Uncle Bob ayrıca, 2000 senesinde Kent Beck ve 15 arkadaşı ile Agile Manifestonun oluşturulmasında yer almıştır. SOLID, Single Responsibility, Open Closed, Liskov Substitutio, Interface Segregation, Dependency Inversion prensiplerinden oluşur. Bu prensiplerin kullanılmasındaki temel amaç esnek ve geliştirilmesi kolay yazılımlar oluşturmaktır. Eğer bu prensipleri sadece uygulamış olmak için yaparsak kompleks bir yapı oluşacaktır. Bu yüzden projenin böyle bir şeye ihtiyacı olup olmadığını iyi analiz etmemiz gerekir. Yazılım geliştirmede amaç her zaman en basit yöntemler kullanarak, sade ve esnek yapılar oluşturmak olmalıdır. Yerine göre SOLID’i kullanıp kullanmamak bize kalmıştır. Bağımlılık seviyesi yüksek kötü tasarlanmış projelerin benzer üç özelliği vardır: (Rigidty) Esnek değillerdir. Geliştirmelere ve yeni eklentilere kapalıdırlar. (Fragility) Kırılgandırlar. Projenin herhangi bir yerinde yapacağım bir değişiklik başka yerleri etkiler. (Immobilty) Sabittirler. Tekrar kullanıma uygun değillerdir. Bu kötü tasarımı SOLID ile ortadan kaldırabiliriz. Bir sonraki yazım SOLID’in S’si olan Single Responsibility Principle (SRP) – Tek Sorumluluk Prensibi Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/nesne-yonelimli-tasarim-prensipleri-solid-1/"},{"title":".Net Projelerinde Otomatik Versiyonlama","text":"Yeni bir .Net projesini Visual Studio ortamında oluşturduğumuzda projenin özellikleri altında AssemblyInfo adlı bir dosya da varsayılan olarak oluşturulmaktadır. Bu dosyada projenin derleme bilgileri (projenin adı, versiyon bilgileri gibi) tutulur. Biz de bu dosyada yer alan AssemblyVersion özelliğine, SVN revision numarasını otomatik atayacağız. Öncelikle .Net projelerinde versiyonlama standartını görelim; Versiyon ({Major}.{Minor}.{Build Number}.{Revision}) şeklindedir. Major Version: Büyük yeniliklerde manuel olarak artırılır.Minor Version: Küçük değişikliklerde manuel olarak artırılır.Build Number: Derme numarası otomatik olarak atanacak.Revision: Her commit sonrası SVN tarafından otomatik gelen değer. Kısa bir açıklamadan sonra şimdi işe koyulabiliriz. Versiyonlama sistemi için açık kaynak kodlu olan MSBuild Community Tasks kütüphanesini kullanacağız. Nuget: 1PM&gt; Install-Package MSBuildTasks Paketi ekledikten sonra projemizin .csproj dosyasını açıp aşağıdaki özellikleri eklemeliyiz. Not: Kullandığımız SVN programının bulunduğu yolu belirtmeliyiz ve SVN programının tam yüklü olması gereklidir. Projemizi derlediğimiz zaman AssemblyVersion bilgisinin x.x.x.Revision şeklinde olduğunu göreceğiz. Bu yazı da bu kadar olsun artık. Kısa ve öz. 🙂 Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/net-projelerinde-otomatik-versiyonlama/"},{"title":"Oracle Query – Get Version","text":"Oracle veritabanında hangi sürümün kullanıldığını merak ettim ve bunu buldum: 1SELECT * FROM V$VERSION","link":"/oracle-get-version-query/"},{"title":"Single Responsibility Principle (SRP) – Tek Sorumluluk Prensibi - 2","text":"Bir önceki blog yazımda Nesne Yönelimli Tasarım Prensipleri – SOLID üzerinde durmuştuk. Bu yazımda ise SOLID’in S’si olan Single Responsibility Principle (SRP) – Tek Sorumluluk Prensibi üzerinde duracağım. Single Responsibility Principle (SRP) – Tek Sorumluluk Prensibi Bir sınıfın veya metodun sadece bir sorumluluğu vardır. Bu sayede bir değişiklik yapacağımız zaman sadece bir nedenimiz olur. Peki bu ne anlama geliyor? Resimde birden fazla işi yapan bir alet (çakı) görüyorsunuz. Bu aletin o kadar fazla sorumluluğu var ki, yeni bir sorumluluk eklemek istediğimde ya da kırılan bir parçayı değiştirmek istediğimizde yapısına müdahale etmem gerekecek. Eğer alet sadece bıçak olsaydı ya da tornavida, yani tek bir sorumluluğu olmuş olsaydı, kırılan kısmını kolay bir şekilde değiştirebilecektim. Belki yerden tasarruf edemezdim ancak zamandan tasarruf edeceğim ortada. Yazılım geliştirmede amaç her zaman en basit yöntemler kullanarak, sade ve esnek yapılar oluşturmaktır, demiştik. Yazılımsal açıdan bakarsak nasıl bir sonuca ulaşırız? Bir sınıfımız olsun ve bu sınıfın içerisinde Allah ne verdiyse yazdığımızı düşünelim. Bir süre sonra kodun binlerce satıra ulaştığını görüyoruz. Editör bile kodları gösterirken kasılır. Bir yeri değiştirmek canımıza okur ve geçmiş yazılımcılara sevmeler başlar. Seve seve biz de aynı şeklide kodumuzu yazarız. Sonuç; büyük ve karmaşık ve yönetimi zor kodlar, kırılgan ve esnek olmayan bir yapı. Yalnızca kendi sorumluluğunu yerine getirecek şekilde parçalara bölseydik bu sonuç ile karşılaşmayacaktık. Örnek C# kodu: 12345678910111213141516171819202122public class FullStackDeveloper{ public void WriteCSharpCode() { Console.WriteLine(\"I can write C#.\"); } public void WriteSQLCode() { Console.WriteLine(\"I can write SQL.\"); } public void WriteJavaScriptCode() { Console.WriteLine(\"I can write JavaScript.\"); } public void WriteCSSCode() { Console.WriteLine(\"I can write CSS.\"); }} “FullStackDeveloper” sınıfımız C#, SQL, JavaScript ve CSS kodu yazabilen bir yazılım geliştiricisini temsil etsin. Tek bir geliştiriciye bu kadar işin yüklenmesi geliştiricinin hata yapma olasılığını yükseltecektir. Çünkü, bir yerden sonra kafa çorbası içilmeye hazır hale gelecektir. Olması gereken ise aslında şudur: 12345678910111213141516171819202122232425262728public class BackEndDeveloper{ public void WriteCSharpCode() { Console.WriteLine(\"I can write C#.\"); }}public class FrontEndDeveloper{ public void WriteJavaScriptCode() { Console.WriteLine(\"I can write JavaScript.\"); } public void WriteCSSCode() { Console.WriteLine(\"I can write CSS.\"); }}public class SQLDeveloper{ public void WriteSQLCode() { Console.WriteLine(\"I can write SQL.\"); }} Kısacası, herkes kendi işini yapmalıdır! Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/single-responsibility-principle-srp-tek-sorumluluk-prensibi-2/"},{"title":"SQL Bir Tablonun Aynısını Oluşturma","text":"Bir tablonun aynı kolonlara sahip bir kopyasını oluşturmak istersek yazmamız gereken sorgu şu şekilde: 1select top 0 * into table2 from table1 Bu sorgu ile table1 tablosunun aynısını table2 ismiyle oluşturur.","link":"/sql-bir-tablonun-aynisini-olusturma/"},{"title":"SQL Create Temp Table Declare","text":"Temp tablo oluşturmak için bir yöntem. 12345DECLARE @TempTable TABLE( test1 INT, test2 NVARCHAR(MAX), test3 NVARCHAR(MAX))","link":"/sql-create-temp-table-declare/"},{"title":"Sql Execution Timing","text":"MSSQL 2008 ve üzeri sorgu süresini hesaplama 12345Declare @StartTime DateTime = GetDate()-- my SQL callsPrint 'Time taken was ' + cast(DateDiff(millisecond, @StartTime, GetDate()) as varchar) + 'ms'","link":"/sql-execution-timing/"},{"title":"SQL Trigger Toplu Update Sorunu","text":"Bazen triggerlarda where kullandığımız sorgular varsa, bu sorgular toplu update işlemi sırasında hata oluşturuyor. Where yerine Join kullanmak sorunu çözebilir.","link":"/sql-trigger-toplu-update-sorunu/"},{"title":"SQL – Update İle Daha Performanslı İşlem Yapma","text":"Bir sorgu içerisinde herhangi bir kolunun değerini bir fonksiyon ile düzenleyip basarsak performans kaybı olur. Ancak ilk olarak kolona varsayılan değerini basıp daha sonra toplu bir update çekersek gözle görülür performans artışı olur. 123UPDATE upb SET upb.yas = Hesapla(yas) FROM TempTable_UyeProfilBilgileri upb","link":"/sql-update-ile-daha-performansli-islem-yapma/"},{"title":"Stored Procedures and Tables Last Modify Date","text":"MSSQL sys.objects tablosundan üzerinde değişiklik yapılma tarihlerine göre tabloları ve stored proceduresleri listeleme sorgusu. U ile ifade edilenler tablo, P ile ifade edilenler ise SP. 1234SELECT name, create_date, modify_date, typeFROM sys.objectsWHERE type = 'U' OR type = 'P'ORDER BY modify_date DESC","link":"/stored-procedures-and-tables-last-modify-date/"},{"title":"TypeItJs – Harf Harf Animasyonlu Yazım Kütüphanesi","text":"Az önce internette dolaşırken karşıma çıkan, hoşuma giden webmaster araçlarını, kütüphanelerini, hem unutmamak hem de sizlerle paylaşmak için fazla açıklama yapmadan paylaşmaya karar verdim. Bu kategorinin ilk kütüphanesi TypeItJs. Harf harf animasyonlu yazı yazmamızı sağlayan güzel bir kütüphane. TypeItJs – Hemen İncele…","link":"/typeitjs-harf-harf-animasyonlu-yazim-kutuphanesi/"},{"title":"Visual Studio ile SVN Kullanımı","text":"VisualSVN kurulumu ve kullanımı hakkında.Bir önceki yazımda Dropbox Üzerine SVN Kurulumundan bahsetmiştim. Bu yazımda da söz verdiğim üzere Visual Studio ortamındayken projenizde değişiklik yaptığınız alanları göstererek commit etminizi sağlayan VisualSVN eklentisinin kurulumunu ve kullanımını anlatacağım. VisualSVN 5.1.4 sürümü ile Visual Studio 2015 e kadar destekliyor. VisualSVN eklentisini indirmek için bu linke tıklayın. www.visualsvn.com İndirme ve kurulum işlemleri bittikten sonra Visual Studio’ yu açtığımız pencerenin üstünde VisualSVN menüsünü gördüğümüzde kurulum başarılı olmuş demektir. Daha önce oluşturduğumuz SVN klasörünün içerisine herhangi bir yeni proje oluşturalım. Oluşturduğumuz anda VisualSVN projenin SVN klasörü içerisinde yer aldığını anlayarak Solution Explorer‘ da değişiklik olan dosyaların sol tarafına bir simge atarak o dosyanın commit edilebilir olduğunu gösteriyor. Projemize sağ tıklayıp commit dediğimizde bütün proje commit edilmiş olur. Eğer sadece çalıştığınız dosyayı commit etmek istiyorsanız o dosyaya sağ tıklayıp aynı işlemleri yaptığınızda commit işlemi gerçekleştiriliyor. Olur ya bir gün görüşemezsek iyi günler, iyi akşamlar ve iyi geceler…","link":"/visual-studio-ile-svn-kullanimi/"},{"title":"Stryker Mutator ile Mutation Testing ve Azure Pipelines Entegrasyonu","text":"Yazmış olduğumuz bir unit testin kalitesini anlamak için, testi yazılan kod parçacığı üzerinde değişiklikler yaptığımızda, unit testin sonucuna bir etkisi olup olmadığını analiz ederek kalitesini ve kapsamını kontrol edebiliriz. Bu şekilde yapmış olduğumuz işleme bir nevi “testin testini yapmak” diyebiliriz. Bu yapılan işleme Mutation Testing denilmektedir. Kod parçacıklarının mutasyona uğratılması sonucunda kalite ve kapsam analizi yapılmaktadır. Yeni unit testler yazmak ve mevcut unit testlerin kalitesini değerlendirmek için Mutation Testing yapılmalıdır. Mutation Testing, bir kod parçacığını küçük şekillerde değiştirmeyi amaçlar. Bu değişiklikler, aritmetik operatör, eşiklik veya mantıksal ifadelerin değiştirilmesi gibi işlemlerdir. Değişikliklerin sonucunda oluşan her bir yeni kod parçacığına “Mutant” denilir. Burada beklenilen durum, unit test çalıştığı zaman oluşan mutantın ölmesidir. Eğer mutant ölmez ise unit testimizin kapsamadığı bir durum var demektir. Kod parçacığı üzerinde ileride yapılacak bir değişiklik muhtemelen unit testimizi etkilemeyecektir. Mutation Testing manuel olarak yapılabileceği gibi otomatik olarak araçlar kullanılarak da yapılabilir. Mutation Testing temelde 3 türe ayrılabilir. Bunlar; ifade mutasyonu (statement mutation), karar mutasyonu (decision mutation) ve değer mutasyonudur (value mutation). BilgiMutation Testing ilk olarak Richard Lipton tarafından 1971’de önerildi. Bir Mutation Testing aracının ilk uygulaması, 1980 yılında Timothy Budd tarafından yapıldı. Otomatik olarak Mutation Testing yapmamızı sağlayan araçlardan bir tanesi Stryker Mutator’dır. Stryker Mutator ile kod parçacıklarını mutasyona uğratarak yani değiştirerek mutation testing işlemini yapmamızı kolaylaştıran bir araçtır. Bu araç sayesinde, daha kaliteli ve dayanıklı, kapsamı geniş unit testler yazabiliriz. .NET desteği ile CLI üzerinden testimizi analiz ettirebiliriz. Bir diğer araç ise PIT Testing. PIT Testing ile SonarQube üzerinden de analiz sonuçlarını görebiliriz. Stryker Mutator ile de Azure Pipelines entegrasyonu sayesinde SonarQube ihtiyacı olmadan da analiz sonuçlarını görmemiz mümkün. İşin hikaye kısmını çok fazla uzatmadan artık örneğimize geçelim: Stryker Mutator Kurulumu ve Kullanımı Projemizin solution yapısı Basit matematiksel işlemler yapan, Calc isimli bir class oluşturalım. Şimdilik sadece toplama işlemini eklememiz yeterli olacaktır. Unit Test Case’i oluşturmak amacıyla “Validate” isimli bir metod yazarak sadece pozitif tamsayılar üzerinde işlem yapılmasını sağladım. NUnit kullanarak unit test yazacağız. 12345678910111213141516public class Calc{ public double Sum(int x, int y) { Validate(x, y); return x + y; } public void Validate(int x, int y) { if (x &lt; 0 || y &lt; 0) { throw new ArgumentException(\"Only positive integers can be used.\"); } }} Aşağıda da Calc clasımız için yazdığımız unit testleri görebilirsiniz. 123456789101112131415161718192021public class CalcTest{ Calc _testClass; [SetUp] public void Setup() { _testClass = new Calc(); } [TestCase(0, 0, 0)] [TestCase(1, 0, 1)] [TestCase(1, 1, 2)] [TestCase(2, 1, 3)] [TestCase(9, 4, 13)] public void SumTest(int x, int y, int expectedResult) { var actualResult = _testClass.Sum(x, y); Assert.AreEqual(expectedResult, actualResult); }} Test Explorer üzerinden unit testlerimizi çalıştırdığımızda oluşan 5 case için tüm testlerin başarılı olduğunu gördük. Buraya kadar olan kısım standart unit test geliştirme adımlarıydı. Siz de basit bir proje üzerinden denemeler yapabilirsiniz. Şimdi sıra geldi Stryker Mutator kurulumuna. Stryker Mutator kurulumunu gerçekleştirebilmek için 2 yöntem var. Bunlardan bir tanesi Nuget ile kurulumu diğeri ise .NET CLI üzerinden kurulumudur. Ben CLI üzerinden kurulumu tercih ettim. Global yükleyerek de tüm tüm projelerimde kullanıma hazır hale getirmiş oldum. Tabi bunun için “dotnet CLI” bilgisayarımızda yüklü olmalı. Aşağıdaki komut ile Stryker Mutator global olarak bilgisayarıma yükleyebiliriz. 1dotnet tool install -g dotnet-stryker Kurulumdan sonra dotnet-stryker komutu ile sağlamasını yapabiliriz. Stryker Mutator’ı kullanıma hazır hale getirdikten sonra unit testlerimiz üzerinde analiz yapmaya başlayabiliriz. Stryker Mutator, Unit Test projemizin bulunduğu dizinde çalıştırılmalıdır. Bu sayede ekstra parametreler girmek zorunda kalmayız. Developer Powershell’i Unit Test projemizin bulunduğu dizini göstererek başlatalım. Bundan sonrası ise çok kolay, sadece dotnet-stryker komutunu yazıp Enter tuşuna bastığımızda mutasyon işlemlerini başlatmış oluruz. Mutasyon işlemleri bittiğinde ise yukarıdaki gibi bir ekran görüntüsü ile karşılaşırız. Burada toplan test case’i, oluşturulan mutant sayısını ve bizim için daha önemli olan mutasyon skorunu ve rapor çıktısını görüyoruz. Örneğin, Calc sınıfımız için yazdığımız unit testler için mutasyon skoru %75 olarak belirlenmiş. Bu da şu demek oluyor: oluşturulan 8 mutanttan 6 tanesini yazmış olduğumuz unit testler öldürdü. Aşağıda da oluşturulan html formatındaki raporun ekran görüntüsünü görebilirsiniz. “Calc.cs” sayfasını açtığımızda, 6 mutantın öldüğünü, 1 tanesinin hayatta kaldığını ve 1 tanesinin de kapsanmadığını görmekteyiz. Şimdi sırayla bu sorunları çözelim: 1. Kodun Unit Test ile kapsanmasını sağlayalım: Kodumuzu incelediğimizde 15.satırdaki şartı sağlayan x veya y değeri sıfırdan küçük gönderilirse 17.satırın kapsanmasını sağlayabiliriz. Bunun için &quot;Sum&quot; metodu üzerinden unit test yazabileceğimiz gibi &quot;Validate&quot; metodu için ayrı bir unit test de yazabiliriz. Ben daha anlaşılır olması adına ayrı metod yazmayı tercih ettim.123456[TestCase(-1, -1)]public void Validate_Only_Positive_Integers_Test(int x, int y){ var exception = Assert.Throws(Is.TypeOf&lt;ArgumentException&gt;(), () =&gt; _testClass.Validate(x, y)); Assert.AreEqual(\"Only positive integers can be used.\", exception.Message);} Validate metodunu incelediğimizde x veya y değişkenlerinin negatif gelmesi durumunda exception fırlattığını görürüz. Unit Test’imizde de ArgumentException gelmesini ve mesajın da beklenilen içeriğe sahip olmasını kontrol etmiş olduk. Eğer mesajın değerini kontrol etmezsek yeni bir mutantın oluşmasına neden oluruz. Tekrar dotnet-stryker komutu ile rapor aldığımızda durum aşağıdaki gibi olacaktır: Gördüğünüz üzere artık kapsanmayan kodumuz kalmadı ancak mutantı hala öldüremedik. 2 Hayatta kalan mutantı öldürelim: Yukarıda ekran görüntüsünde gördüğünüz 1 numaralı kırmızı kutu simgesine tıkladığımızda aşağıdaki gibi gözükecektir. Burada oluşturulan mutant ile mantıksal operatör değiştirilmiş ve bu değişikliğe rağmen unit testimiz hiçbir sorun çıkarmadan çalışmış. Bu da bizim istediğimiz bir durum değil. “Validate” metodu için yazmış olduğumuz Unit Test’imizin TestCase’inde x ve y değişkenlerine -1 göndermiştik. Ancak mantıksal operatör değiştiğinde x ve y değişkenlerine göndermiş olduğumuz -1 değeri oluşan mutantın hayatta kalmasına neden olmaktadır. Test Case’ler arasına x ve y değişkenlerine sırasıyla (-1,-1) - (-1,1) ve (1,-1) değerlerini gönderdiğimizde, mantıksal operatör değişikliğinden ortaya çıkan mutantın ölmesini sağlayacaktır. 12345678[TestCase(-1, -1)][TestCase(1, -1)][TestCase(-1, 1)]public void Validate_Only_Positive_Integers_Test(int x, int y){ var exception = Assert.Throws(Is.TypeOf&lt;ArgumentException&gt;(), () =&gt; _testClass.Validate(x, y)); Assert.AreEqual(\"Only positive integers can be used.\", exception.Message);} Unit Test’mizin son hali yukarıdaki gibi olacaktır. Bu değişiklikler sayesinde kod ileride parçacığı üzerinde yapılacak değişikliklerin Unit Test’lerimizi etkileme ihtimalini artırmış oluyoruz. Yeniden dotnet-stryker komutunu çalıştırdığımda artık tüm mutantların öldürüldüğünü görebiliriz. Şimdi de son dokunuşları yapalım artık :) Azure Pipelines üzerinde, Stryker Mutator ile almış olduğumuz raporu CI sürecinde görmemizi sağlayalım. Azure Pipelines EntegrasyonuBurada pipeline sürecinin halihazırda olduğunu varsayarak anlatmaya çalışacağım. Stryker Mutator’dan rapor alabilmek için aşağıdaki gibi 3 agent job tanımının olması gerekiyor. İlki Stryker Mutator kurulumunu, ikincisi çalıştırılması ve üçüncüsü de oluşturulan raporun publish edilmesi. Bu üç adımın YAML içerikleri şu şekilde olmalıdır: 1. Install dotnet-stryker 1234567steps:- task: DotNetCoreCLI@2 displayName: 'Install dotnet-stryker' inputs: command: custom custom: tool arguments: 'install dotnet-stryker --tool-path $(Agent.BuildDirectory)/tools' 2. Run dotnet-stryker 1234steps:- powershell: '$(Agent.BuildDirectory)/tools/dotnet-stryker' workingDirectory: StrykerMutatorSample.Calc.Test displayName: 'Run dotnet-stryker' 3. Publish Mutation Test Report Bu adımda önemli olan, Mutation Report Publisher eklentisinin yüklenmesi. 123steps:- task: stryker-mutator.mutation-report-publisher.44d9cfb7-7efd-48e2-b2ae-4750950271be.PublishMutationReport@0 displayName: 'Publish Mutation Test Report' Azure Pipelines kısmında yapacaklarımız sadece bu kadar. Pipeline’ımızı Run ettiğimizde aşağıdaki görseldeki gibi Mutation Report sekmesi gelecektir. Bu sekmenin detayında rapor sonucunu görebiliriz. Faydalı olması dileğiyle, başka yazılarda görüşmek üzere :)","link":"/stryker-mutator-ile-mutation-testing-ve-azure-pipelines-entegrasyonu/"},{"title":"WebAssembly - Bize Hızın Anlamını Göster","text":"WebAssembly, kısaca WASM ile web tarayıcılarda C,C++ ve Rust gibi yüksek seviyeli diller ile yazılımış programları derleyebilir, çalıştırabilir ve taşıyabiliriz. Javascript’in performans olarak yetersiz kaldığı noktalarda WASM ile 20 kat daha performanslı işler yapabiliriz. Run Shadowfax WebAssembly, show us the meaning of haste. Gandalf WebAssemblyWebAssembly, kısaca WASM ile web tarayıcılarda C,C++ ve Rust gibi yüksek seviyeli diller ile yazılımış programları derleyebilir, çalıştırabilir ve taşıyabiliriz. Javascript’in performans olarak yetersiz kaldığı noktalarda WASM ile 20 kat daha performanslı işler yapabiliriz. WASM, JavaScript’e eşlik eden bir araç olarak düşünülebilir. Javascript’ten tamamen vazgeçme durumu yok. JavaScript’in esnek olduğu, dinamik olarak yazılabildiği ve okunabilir kaynak koduyla sunulduğu durumlarda, WASM yüksek hızlı, güçlü bir şekilde yazılmıştır ve kompakt bir binary format aracılığıyla sunulmaktadır. WASM’ın sunmuş olduğu native performansı kadar iyi olmasa da, modern JavaScript motorları da oldukça hızlıdır. Büyük miktarda veri sıkıştırması gerektirmeyen çoğu temel web uygulaması ve basit komut dosyaları için hala kabul edilebilir bir performans sergileyebilmektedirler. Temel komutları barındıran basit şeyler için WASM kullanmaya gerek yoktur. Örneğin, bir kullanıcı bir butona tıkladığında bir uyarının tetiklenmesi Javascript tarafından kolaylıkla yapılabilir, saniyede bir milyon kez çalıştırılacak kadar performanslı olması gerekmez ve kesinlikle C, C++ ya da Rust ile yazılmasına gerek yoktur. Ancak, bir masaüstü uygulamasını bir web tarayıcısında çalıştırılacak şekilde geliştirmek istediğinizde, WASM tercih edilen format olacaktır. Yine de, JavaScript hala WASM yöntemlerini çağırmak için gereklidir.Aşağıdaki görselde, face detection uygulamasının WASM ve Javascript kıyaslaması yapılmaktadır. FPS değerlerine bakıldığında WASM çok daha performanslı bir şekilde görüntü işlemesi gerçekleştirebilmektedir. Yine bahsetmek gerekirse; masaüstü uygulamaların web uygulamalarına göre daha performanslı çalıştığı bilinir. Karmaşık ve yüksek CPU gerektiren işlemleri barındıran programlar genellikle masaüstü uygulamalarıdır. Masaüstü uygulamalarını native olarak sınıflandırırsak, WASM ile native performansa yakın ve web ortamında çalışan uygulamalar geliştirmek amaçlanmıştır. Günümüzde popüler bir çok web tarayıcısı WASM’ı desteklemektedir. WASM’dan önce Google’ın Native Client‘ı ve Mozilla’nın da asm.js isimli teknolojileri ile native performansı sağlanmaktaydı. Tabii doğal olarak Google’ın odak noktası Chrome ve Mozilla’nınki ise Firefox’tu. Öncelikli olarak kendi tarayıcılarında çalışacak bir sistem geliştirmişlerdi. Bunlara kısaca değinmek gerekirse: Google, native kodu bir web tarayıcısında güvenli bir şekilde çalıştırmak amacıyla Native Client’ı (NaCl) geliştirmiştir. Yürütülebilir kod sanal bir alanda çalışır ve native kod yürütmenin performans avantajlarını sunabilmektedir. NaCl, belirli bir mimariye bağlıyken, Portable Native Client (PNaCl), herhangi bir platformda çalışmak üzere geliştirilmiş, NaCl’nin mimariden bağımsız bir versiyonudur. Mozilla ise, asm.js’i 2013’te piyasaya sürdü ve geliştiricilere C veya C++ kaynak kodlarını JavaScript’e çevirmeleri için bir yol sağlamıştır. asm.js, derleyiciler için düşük seviyeli, verimli bir hedef dil olarak kullanılabilen katı bir JavaScript alt kümesi olarak tanımlanmaktadır. 2015 yılında, web standartları geliştirmek için kurulmuş uluslararası bir topluluk olan World Wide Web Consortium’un (W3C) organize etmiş olduğu ve Google, Mozilla, Apple ve Microsoft’un katılımlarıyla gerçekleştirilen WebAssembly Community Group buluşmasıyla WASM’ın temelleri atılmış oldu. Artık navite performansı popüler tarayıcıların hepsinde desteklenir hale gelmiştir. Web tarayıcılarında WASM desteğinin uygulanması asm.js’e ve PNaCl’nin dağıtılmış yürütülebilir dosya konseptine dayanmaktadır. Aşağıdaki görselde yine aynı face detection uygulamasının WASM, asm.js ve Javascript kıyaslaması yapılmaktadır. FPS değerlerine bakıldığında WASM çok daha performanslı bir şekilde görüntü işlemesi gerçekleştirebilmektedir. WebAssembly Nasıl Çalışır?WASM, yaratıcılarının deyimiyle bir “derleme hedefi” dir. Doğrudan WebAssembly yazmamıza gerek yoktur. Seçtiğimiz yüksek seviyeli dilde yazarız ve daha sonra WASM bayt kodu olarak derlenir. Bayt kod daha sonra client üzerinde çalıştırılır ve burada yerel makine koduna çevrilir ve yüksek hızda yürütülür. WASM herhangi bir özel makine için tasarlanmadığı için tam anlamıyla bir assembly dili değildir. Tarayıcılar içindir ve tarayıcıda yürütülecek kodu teslim ederken, kodunuzun ne tür makinelerde çalışacağını bilemeyiz. Tarayıcı WASM kodunu indirdiğinde, kodu hızla herhangi bir makinenin anlayabileceği bir dile dönüştürür. C, C++ veya Rust ile yazdığımız kodlar WASM metin formatı olan .wat dosyalarına dönüştürülür. Tarayıcıya ise bu dosyanın binary hali olan .wasm dosyası sunulmaktadır. Örneğin, aşağıdaki kod parçasında C++ ile faktöriyel hesaplaması yapan recursive bir fonksiyonu .wat ve .wasm formatına dönüştürülmüş halini görebilirsiniz. Binary olan .wasm, text olan ise .wat dosyasına aittir. .wasm ve .wat dosyalarını herhangi bir WasmExplorer aracılığıyla elde edebilirsiniz. Ayrıca, Emscripten kullanarak da derleme yapabilirsiniz. Emscripten, hıza, boyuta ve Web platformuna özel odaklanan, LLVM kullanan, WASM için eksiksiz bir derleyici toolchain’dir. Emscripten kurulumunu yaptıktan sonra aşağıdaki basit CLI komutu ile C ile yazdığınız kodu WASM dosyasına dönüştürerek tarayıcı üzerinden kullanılabilir hale getirebilirsiniz. emcc hello.c -s WASM=1 -o hello.html Gerçek Dünyadan Güzel Bir ÖrnekBir çoğumuzun bildiği sanal seyahat imkanı sunan Google Earth, Haziran 2019’daki Medium yazısına (Preview Google Earth on web across browsers) göre WASM ile beta sürümünü yayınladı. Google Earth, önceki versiyonunda NaCI kullanıldığı için, sadece Chrome tarayıcılarda kullanılabiliyordu, artık sadece Chrome’da değil Opera, Edge ve Firefox tarayıcılarda da kullanılabilir hale getirildi. Safari tarayıcısında da desteklenmesi için çalışmalar hala devam etmektedir. Aşağıdaki görselde göreceğiniz üzere Google Earth Web uygulamasını tarayıcımızda açtığımızda yüklenen dosyalar arasında .wasm dosyasını da görebilirsiniz. Son Birkaç SözWebAssembly ile C, C++ ve Rust dillerinin dışında diğer popüler dillerle de geliştirme yapmak mümkün. Örneğin; C# ile Blazor F# ile Bolero Haxe ile WebIDL Java ile TeaVM ya da Bytecoder Kotlin ile TeaVM TypeScript ile AssemblyScript WebAssembly konusunda çok fazla detaya girmeden, olabildiğince sade anlatmaya çalıştım. Detaylara girdikçe işin içerisinden çıkmak çok mümkün olmuyor. :) Umarım faydalı olmuştur. Kaynaklar https://www.infoworld.com/article/3291780/what-is-webassembly-the-next-generation-web-platform-explained.html https://webassembly.org/docs/faq/ https://medium.com/google-earth/google-earth-comes-to-more-browsers-thanks-to-webassembly-1877d95810d6 https://hacks.mozilla.org/2017/09/bootcamps-webassembly-and-computer-vision/ https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71/","link":"/webassembly-bize-hizin-anlamini-goster/"},{"title":"Yapay Zeka’ya Güvenebilir miyim? — Explainable AI","text":"Asıl konumuza giriş yapmadan önce kısaca Yapay Zekanın ne demek olduğunu hatırlayalım; Yapay Zeka, bir çıktı elde etmek için insan zekası gibi davranan ve elde ettiği bilgilere göre yinelemeli olarak kendisini sürekli geliştirebilen sistem veya makinedir. Tekrarlanan öğrenme ve verisel keşif süreci ile birçok gizli katmana sahip sinir ağlarını kullanarak daha fazla ve daha derin verileri analiz eder. Bu noktada, Yapay Zekanın en önemli özelliği bağımsız öğrenme yeteneğidir diyebiliriz. Yapay Zeka, bağımsız öğrenme yeteneği ile algoritmalar oluşturarak karar verir. Karar verme sürecinde faydalandığı algoritmanın tam olarak ne olduğunu ve aldığı kararın gerekçelerini tam olarak bilemeyiz. Bu da Yapay Zekanın arkasındaki kara kutudur. Bu kara kutunun içerisinde neler olup bittiğini bilemiyoruz. Örneğin, aşağıdaki görselde de göreceğiniz üzere, daha önceden eğitilmiş bir Yapay Zekaya girdi olarak verilen bir fotoğrafın analiz süreci yer almaktadır. Kara kutu olarak belirtilen yer, Yapay Zekanın öğrenme sürecinde kendisine çıkardığı algoritma yer almaktadır. Buradaki algoritmanın nasıl işlediğini Yapay Zekayı geliştiren mühendis bile tam anlamıyla bilmemektedir. Nuance yöneticisi Nils Lenke, Yapay Zekanın kara kutusu hakkında şöyle diyor; İçerde ne olduğu her zaman açık değildir, siz Yapay Zekanın kendi kendini düzenlemesini sağlarsınız. Ancak bu durum, kendi geliştirirken size bunu nasıl yaptığını söyleyeceği demek değildir. 1950’lerden günümüze kadar Yapay Zeka alanında birçok çalışma yapılmıştır. Bu doğrultuda Yapay Zekanın kullanım alanı her geçen gün daha da genişledi ve güvenlik, sağlık, otomotiv, otomasyon, bilgi teknolojileri ve finans gibi birçok sektörde kullanılmaya başlandı. Gelişen teknoloji ve değişen ihtiyaçlar nedeniyle, her geçen gün Yapay Zekadan daha fazla şey beklenilmektedir. Bu ihtiyaçlardan bir tanesi de, Yapay Zekanın almış olduğu karara duyulan güvendir. Problemi çözmesinin yanı sıra Yapay Zekanın arkasında nelerin olup bittiğini açıklanması da beklenmektedir. Bu noktada işin içerisine, Yapay Zekanın kara kutusu içerisinde nelerin olup bittiğini, Açıklanabilir Yapay Zeka (Explainable AI — XAI) yaklaşımı ile ifade etme süreci devreye girmektedir. Aşağıdaki görsellerde Açıklanabilir Yapay Zeka öncesi ve sonrası basit olarak ifade edilmiştir. “Önce” olarak isimlendirilen görsele Kara Kutu Yapay Zeka (Blackbox AI), “Sonra” olarak isimlendirilen görsele ise Açıklanabilir Yapay Zeka (Explainable AI) diyebiliriz. Açıklanabilir Yapay Zeka sistemleri, ek bilgi sağlayan veya makine öğrenimi sisteminin iç işleyişine özgü verileri sunan bir arayüz sağlar. Bu sayede insanların bu karara Yapay Zeka tarafından nasıl ve neden ulaşıldığını anlamasına yardımcı olur. SAS başkan yardımcısı Keith Collins, Açıklanabilir Yapay Zekayı şöyle ifade etmektedir: Açıklanabilir Yapay Zeka terimi, insanların yapay zeka teknolojisinin bir karar vermek için izlediği yolu dinamik olarak oluşturulmuş grafikler veya metinsel açıklamalar aracılığıyla kolayca anlayabilmesini ifade eder.Açıklanabilir Yapay Zeka yaklaşımı ile yorumlanabilirlik, şeffaflık ve açıklanabilirlik sağlanmaya çalışılmıştır. Ancak bilindiği üzere Yapay Zeka yapay sinir ağlarından oluşmaktadır. Küçük bir sinir ağını açıklamak nispeten daha kolayken, yüzlerce belki de binlerce katmana sahip bir derin sinir ağını açıklamak oldukça zor olmaktadır. Bu noktada Yapay Zekadaki açıklanabilirlik karmaşıklığa bağlıdır diyebiliriz. Genel olarak, daha karmaşık Yapay Zeka sistemleri daha doğrudur ancak daha az açıklanabilirken, daha az karmaşık modeller ise daha az doğrudur ancak daha açıklanabilirdir. Kısaca, açıklanabilirlik ve karmaşıklık arasında ters orantı vardır. Açıklanabilir Yapay Zeka sistemlerinden bunun dengeli olması faydalı olacaktır. Açıklanabilir Yapay Zekanın Mevcut ve Potansiyel Kullanım AlanlarıAçıklanabilir Yapay Zekaya Yapay Zekanın kullanıldığı bir çok alanda ihtiyaç duyulabilir. Bu ihtiyacın ortaya çıkmasındaki asıl neden Yapay Zekaya duyulan güvendir. Yapay Zekanın, karar verme aşamasında tüm kontrolün bir algoritmalarda olması bazı problemlere neden olabilmektedir. Örneğin; otonom bir araç bir kazaya neden olursa bunun sorumlusu kim olacaktır? Yolcuları, Yapay Zekanın almış olduğu karardan sorumlu tutamayız. Ancak otonom araç almış olduğu kararları açıklayarak durumu netleştirebilir. Tabi böyle karmaşık bir durumu açıklamak üreticiler için bir hayli zor olacaktır. Benzer bir durum, bir hastanın iyileşme sürecinin kontrolüne otomatik olarak sahip olan Yapay Zeka uygulamaları için de söylenebilir. Kısacası, Açıklanabilir Yapay Zeka yaklaşımı Yapay Zekanın olduğu her yerde olabilir. Yapay Zeka, pazarlamada, otomotivde, sigortacılık ve finansta, sağlıkta, siber güvenlikte, askeri savunmada ve aklımıza gelebilecek birçok alanda kullanılmaktadır. Bunların hepsinin temelinde Yapay Zeka ve dolayısıyla yapay sinir ağları vardır. Kara kutu olarak isimlendirdiğimiz Yapay Zekanın bilinmezinin açıklanması gerektiği tüm durumlarda Açıklanabilir Yapay Zeka kullanılabilir. Tabi burada Yapay Zeka sisteminin kullanıldığı sürecin kritiklik derecesine bağlı olarak değişebilmektedir. Yapay Zekanın en önemli özelliği bağımsız öğrenme yeteneğidir. Bağımsız öğrenme yeteneği sayesinde girdi olarak verilen verileri analiz ederek çıkarımlarda bulunur. Daha öncede bahsettiğimiz üzere kara kutuda neler olup bittiğini kimse bilemez. Bu da Yapay Zekaya güven sorununu ortaya çıkarmaktadır. Örneğin, Amazon tarafından iş başvurularını incelemek için geliştirilen bir Yapay Zeka sistemi, kadın adayları erkek adaylara kıyasla sürekli olarak geri plana atmıştır. Sistem, özellikle erkek adaylar tarafından aşırı doldurulan tarihsel veriler üzerine eğitilmiştir. Sonuç olarak, sistem kadınlara karşı önyargılı kararlar almıştır. İşin ilginç tarafı ise, cinsiyet belirleyici özellikler kaldırıldıktan sonra bile (örneğin ad ve cinsiyet) sistemin hala aynı sonucu vermesiydi. Sistem, erkek adayların kadın adayların kullanmadığı belirli kelimeleri veya cümleleri kullanma eğiliminde olduklarını tespit etmiştir. Erkek adaylar başarılarını anlatmak için daha özgüvenli ve otoriter bir dil kullanırken, kadın adaylar yetenekleri konusunda daha temkinli bir dil kullanmışlardı. Benzer şekilde, 2018 UC Berkley çalışması, kredi başvurularını onaylamaya yönelik geleneksel ve makine tabanlı sistemlerin, Latin ve Afroamerikalı borçlulara eşdeğer bir Kafkas borçlusundan 6–9 baz puan daha yüksek faiz oranları uyguladığı sonucuna varmıştır. Bu sadece ahlaki açıdan yanlış değildir, görünüşte ten rengiyle bağlantılı tespitler yapmakla kalmıyor. Bu durumda, ahlaki açıdan adil olma, ancak aynı zamanda yasal olarak uyumlu olma ihtiyacı vardır. Açıklanabilir Yapay Zeka Alanında Yapılan ÇalışmalarÇok uzun zamandır bilim ve mühendislikte kullanılan klasik kara kutu analizi yaklaşımlarından Derin Sinir AğlarI için tasarlanmış en son yöntemlere kadar, açıklama üretmek için bir dizi yöntem mevcuttur. Bu alanda yapılan en önemli çalışmalar şunlardır; LIMELIME (Local Interpretable Model-Agnostic Explanations), modelden bağımsızdır, yani herhangi bir makine öğrenimi modeline uygulanabilir. Teknik, veri örneklerinin girişini bozarak ve tahminlerin nasıl değiştiğini anlayarak modeli anlamaya çalışır. Herhangi bir sınıflandırıcı veya regresörün tahminlerini yerel olarak yorumlanabilir bir modelle yaklaştırarak sadık bir şekilde açıklayabilen bir algoritmadır. Özellik değerlerini değiştirerek tek bir veri örneğini değiştirir ve sonuçta çıktı üzerindeki etkiyi gözlemler. Her veri örneğinden gelen tahminleri açıklamak için bir “açıklayıcı” rolünü yerine getirir. LIME çıktısı, her bir özelliğin tek bir örneklem için bir tahmine olan katkısını temsil eden bir dizi açıklama olup, bir yerel yorumlanabilirlik biçimidir. LIME ile yorumlanabilir modeller, örneğin, iyi bir yerel yaklaşım sağlamak için orijinal modelin küçük düzensizlikleri (bu düzensizlikler; gürültü ekleme, sözcükleri çıkarma, görüntünün parçalarını gizleme olabilir) üzerine eğitilmiş doğrusal regresyon veya karar ağaçları olabilir. SHAPSHAP, SHapley Additive Explanations’ın kısaltmasıdır. Herhangi bir makine öğrenimi modelinin çıktısını açıklamak için bir oyun teorisi yaklaşımıdır. Oyun teorisindeki klasik Shapley değerlerini ve bunlarla ilgili uzantıları kullanarak optimum kredi tahsisini yerel açıklamalarla birleştirir. Shapley değerleri, yaklaşım için bir ağırlıklandırma çekirdeği kullanan Kernel SHAP ve bunları yaklaştırmak için DeepLift kullanan DeepSHAP kullanılarak yaklaşık olarak hesaplanmaktadır. FairlearnMicrosoft’un Fairlearn isimli projesi, veri bilimcilerinin ve geliştiricilerin yapay zeka sistemlerinin adilliğini değerlendirmelerini ve geliştirmelerini sağlayan popüler bir Açıklanabilir Yapay Zeka araç setidir. Araç setinin iki bileşeni vardır: etkileşimli bir görselleştirme panosu ve adaletsizliği azaltma algoritmaları. Esas olarak adalet ve model performansı arasındaki dengeyi sağlamaya yardımcı olmak için tasarlanmıştır. Açık kaynak araç seti, bir AI modelinin çeşitli insan grupları üzerindeki etkilerini değerlendirmek için hem sınıflandırma hem de regresyon görevlerini içeren geniş bir adalet ölçütleri yelpazesini desteklemektedir. WhiteNoiseWhiteNoise, Harvard Üniversitesindeki araştırmacılarla işbirliği içinde Microsoft tarafından geliştirilen, küresel farklı özel sistemler oluşturmak için farklı bileşenler içeren farklı bir gizlilik platformudur. Microsoft, Build 2020 konferansı sırasında daha açıklanabilir yapay zeka sistemlerine yönelme çabasıyla bu aracı açık kaynaklı olarak kullanmıştır. Core ve System gibi iki üst düzey bileşenden oluşan açık kaynaklı bir projedir. Core kütüphane, farklı şekilde özel bir sistemi uygulamak için gizlilik mekanizmaları içerir, System kütüphanesi ise, tablo şeklinde ve ilişkisel verilerle çalışmak için araçlar ve hizmetler sağlar. ERASERERASER (Rationales And Simple English Reasoning), Salesforce tarafından geliştirilen, rasyonelleştirilmiş doğal dil işleme (NLP) modellerinin değerlendirilmesine yardımcı olan Açıklanabilir Yapay Zeka çalışmasıdır. Kıyaslama, yedi farklı NLP veri setinden ve tahminler için destekleyici kanıt olarak açıklamaların insan açıklamalarını içeren görevlerden oluşur.ERASER’a dahil edilen tüm veri kümeleri, farklı sayıda etiketle diğerlerinin yanı sıra duyarlılık analizi, doğal dil çıkarımı ve soru cevaplama görevlerini içeren sınıflandırma görevleridir ve bazılarının farklı sınıf etiketleri vardır. Ayrıca, kıyaslama, doğru çıktıyı tahmin etmek için yeterli kanıt sağlayan görevin kaynak belgesinden çıkarılan metin parçacıkları olan “gerekçelere” odaklanır. COVID-NetSon zamanlarda, AI şirketi olan DarwinAI, Açıklanabilir Yapay Zeka platformlarında COVID-Net ve COVIDNet-S’yi geliştirdi. 2020 Mart ayında, COVID-Net, COVID-19 vakalarının göğüs röntgeni (CXR) görüntülerinden algılanması için özel olarak tasarlanmış derin bir evrişimli sinir ağı tasarımıdır. Araştırmacılar, modelin yanı sıra, 13870 hasta vakasında 13975 CXR görüntüsünü içeren, oluşturulan açık erişimli bir karşılaştırma veri kümesi olan açık kaynaklı COVIDx’i de kullandı. 2020 Eylül ayında DarwinAI, COVID-19’un hastalık şiddetini değerlendirmek için Açıklanabilir Yapay Zeka platformlarında tasarlanmış bir derin öğrenme modelleri paketi olan COVIDNet-S’yi duyurdu. COVIDNet-S, göğüs röntgeninin temel görsel göstergelerini analiz ederek hastanın akciğerlerindeki coğrafi ve opasite boyutunu nicel olarak puanlayabilir. Sistem, 10000’den fazla göğüs röntgeni kullanılarak geliştirildi ve bunların yüzlercesi kapsamlı akciğer hastalığı şiddet değerlendirmelerine sahip COVID-19 pozitif hastalardan oluşuyor. Kaynaklar https://www.oracle.com/tr/artificial-intelligence/what-is-artificial-intelligence.html https://bilimfili.com/yapay-zekanin-kalbindeki-karanlik-sir https://www.sas.com/tr_tr/insights/analytics/yapay-zeka-nedir.html https://www.karel.com.tr/blog/yapay-zeka-karsilastigi-sorunlari-asabilecek-mi https://lawtomated.medium.com/explainable-ai-all-you-need-to-know-the-what-how-why-of-explainable-ai-dcf2287a9f6c https://www.sunsavunma.net/darpa-yapay-zeka-projesi/ https://analyticsindiamag.com/top-milestones-on-explainable-ai-in-2020/","link":"/yapay-zekaya-guvenebilir-miyim-explainable-ai/"},{"title":"Blockchain — Interoperability","text":"Blockchain Nedir?Basit bir ifadeyle; şifrelenmiş bir şekilde işlem takibi sağlayan ve merkezi olmayan büyük bir veritabanı olarak tanımlayabiliriz. Bu büyük veritabanında veriler bloklar halinde tutulur. Hiçbir şekilde verilerin değiştirilmesi söz konusu değildir. Sadece okuma ve yazma işlemleri yapılır. Eğer hatalı bir işlem yapıldıysa, bu hatalı işlem de bloklara eklenir. Çeşitli verilerin barındırıldığı bloklar bir araya geldiğinde block zinciri meydana gelir. Örneğin, para transfer işlemlerinde her adım bir bloğu karşılık gelir. Bu adımlar takip edilerek paranın alıcılar arasında nasıl bir yol izlediği görülür. Blockchain sayesinde, bir aracıya ihtiyaç duyulmayan ve güvenin maksimum edildiği bir ortam sağlanmış olur. Şekil.1 — Örnek bir Blockchain TarihçeBiraz işin tarihçesinden bahsedelim; blockchain teknolojisi, 1980 yılında Ralph Merkle’in meşhur makalesi ile başlayan çözülmesi çok zor kripto para ve şifreli ağlar ile başladı. 1991 yılına gelindiğinde ise W. Scoot Stornetta ve Stuart Haber isimli iki bilim adamının dijital belgelerin zaman damgası ile karıştırılamaz ya da geriye dönük olarak değiştirilemez şekilde imzalanması fikri konuya dahil oldu. Bu gelişmelerin üzerine 1992 yılında Ralph Merkle’nin bahsetmiş olduğu Merkle Ağacı ya da Hash Ağacı olarak isimlendirilen yapıdan faydalanılarak birtakım belgelerin bir blok şeklinde bir arada toplanması sağlanmış ve bu durum sistemi daha verimli hale getirmiştir. Ancak tüm bu gelişmelere rağmen bu teknoloji kullanılmamış ve 2004 yılında sonlanmış. 2008 yılının son çeyreğine gelindiğinde, Lehman Brothers’ın iflasından sadece iki ay sonra, Bitcoin olarak isimlendirilen merkezi olmayan, eşler arası (P2P) dijital para sistemini açıklayan bir manifesto, Satoshi Nakamoto takma isimli kişi veya kişiler tarafından yayınlandı. 3 Ocak 2009 tarihinde Bitcoin’in ilk bloğu (Genesis) Satoshi Nakamoto tarafından oluşturuldu ve bu işlem ona 50 Bitcoin kazandırdı. Blockchain’in Temel ÖğeleriDağıtık Büyük VeritabanıAğdaki tüm katılımcılar, bu veritabanına ve değişmez işlem kayıtlarına erişebilirler. Paylaşılan bu veritabanında işlemler sadece bir kaydedilir. Değişmez KayıtlarBir işlem, paylaşılan veritabanına kaydedildikten sonra hiçbir katılımcı tarafından değiştirilemez veya kurcalanamaz. Eğer bir işlem kaydı hata içeriyorsa, bu değiştirilemeyeceği için hatayı tersine çevirmek gerekir, bunun için yeni bir işlem eklenmelidir ve her iki işlem de görünür hale gelecektir. Akıllı Sözleşmelerİşlemleri hızlandırmak için, akıllı sözleşme adı verilen bir dizi kural, Blockchain’de depolanır ve otomatik olarak yürütülür. Bir akıllı sözleşme, bloklarla ile ilgili olan her türlü şartı içerebilir. Interoperability(Farklı Blockchain Ağlarının Birlikte Çalışabilmesi)Günümüzde, blok zincirlerinin sayısı gitgide artıyor. Bununla birlikte bu blok zincirleri kendi izole ortamlarında çalışmaya ve büyümeye devam ediyor. Bir block zincirinin başka bir blok zincirindeki veriye olan ihtiyacı Interoperability kavramını ortaya çıkarmıştır. Buradan hareketle, Interoperability, kısaca, blockchain ağları arasında bilgileri kolayca paylaşma ve işlem yapma kabiliyetidir diyebiliriz. Başka bir ifadeyle, birlikte çalışabilirlik, tüm blockchain ağlarında serbestçe bilgi paylaşma yeteneğidir. En genel anlamıyla ise, Interoperability, farklı bilgi sistemlerinin, cihazların ve uygulamaların verilere, kurumsal, bölgesel ve ulusal sınırlar içinde ve ötesinde, koordineli bir şekilde, bilgiye zamanında, kesintisiz bir şekilde taşınabilirlik sağlama, erişme, bütünleştirme ve işbirliği içinde kullanma becerisidir diyebiliriz. Tamamen birlikte çalışabilir bir ekosistemde, başka bir blok zincirinden bir kullanıcı, blok zincirine bir şey gönderirse, o kullanıcıyı kolayca tanıyıp ve etkileşime geçebiliriz. Blok zincirlerinin birlikte çalışması bir nevi onların birleşmesi demektir. Bu birleşmedeki amaç, birlikten güç doğmasını sağlamak. Yani blok zincirlerindeki kullanıcı sayısını çoğaltmak. Birleşme sonucunda kullanıcılara pek çok pratik fayda sağlanır ve kullanıcı adaptasyonu artırılır. Hali hazırda, blok zincirleri arasında birlikte çalışabilirliği sağlamak için üç teknik mevcut. Bunlar; Notary schemes, Sidechains / Relays ve Hash-Locking teknikleridir. Notary schemes (Noter şemaları), blok zincirleri arasında güvenilir bir varlık kullanılmaktadır. Buradaki noterin rolü, blok zincirinde bir olayın gerçekleştiğini doğrulamak ve bu bilgileri başka bir blok zincirine aktarmaktır. Noter şemasının bize sağladığı en büyük fayda, basitliğidir. Çünkü, blok zincirinin temel uygulamasında herhangi bir değişikliğe ihtiyaç duyulmaz. Dezavantajı ise, notere güvenmek zorunda olmamızdır. Sidechains (Yan zincirler) / Relays, diğer blok zincirlerinin durumu hakkında bilgileri doğrulama ve işleme yeteneği sağlar. Bu işlem, teknik olarak, Simpliﬁed Payment Veriﬁcation (Basit Ödeme Doğrulaması) kullanılarak gerçekleştirilir. Simpliﬁed Payment Veriﬁcation, tüm defteri indirmek zorunda kalmadan başka bir blok zincirinde bir işlem olup olmadığını doğrulamak için blok başlıkları ve Merkle ağaçları kullanan bir sistemdir. Verilerin harici olarak bir blok zincirinden diğerine aktarılması gerekse de, bu işlem için gevene ihtiyaç duyulmaz. Şekil.2 — Sidechain (Yan zincir) Bilindiği üzere, blok zincirlerinin kriptografik özellikleri nedeniyle, verilerin kurcalandığını anlamak kolaydır. Ayrıca, iki blok zinciri arasındaki değiş tokuşlar, “Pegged sidechains” ile etkinleştirilebilir. Bu şema, varlıkların bir blok zincirinde kilitlendiğine dair bir kanıt oluşturur, böylece ikinci bir blok zincirinde aynı miktarda işlem yapılabilir. Bunun yanında, bir yan zincir oluşturmak için akıllı sözleşme yetenekleri de gerekli. Tam birlikte çalışabilirlik sağlamak için, her blok zinciri, diğer tüm blok zincirlerini desteklemesi gereken bir yan zincire ihtiyaç duyar. Büyüyen bu sistemin bakımı doğal olarak büyük bir zorluk haline geliyor. Sidechains Avantajları;En önemli iki avantajları var. Sahip oldukları ilk avantaj, sonsuz olmalarıdır. Her seferinde bir tane kullanmanız gerektiğinde yeni bir Sidechain oluşturmanız gerekmez. Bir Sidechain oluşturulduktan sonra korunur ve ana zincirden belirli bir görevi yapan herkes tarafından kullanılabilir.İkinci avantajı ise, farklı kripto para birimleri arasında etkileşim kurmayı kabul etmeleridir. Geliştiriciler, ana zincirde yayınlanmadan önce yazılım sürümlerini ve beta coin sürümlerini test etme şansına sahip olurlar. Sidechains Dezavantajları;Yan zincirlerin korunmasını sağlamak için madencilere ihtiyaç duyulur. Bu, yeni Sidechain’lerin düzenlenmesini pahalı bir girişim haline getiriyor. Herhangi bir yeni Sidechain oluşturulmadan önce büyük miktarlarda yatırım yapılmalıdır. Hash-Locking, iki işlem veya aracısı olmayan daha fazla taraf arasındaki ticarete izin veren bir tekniktir. Bir başka ifadeyle, Lightning Networks’ten türetilen bir karma değerin düz metnini tahmin etmek için bir süre kilitleyerek ödeme yapmak için bir mekanizmadır.Çoğu senaryoda zincirler arası varlık alışverişini ve zincirler arası varlık yayılımını desteklese de, zincirler arası varlık taşınabilirliği ve zincirler arası akıllı sözleşme için kullanılamaz. Bu birlikte çalışabilirlik için en pratik teknik yöntemdir, ancak işlevsellik açısından da en sınırlayıcı olanıdır, sadece dijital varlık değişimini destekler. Bu teknik günümüzde çoğu merkezi olmayan borsa tarafından kullanılıyor. Hash-Locking dezavantajı;Blok zincirinin Hash-TimeLock Sözleşmesi (HTLC) adı verilen bu tür akıllı sözleşmeyi desteklemesi gerektiğidir. Ayrıca, işlemler esnasındaki bekleme süresi taraflar arasında düşen veya artan fiyatlar üzerinde spekülasyon yapılarak kullanılabilir. Interoperability SeviyeleriFoundational Level (Temel Seviye): Bir sistem veya uygulamanın güvenli bir şekilde diğerine veri iletmesi ve diğerinden veri alması için gereken bağlantılar arası gereksinimleri belirler. Structural Level (Yapısal Seviye): Yorumlama için veri alanı seviyesinde olmak üzere veri alışverişinin biçimini, sözdizimini ve organizasyonunu tanımlar. Semantic Level (Anlamsal Seviye): Ortak kullanılan modeller ve kodlama sağlar, veri halka açık değer kümelerinden standart tanımlamalar ve kodlama kelime dağarcığı kullanımı da dahil olmak üzere, kullanıcıya ortak bir anlayış ve anlam sağlar. Organizational Level (Örgütsel Seviye): Kuruluşlar, kurumlar ve bireyler arasında güvenli, kesintisiz ve zamanında iletişim ve veri kullanımını kolaylaştırmak için yönetişim, politika, sosyal, yasal ve organizasyonel hususları içerir. Bu bileşenler paylaşılan onay, güven ve entegre son kullanıcı süreçleri ve iş akışlarını mümkün kılar. Interoperability Neden Önemlidir?Blok zincirinde, birlikte çalışabilirlik, kullanıcı dostu bir deneyim sağlar ve böylece benimsenmeyi artırır. Cüzdanlar aracılığıyla çok tokenli işlemler sağlar ve kullanıcıların tek bir pencerede birden fazla para birimiyle çalışmasını sağlamak için zincirler arası bilgi alışverişini sağlar. Birlikte çalışabilirlik olmadan, bağlantısız sistemler iletişim kurmadan veya işlem yapmadan birbirleriyle birlikte çalışan bağımsız silolar olacaktır. Birlikte çalışabilir bir ekosistem, ayrı blok zinciri ağlarından gelen birden çok kullanıcının, alınan bilgileri tercüme etmek ve kesinti yaşamak için kaynak harcamadan etkileşim kurmasını sağlar. Bilgilerin işlenmesini ve buna göre bir yanıtın gönderilmesini sağlar. Blockchain birlikte çalışabilirliğinin temel faydaları: Katılımcı blok zincirleri arasında kesintisiz bilgi alışverişi sağlanır. Akıllı sözleşmeler zahmetsizce yapılabilir. Blok zinciri ekosistemi içinde ortaklıklar geliştirilebilir. BT personeli, bazı önde gelen standartlar hakkında iyi bir anlayış geliştirebilir. Blockchain Ağlarının Dış Sistemler ile Entegrasyonunda Dikkat Edilmesi GerekenlerBlok zinciri ağlarının üç türü vardır, bunlar; Public Blockchain (Genel Blokzincir), Private Blockchain (Özel Blokzincir) ve Federated/Consortium Blockchain (Birleşik / Konsorsiyum Blokzincir)’dir. Genel bir blokzincir, Bitcoin tarafından tanıtıldığı gibi hepimizin bildiği ve sevdiği standart blokzincir ağıdır. Adından da anlaşılacağı gibi, ağ herkese açıktır ve merkezi bir yönetim yoktur. Sistem şu şekilde çalışır: Herkes ağa erişebilir ve tamamen merkezi olmayan, izinsiz ve açık kaynaklı bir sistem olduğu için blok zincirini okuma, yazma ve denetlemeye katılabilir. Ayrıca, herkes belirli bir noktada işlem oluşturabilir, doğrulayabilir ve görüntüleyebilir. İşlemleri doğrulamak için, karar alma Çalışma Kanıtı (PoW) veya Kanıt Kanıtı (PoS) gibi bir konsensüs algoritması ile gerçekleşir. Ağ halka açık olmasına rağmen, katılımcıların kimliği takma addır. Bununla birlikte, katılımcıların anonimliği, hem avantaj hem de dezavantajdır, çünkü bu, kötü niyetli işlemleri içerebilir ve sistemin itibarını tehdit edebilir. Halka açık blokzincir ağını kullanan blokzincir uygulamalarına örnek olarak Bitcoin, Litecoin, Ethereum ve bilinen diğer tüm alternatif dijital para birimleri verilebilir. Özel bir blokzincir, bir kişiye veya kuruluşa ait izin verilen ve kapalı bir sistemdir. Bu tür sistemde, sadece tek yetkili ağ blok zincirini okuyabilir, yazabilir ve denetleyebilir. Merkezi yetkili ayrıca, yalnızca belirli noktalarda işlem yapmak, doğrulamak ve görüntülemek için seçilen düğümlere izinli erişim sağlayabilir. Esasen özel olduğu için konsensüs, sorumlu kişinin takdirine bağlı olarak veya bir oylama veya çok partili konsensüs algoritması ile elde edilir. Özel blokzincir ağları genellikle veritabanı yönetimi ve denetimi gibi tek bir özel şirketin dahili sistemlerine uygulanır. Özel blok zincirleri, kriptografik denetim ve bilinen kimliklerin avantajını sunar. Bu tür bir sistemin doğası, verileri kurcalamayı zorlaştırır, ancak işlemleri doğrulamayı kolaylaştırır, böylece sistemi daha hızlı ve daha uygun maliyetli hale getirir. Özel bir blokzincir ağına dayanan blokzincir uygulamalarına örnek olarak Bankchain, Monax ve Hyperledger verilebilir. Bir birleşik / konsorsiyum blokzincir, tek özerkliğin kaldırıldığı izin verilen ve gruba ait bir sistemdir ve bunun yerine izinler bir grup şirkete veya bireye verilir. Bu tip sistemde, blok zincirini okumak, yazmak ve denetlemek için önceden seçilmiş düğümlere erişim sağlayacak birden fazla merkez vardır. Yalnızca konsorsiyum üyeleri işlemleri yapabilir, doğrulayabilir ve inceleyebilir. Konsensüs, kuralları katılımcıların anlaşmasına bağlı olan bir oylama veya çok partili konsensüs algoritması ile elde edilir. Birleşik / konsorsiyum blokzincirleri, özel blok zincirlerinin sunduğu aynı faydaları, yani işlemlerin etkinliği ve gizliliği sunar. Bununla birlikte, sadece bir şirkete güç konsolidasyonunu ortadan kaldırma avantajı sağlar. Bu tip blokzincir ağı, organizasyonel işbirliği için idealdir. Özetle, özel ve birleşik / konsorsiyum blokzinciri ağlarının her ikisi de, işlem hızı açısından genel blokzincirlerine göre bir avantaj sunmaktadır. Bununla birlikte, bu ağların hesap verebilirlik ve genel yön gibi kendi sınırlamaları da vardır. Bu yeni blokzinciri ağlarının sundukları, orjinal blokzinciri çerçevesini kullanmaya devam ederken, haklar ve erişim yönetimi için alternatif seçenekler vardır. Diğer bir taraftan, internet dünyasının genelinde görülen güvenlik sorunları blokzinciri sistemleri içinde de geçerlidir. Siber ataklar blokzincirlerini tehdit etmektedir. Örneğin ağ denetiminin büyük çoğunluğu siber saldırı sonucu kötü niyetli bireylerin eline geçerse işlemlerin sıralamasının değiştirilmesi veya bazı işlemlerin kasıtlı olarak işlem dışı bırakılması sağlanabilir veya kişisel veriler tehlikeye girebilir. Birlikte çalışabilirlik konusuna, geliştiriciler açısından bakıldığında; geliştiriciler daha fazla özgürlük için bir blokzinciri oluştururken standartları genellikle yok sayarlar, ancak bu birlikte çalışabilirlik ve iletişim sorunlarına neden olabilir. Birlikte çalışabilirlik için en büyük zorluk, uzlaşma modelleri, akıllı sözleşme işlevselliği ve işlem şemaları gibi farklı parametrelere sahip çoklu blokzinciri ağlarıdır. Bu durumu düzeltmek için devam etmekte olan birkaç standartlaştırma çabası var. IBM ve Microsoft, birlikte çalışabilir bir blok zinciri sağlamak için GS1 tarafından geliştirilen mevcut bir standardı kullanıyor. Bununla birlikte, Enterprise Ethereum Alliance sıfırdan bir standart geliştirmiştir. Blokzincirinin birlikte çalışabilirlik standartlaştırma çabaları iki gruba ayrılabilir: Open protocols (Açık protokoller): üçüncü bir taraf olmadan blok zincirleri arasında iletişime izin veren standart protokoller veya gerekli güven süreçleri. En iyi bilinen açık protokol Atomic takastır. Multi-chain frameworks (Çok zincirli çerçeveler): Genellikle “blokzincirlerinin interneti” olarak adlandırılır, bunlar açık protokollerden daha karmaşıktır. Blok zincirler standartlaştırılmış bir ekosistemin parçası olabilir ve bir birbirleriyle veri ve değer aktarımı yapabilir. Kaynaklarhttps://www.ibm.com/tr-tr/blockchain/what-is-blockchainhttps://startuphukuku.com/blockchain-nedir/http://www3.weforum.org/docs/WEF_A_Framework_for_Blockchain_Interoperability_2020.pdfhttps://bkm.com.tr/wp-content/uploads/2015/06/Sorularlablockchain.pdfhttps://bkm.com.tr/wp-content/uploads/2019/08/15082019_kitap.pdfhttps://cointral.com/tr/blockchain-nedir/https://medium.com/@ahmetseyhan/blockchain-teknolojisine-giri%C5%9F-4d2cbb452342https://www.wanchain.org/blog/the-importance-of-blockchain-interoperability/https://files.ifi.uzh.ch/CSG/staff/scheid/extern/publications/LCN2019-Bifrost.pdfhttps://medium.com/@harish_6956/sidechain-blockchain-641da3474ab3https://medium.com/coinmonks/intervalues-cross-chain-technology-and-multi-chain-integration-will-realize-value-interconnection-698cd04b9b5fhttps://www.himss.org/what-interoperabilityhttps://www.primafelicitas.com/the-challenges-of-blockchain-interoperability/https://www2.deloitte.com/content/dam/Deloitte/tr/Documents/consulting/blokzincir-potansiyelinin-kesfi.pdfhttps://www.infineon.com/dgdl/Infineon-whitepaper-Bringing-security-to-the-world-of-blockchain-Whitepaper-v01_00-EN.pdf?fileId=5546d4626afcd350016b2d605e927265https://www.cnnturk.com/2010/turkiye/03/04/50.milyon.kisinin.kimligi.internette.iddiasi/566233.0/index.html","link":"/blockchain-interoperability/"}],"tags":[{"name":"algoritma","slug":"algoritma","link":"/tags/algoritma/"},{"name":"genetik","slug":"genetik","link":"/tags/genetik/"},{"name":"rating","slug":"rating","link":"/tags/rating/"},{"name":"helper","slug":"helper","link":"/tags/helper/"},{"name":"solid","slug":"solid","link":"/tags/solid/"},{"name":"dropbox","slug":"dropbox","link":"/tags/dropbox/"},{"name":"svn","slug":"svn","link":"/tags/svn/"},{"name":"unittest","slug":"unittest","link":"/tags/unittest/"},{"name":"mock","slug":"mock","link":"/tags/mock/"},{"name":"dbcontext","slug":"dbcontext","link":"/tags/dbcontext/"},{"name":"ef6","slug":"ef6","link":"/tags/ef6/"},{"name":"entityframework","slug":"entityframework","link":"/tags/entityframework/"},{"name":"asnotracking","slug":"asnotracking","link":"/tags/asnotracking/"},{"name":"visualstudio","slug":"visualstudio","link":"/tags/visualstudio/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"pages","slug":"pages","link":"/tags/pages/"},{"name":"customdomain","slug":"customdomain","link":"/tags/customdomain/"},{"name":"mssql","slug":"mssql","link":"/tags/mssql/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"webmaster","slug":"webmaster","link":"/tags/webmaster/"},{"name":"otomatik","slug":"otomatik","link":"/tags/otomatik/"},{"name":"versiyonlama","slug":"versiyonlama","link":"/tags/versiyonlama/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"oracle","slug":"oracle","link":"/tags/oracle/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"update","slug":"update","link":"/tags/update/"},{"name":"storedprocedures","slug":"storedprocedures","link":"/tags/storedprocedures/"},{"name":"devops","slug":"devops","link":"/tags/devops/"},{"name":"webassembly","slug":"webassembly","link":"/tags/webassembly/"},{"name":"blazor","slug":"blazor","link":"/tags/blazor/"},{"name":"yapay-zeka","slug":"yapay-zeka","link":"/tags/yapay-zeka/"},{"name":"artificial-intelligence","slug":"artificial-intelligence","link":"/tags/artificial-intelligence/"},{"name":"explainable-ai","slug":"explainable-ai","link":"/tags/explainable-ai/"},{"name":"aciklanabilir-yapay-zeka","slug":"aciklanabilir-yapay-zeka","link":"/tags/aciklanabilir-yapay-zeka/"},{"name":"blockchain","slug":"blockchain","link":"/tags/blockchain/"},{"name":"blockchain-interoperability","slug":"blockchain-interoperability","link":"/tags/blockchain-interoperability/"}],"categories":[{"name":"Algoritmalar","slug":"Algoritmalar","link":"/categories/Algoritmalar/"},{"name":".Net","slug":"Net","link":"/categories/Net/"},{"name":"Genel","slug":"Genel","link":"/categories/Genel/"},{"name":"C#","slug":"Net/C","link":"/categories/Net/C/"},{"name":".Net","slug":"Algoritmalar/Net","link":"/categories/Algoritmalar/Net/"},{"name":"Tavsiye Programlar","slug":"Tavsiye-Programlar","link":"/categories/Tavsiye-Programlar/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Webmaster","slug":"Webmaster","link":"/categories/Webmaster/"},{"name":"Veritabanı","slug":"Net/Veritabani","link":"/categories/Net/Veritabani/"},{"name":"SQL Server","slug":"SQL-Server","link":"/categories/SQL-Server/"},{"name":"Javascript","slug":"Net/C/Javascript","link":"/categories/Net/C/Javascript/"},{"name":"C#","slug":"Algoritmalar/Net/C","link":"/categories/Algoritmalar/Net/C/"},{"name":"Veritabanı","slug":"Veritabani","link":"/categories/Veritabani/"},{"name":"Visual Studio","slug":"Visual-Studio","link":"/categories/Visual-Studio/"},{"name":"Unit Test","slug":"Net/C/Unit-Test","link":"/categories/Net/C/Unit-Test/"},{"name":"JQuery","slug":"Javascript/JQuery","link":"/categories/Javascript/JQuery/"},{"name":"Javascript","slug":"Webmaster/Javascript","link":"/categories/Webmaster/Javascript/"},{"name":"Veritabanı","slug":"SQL-Server/Veritabani","link":"/categories/SQL-Server/Veritabani/"},{"name":"JQuery","slug":"Net/C/Javascript/JQuery","link":"/categories/Net/C/Javascript/JQuery/"},{"name":"Oracle","slug":"Veritabani/Oracle","link":"/categories/Veritabani/Oracle/"},{"name":"SQL Server","slug":"Veritabani/SQL-Server","link":"/categories/Veritabani/SQL-Server/"},{"name":"Open Source","slug":"Net/C/Javascript/JQuery/Open-Source","link":"/categories/Net/C/Javascript/JQuery/Open-Source/"},{"name":"Devops","slug":"Devops","link":"/categories/Devops/"},{"name":"Javascript","slug":"Genel/Javascript","link":"/categories/Genel/Javascript/"},{"name":"Yapay Zeka","slug":"Yapay-Zeka","link":"/categories/Yapay-Zeka/"}]}